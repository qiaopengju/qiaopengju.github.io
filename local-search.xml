<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OpenGL-Matrix</title>
    <link href="/2021/06/10/OpenGL-Matrix/"/>
    <url>/2021/06/10/OpenGL-Matrix/</url>
    
    <content type="html"><![CDATA[<h3 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h3><ul><li>Scale:</li></ul><script type="math/tex; mode=display">\begin{bmatrix}S_1 & 0 & 0 & 0 \\0 & S_2 & 0 & 0 \\0 & 0 & S_3 & 0 \\0 & 0 & 0 & 1\end{bmatrix}\begin{pmatrix}x_1\\ x2\\ x3\\ 1\end{pmatrix}=\begin{pmatrix}S_1x_1\\ S_2x_2\\ S_3x_3 \\1\end{pmatrix}</script><ul><li>Translate:</li></ul><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & T_x\\0 & 1 & 0 & T_y\\0 & 0 & 1 & T_z\\0 & 0 & 0 & 1\end{bmatrix}\begin{pmatrix}x\\ y\\ z\\ 1\end{pmatrix}=\begin{pmatrix}x+T_x\\ y+T_y\\ z+T_y\\ 1\end{pmatrix}</script><p class="note note-primary">Translate using w(Homogeneous Coordinates-齐次坐标)</p><ul><li><p>Rotate:</p><ul><li>两个向量的内积，在被同一个旋转矩阵M操作后不变，得旋转矩阵是正交矩阵</li></ul><script type="math/tex; mode=display">a^T \centerdot b = (Ma)^T \centerdot (Mb) =a^TM^TMa \\ \Rightarrow M^TM = M^{-1}M=E</script><ul><li>二维向量旋转矩阵：</li></ul></li></ul><script type="math/tex; mode=display">\begin{bmatrix}cos\theta & -sin\theta\\sin\theta & cos\theta\end{bmatrix}</script><p><img src="rotate.png" alt=""></p><p>现在推导<strong>顺时针</strong>旋转$\theta$度的旋转矩阵，将$\vec{OP}$顺时针旋转$\theta$度，相当于将坐标系逆时针旋转$\theta$度：</p><script type="math/tex; mode=display">X_b=OB+BC;\quad OB=X_acos\theta,\quad BC=AD=APsin\theta = Y_a sin\theta\\</script><script type="math/tex; mode=display">\Rightarrow X_b = X_acos\theta + Y_asin\theta\\</script><script type="math/tex; mode=display">Y_b = OF-GF; \quad OF=OE cos\theta=Y_a cos\theta,\quad GF=EH=EP sin\theta = X_a sin\theta\\</script><script type="math/tex; mode=display">\Rightarrow Y_b = - X_a sin\theta + Y_a cos\theta\\</script><script type="math/tex; mode=display">\Rightarrow\begin{pmatrix}X_b\\ Y_b\end{pmatrix}=\begin{bmatrix}cos\theta & sin\theta\\-sin\theta & cos\theta\end{bmatrix}\begin{pmatrix}X_a\\ Y_a\end{pmatrix}</script><p>所以顺时针旋转$\theta$度的矩阵是：</p><script type="math/tex; mode=display">\begin{bmatrix}cos\theta & sin\theta\\-sin\theta & cos\theta\end{bmatrix}</script><p class="note note-danger">逆时针是正角，上述推导为顺时针旋转矩阵</p><p class="note not-info">Transform Order: Scale->Rotate->Translate</p><hr><h4 id="Projection-Matrix"><a href="#Projection-Matrix" class="headerlink" title="Projection Matrix:"></a>Projection Matrix:</h4><p><em>本节内容学习自：[OpenGL Projection Matrix][<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a>]</em></p><p>OpenGL Projection Matirx Task:</p><ul><li>Clip coordinates from view coordinates to clip coordinates;</li><li>Normalize device coordinates</li></ul><h5 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h5><ol><li>project 3D point to <strong>near plane</strong>.</li></ol><p><img src="gl_projectionmatrix03.png" alt=""></p><p><img src="gl_projectionmatrix04.png" alt=""></p><p>发现view坐标系下$x_e,y_e$坐标投影到近平面后，$x_p$和$y_p$都由${-z_e}$做分母，故我们将投影空间的$w_p$设为$-z_e$，因为OpenGL输出每一个空间坐标的最后，都要除齐次坐标$w$.</p><script type="math/tex; mode=display">\begin{pmatrix}X_{ndc}\\ Y_{ndc}\\ Z_{ndc}\end{pmatrix}=\begin{pmatrix}x_{clip}/w_{clip}\\y_{clip}/w_{clip}\\z_{clip}/w_{clip}\\\end{pmatrix}</script><p class="note not-info">NDC: normalized device coordinate 标准设备坐标</p><p>投影空间的$w_p$为$-z_e$，因此Perspective projection Matrix的第四行确定了：</p><script type="math/tex; mode=display">\begin{pmatrix}X_c\\ Y_c\\ Z_c\\ W_c\end{pmatrix}=\begin{bmatrix}\centerdot & \centerdot & \centerdot & \centerdot\\\centerdot & \centerdot & \centerdot & \centerdot\\\centerdot & \centerdot & \centerdot & \centerdot\\0 & 0 & -1 &0\end{bmatrix}\begin{pmatrix}X_e\\ Y_e\\ Z_e\\ W_e(=1)\end{pmatrix}</script><p>之后我们将$X_p,Y_p$从[l, r]映射到[-1, 1]，转换为NDC:</p><script type="math/tex; mode=display">X_{ndc} = \frac{1- (-1)}{r-l} \centerdot X_p + \beta</script><p>将裁剪空间边界r,l带入$X_p$，会分别映射为1, -1:</p><script type="math/tex; mode=display">1 = \frac{2r}{r-l} + \beta</script><script type="math/tex; mode=display">\beta = 1-\frac{2r}{r-l}=-\frac{r+l}{r-l}</script><script type="math/tex; mode=display">X_{ndc} = \frac{2X_p}{r-l} - \frac{r+l}{r-l}</script><p>同理，求得$Y_p$的映射：</p><script type="math/tex; mode=display">Y_{ndc} = \frac{1- (-1)}{t-b} \centerdot Y_p + \gamma</script><p>带入上边界t，映射至NDC的1：</p><script type="math/tex; mode=display">1=\frac{2t}{t-b} + \gamma \Rightarrow \gamma = -\frac{t+b}{t-b}</script><script type="math/tex; mode=display">Y_{ndc} = \frac{2Y_p}{t-b} - \frac{t+b}{t-b}</script><p>之后将再做恒等式变换：</p><script type="math/tex; mode=display">X_n =\frac{2X_p}{r-l} - \frac{r+l}{r-l}=\frac{2\frac{n \centerdot X_e}{-Z_e}}{r-l} - \frac{r+l}{r-l}</script><script type="math/tex; mode=display">X_n = (\underbrace{\frac{2n}{r-l}X_e + \frac{r+l}{r-l}\centerdot Z_e}_{X_c})/-Z_e</script><script type="math/tex; mode=display">Y_n =\frac{2Y_p}{t-b} - \frac{t+b}{t-b}=\frac{2\frac{n \centerdot Y_e}{-Z_e}}{t-b} - \frac{t+b}{t-b}</script><script type="math/tex; mode=display">Y_n = (\underbrace{\frac{2n}{t-b}Y_e + \frac{r+l}{r-l}\centerdot Z_e}_{Y_c})/-Z_e</script><p>分别得到裁剪空间坐标$X_c,Y_c$，现在将Perspective projection Matrix补全：</p><script type="math/tex; mode=display">\begin{pmatrix}X_c\\ Y_c\\ Z_c\\ W_c\end{pmatrix}=\begin{bmatrix}\frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0\\0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0\\\centerdot & \centerdot & \centerdot & \centerdot\\0 & 0 & -1 &0\end{bmatrix}\begin{pmatrix}X_e\\ Y_e\\ Z_e\\ W_e(=1)\end{pmatrix}</script><p>现在我们计算裁剪空间的$Z_c$坐标，需要注意，裁剪空间的$X_c，Y_c$坐标是通过将观察空间的坐标投影到近平面上得到的，近平面的Z坐标恒为-n，所以我们需要不同的方法计算$Z_c$，并且$Z_c$和$Z_e$要是双射。首先$Z_c$肯定和X，Y坐标无关，与$Z_e,W_e$有关，观察空间的$W_e$为1，故$Z_c$只与$Z_e$相关，设：</p><script type="math/tex; mode=display">\begin{pmatrix}X_c\\ Y_c\\ Z_c\\ W_c\end{pmatrix}=\begin{bmatrix}\frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0\\0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0\\0 & 0 & A & B\\0 & 0 & -1 &0\end{bmatrix}\begin{pmatrix}X_e\\ Y_e\\ Z_e\\ W_e(=1)\end{pmatrix}</script><script type="math/tex; mode=display">Z_{ndc} = Z_c/W_c = \frac{AZ_e+BW_e}{-Z_e} =\frac{AZ_e+B}{-Z_e}</script><p>带入近平面远平面$Z_e$被映射为[-1,1]，带入得：</p><script type="math/tex; mode=display">\frac{-An+B}{n}=-1\\\frac{-Af+B}{n}=1</script><script type="math/tex; mode=display">\Rightarrow A=-\frac{f+n}{f-n};\quad B=-\frac{2fn}{f-n}</script><script type="math/tex; mode=display">Z_{ndc} = \frac{-\frac{f+n}{f-n}Z_e-\frac{2fn}{f-n}}{-Z_e}</script><p>注意，$Z_n$和$Z_e$是的关系不是线性的，是成反比的，越靠近近平面Z的精度越高，越远离近平面Z的精度越低，这样会导致深度测试冲突(Z-fighting)。</p><p><img src="gl_projectionmatrix07.png" alt=""></p><p>最后终于得到透视投影的投影矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}\frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0\\0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0\\0 & 0 & -\frac{f+n}{f-n} & -\frac{2fn}{f-n}\\0 & 0 & -1 &0\end{bmatrix}</script><h4 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection:"></a>Orthographic Projection:</h4><p>正射投影不需要对观察空间坐标做过多变换，直接将坐标裁剪并映射到[-1,1]即可。</p><h4 id="View-Matrix"><a href="#View-Matrix" class="headerlink" title="View Matrix"></a>View Matrix</h4><p>定义了摄像机空间的基坐标后，我们将世界坐标系转换为摄像机的坐标系，也就是观察空间坐标，先做平移变换，再做基变换，其中R,U,D,P分别是摄像机的右轴，上轴，方向向量，位置：</p><script type="math/tex; mode=display">LookAt = \begin{bmatrix}R_x & R_y & R_z & 0\\U_x & U_y & U_z & 0\\D_x & D_y & D_z & 0\\0 & 0 & 0 & 1\end{bmatrix}*\begin{bmatrix}1 & 0 & 0 & -P_x\\0 & 1 & 0 & -P_y\\0 & 0 & 1 & -P_z\\0 & 0 & 0 & 1\end{bmatrix}</script><p class="note note-danger">注意，摄像机与世界位移方向相反，所以我们将世界坐标平移-Camera.position</p>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL-learn</title>
    <link href="/2021/05/27/OpenGL/"/>
    <url>/2021/05/27/OpenGL/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p><img src="https://learnopengl.com/img/getting-started/opengl.jpg" width = 200></p><h3 id="OpenGL简介"><a href="#OpenGL简介" class="headerlink" title="OpenGL简介"></a>OpenGL简介</h3><ul><li>实质: 图形规范，并非API；具体由显卡商实现;</li><li>特点: 状态机</li></ul><h3 id="GLAT"><a href="#GLAT" class="headerlink" title="GLAT"></a>GLAT</h3><p>OpenGL具体代码由硬件厂家实现，调用函数时需要实际函数的指针，GLAT库可以用来将函数指向具体实现。</p><p>图形渲染管线</p><p>着色器</p><p>标准化设备坐标</p><p>顶点着色器</p><h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>perspective:透视</p><p>orthographic:正射投影</p><p>frustum:平截头体</p><hr><h3 id="深度测试-Depth-Testing"><a href="#深度测试-Depth-Testing" class="headerlink" title="深度测试 Depth Testing"></a>深度测试 Depth Testing</h3><p>默认禁用，启用深度测试：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl">glEnalbe(GL_DEPTH_TEST);<span class="hljs-comment">// 启用深度测试</span><br>...<br><span class="hljs-keyword">while</span>(renderCondition)&#123;<br>    glClear(GL_DEPTH_BUFFER_BIT);<span class="hljs-comment">// 清除深度缓冲</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>glsl中 gl_FragCoord.z表示片段的深度缓冲值</li></ul><p>禁止深度缓冲写入</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">glDepthMask(GL_FALSE);<span class="hljs-comment">// 深度掩码设为false，禁止写入</span><br></code></pre></td></tr></table></figure><p>深度缓冲将深度值映射到[0, 1]，是非线性函数，物体离平截头体近平面越近，精度越高，离近平面越远，精度越低：$F_{depth} = \frac{1/z - 1/near}{1/far - 1/near}$</p><p><img src="https://learnopengl.com/img/advanced/depth_non_linear_graph.png" alt=""></p><p>深度测试函数，规定在什么情况通过深度测试</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl">glDepthFunc(GL_LESS);<span class="hljs-comment">// default</span><br><span class="hljs-comment">/* parameter:</span><br><span class="hljs-comment">GL_ALWAYS</span><br><span class="hljs-comment">GLNEVER</span><br><span class="hljs-comment">GL_LESS</span><br><span class="hljs-comment">GL_EQUAL</span><br><span class="hljs-comment">GL_LEQUAL</span><br><span class="hljs-comment">GL_GRETER</span><br><span class="hljs-comment">GL_GEAUAL</span><br><span class="hljs-comment">GL_NOTEQUAL</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="深度冲突-Z-fighting"><a href="#深度冲突-Z-fighting" class="headerlink" title="深度冲突 Z-fighting"></a>深度冲突 Z-fighting</h4><p>当物体紧密排列时，深度缓冲没有足够精度决定谁在前面，两个形状抢夺显示先后顺序。会有奇怪的显示，冲突解决方法：</p><ul><li>不要把物体摆放太近</li><li>使用高精度深度缓冲</li><li>近平面设置远一点</li></ul><hr><h3 id="模板测试-Stencil-testing"><a href="#模板测试-Stencil-testing" class="headerlink" title="模板测试 Stencil testing"></a>模板测试 Stencil testing</h3><p>由窗口库(GLFW)配置模板缓冲，默认禁用，启用模板测试：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl">glEnable(GL_STENCIL_TEST);<span class="hljs-comment">// 启用模板缓冲</span><br>...<br><span class="hljs-keyword">while</span>(renderCondition)&#123;<br>    glClear(GL_STENCIL_BUFFER_BIT);<span class="hljs-comment">// 清除模板缓冲</span><br>&#125;<br></code></pre></td></tr></table></figure><p>模板掩码，stencil写入缓冲前先与stencil mask做与运算</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl">glStencilMask(<span class="hljs-number">0xFF</span>);<span class="hljs-comment">// 每位写入模板缓冲都会保持原样</span><br>glStencilMask(<span class="hljs-number">0x00</span>);<span class="hljs-comment">// 所有写入缓冲都为0，相当于禁用写入</span><br></code></pre></td></tr></table></figure><ul><li>模板函数：</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><br>glStencilFunc(GLenum func, GLint ref, GLuint mask);<span class="hljs-comment">// 何时通过模板测试</span><br>glStencilFunc(GL_EQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">0xFF</span>);<span class="hljs-comment">// default</span><br><span class="hljs-comment">/* parameter:</span><br><span class="hljs-comment">GL_ALWAYS</span><br><span class="hljs-comment">GLNEVER</span><br><span class="hljs-comment">GL_LESS</span><br><span class="hljs-comment">GL_EQUAL</span><br><span class="hljs-comment">GL_LEQUAL</span><br><span class="hljs-comment">GL_GRETER</span><br><span class="hljs-comment">GL_GEAUAL</span><br><span class="hljs-comment">GL_NOTEQUAL</span><br><span class="hljs-comment">*/</span><br>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);<br><span class="hljs-comment">// sfail：模板测试失败时采取的行为</span><br><span class="hljs-comment">// dpfail: 模板测试通过，深度测试失败</span><br><span class="hljs-comment">// dppass: 深度测试通过时采取的行为</span><br>glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);<span class="hljs-comment">// default</span><br><span class="hljs-comment">/* parameter:</span><br><span class="hljs-comment">GL_KEEP</span><br><span class="hljs-comment">GL_ZERO</span><br><span class="hljs-comment">GL_REPLACE</span><br><span class="hljs-comment">GL_INCR: 模板值加一(加一后要小于模板最大值)</span><br><span class="hljs-comment">GL_INCR_WRAP:模板值加一，若超过最大值置零</span><br><span class="hljs-comment">GL_DECR</span><br><span class="hljs-comment">GL_DECR_WRAP:模板值减一，若小于0则置为最大值</span><br><span class="hljs-comment">GL_INVERT:按位翻转</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>用模板测试绘制物体边框</p><hr><h3 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h3><ul><li>source：源颜色，上面叠的颜色</li><li>destination：目标颜色，底色</li></ul><p>destination和source和绘制顺序相关</p><hr><h3 id="Framebuffer"><a href="#Framebuffer" class="headerlink" title="Framebuffer"></a>Framebuffer</h3><h3 id="point-light"><a href="#point-light" class="headerlink" title="point light"></a>point light</h3><ol><li>create a cube map texture</li><li>setting cube texture to GL_DEPTH_COMPONENT</li><li>setting texture parameter</li><li>shadow Projection &amp; shadow view matrix</li></ol>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图形推理</title>
    <link href="/2021/05/19/%E5%9B%BE%E5%BD%A2%E6%8E%A8%E7%90%86/"/>
    <url>/2021/05/19/%E5%9B%BE%E5%BD%A2%E6%8E%A8%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="位置规律-元素组成相同"><a href="#位置规律-元素组成相同" class="headerlink" title="位置规律(元素组成相同)"></a>位置规律(元素组成相同)</h4><h5 id="1-平移"><a href="#1-平移" class="headerlink" title="1.平移"></a>1.平移</h5><ul><li>上下左右、顺逆时针、斜对角</li><li>步数</li><li><p>隐藏</p><ul><li>元素</li><li>轨迹<ul><li>“回”字：16/25宫格</li></ul></li></ul><h5 id="2-旋转"><a href="#2-旋转" class="headerlink" title="2.旋转"></a>2.旋转</h5><h5 id="3-翻转"><a href="#3-翻转" class="headerlink" title="3.翻转"></a>3.翻转</h5></li><li><p>上下/左右位置变化</p></li></ul><hr><h4 id="样式规律-元素重复出现"><a href="#样式规律-元素重复出现" class="headerlink" title="样式规律(元素重复出现)"></a>样式规律(元素重复出现)</h4><ul><li>遍历：缺啥补啥</li><li>加减同异<ul><li>求同/求异</li></ul></li><li>黑白运算(分割区域相同/黑块数量不同)<ul><li>相同位置做运算</li></ul></li></ul><hr><h4 id="属性规律-元素组成不同"><a href="#属性规律-元素组成不同" class="headerlink" title="属性规律(元素组成不同)"></a>属性规律(元素组成不同)</h4><h5 id="1-对称性"><a href="#1-对称性" class="headerlink" title="1.对称性"></a>1.对称性</h5><ul><li>轴对称/中心对称</li><li>对称轴<ul><li>数量</li><li>方向</li><li>与图形的关系</li></ul></li></ul><h5 id="2-曲直性"><a href="#2-曲直性" class="headerlink" title="2.曲直性"></a>2.曲直性</h5><ul><li>全曲线</li><li>全直线</li><li>曲线+直线</li></ul><h5 id="3-开闭性-完整图形留了缺口"><a href="#3-开闭性-完整图形留了缺口" class="headerlink" title="3.开闭性(完整图形留了缺口)"></a>3.开闭性(完整图形留了缺口)</h5><ul><li>全封闭</li><li>全开放</li></ul><hr><h3 id="数量规律"><a href="#数量规律" class="headerlink" title="数量规律"></a>数量规律</h3><h5 id="1-点-交叉明显-乱线-相切"><a href="#1-点-交叉明显-乱线-相切" class="headerlink" title="1.点(交叉明显/乱线/相切)"></a>1.点(交叉明显/乱线/相切)</h5><ul><li>曲直交点</li><li>内外交点<ul><li>存在明显外框</li><li>点: 框内/框上/框外</li></ul></li></ul><h5 id="2-线"><a href="#2-线" class="headerlink" title="2.线"></a>2.线</h5><p>直线数量</p><ul><li>多边形/单一直线</li></ul><p>曲线数量</p><p>笔画问题(五角星/日/田/圆相交/相切/<strong>多端点</strong>)</p><ul><li><strong>一笔画</strong>(需同时满足)<ul><li>线条直接连通</li><li>奇点数为0或2<ul><li>奇点：发射出奇数条线的点</li><li><strong>端点都是奇点</strong></li></ul></li></ul></li><li><strong>多笔画</strong>数=奇点数/2</li></ul><h5 id="3-面-封闭空间"><a href="#3-面-封闭空间" class="headerlink" title="3.面:封闭空间"></a>3.面:封闭空间</h5><ul><li>图形分割/封闭面明显</li><li>生活化图形/粗线条图形的留白区域</li></ul><p>细分：</p><ul><li>面的形状:三角形/四边形</li><li>最大面/最小面<ul><li>形状</li><li>属性</li><li>与外框的关系</li></ul></li></ul><h5 id="4-素-多个独立小图形"><a href="#4-素-多个独立小图形" class="headerlink" title="4.素(多个独立小图形)"></a>4.素(多个独立小图形)</h5><ul><li><p>元素个数</p></li><li><p>元素种类</p></li><li>部分数(连在一起的是一部分)<ul><li>生活化图形/粗线条</li></ul></li></ul><h5 id="5-角-直线的交-扇形-折线多-留了小缺口"><a href="#5-角-直线的交-扇形-折线多-留了小缺口" class="headerlink" title="5.角(直线的交:扇形/折线多/留了小缺口)"></a>5.角(直线的交:扇形/折线多/留了小缺口)</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo note</title>
    <link href="/2021/04/28/hexo-note/"/>
    <url>/2021/04/28/hexo-note/</url>
    
    <content type="html"><![CDATA[<!-- more --><h4 id="置顶："><a href="#置顶：" class="headerlink" title="置顶："></a>置顶：</h4><p>在Front-matter中加入:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$ sticky: 100 &lt;!--数字越大排序越前--&gt;<br></code></pre></td></tr></table></figure><hr><h4 id="加载html："><a href="#加载html：" class="headerlink" title="加载html："></a>加载html：</h4><ul><li>在md<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="markdown">[1]</span></a></sup>中加入:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;filename.html&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;700&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;800&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>要避免hexo渲染此html，在_config.yml写入:</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">skip_render:</span><br><span class="hljs-string">&#x27;_posts/文件夹名/文件名.html&#x27;</span><br></code></pre></td></tr></table></figure><hr><h4 id="加载pdf"><a href="#加载pdf" class="headerlink" title="加载pdf"></a>加载pdf</h4><p>使用hexo-pdf插件，下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install hexo-pdf --save</span><br></code></pre></td></tr></table></figure><p>md插入pdf：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% pdf ./filename.pdf %&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="勾选框"><a href="#勾选框" class="headerlink" title="勾选框"></a>勾选框</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% cb text, checked?, inline? %&#125;<br>&lt;!--first line--&gt; &#123;%cb true&#125; Completed<br>&lt;!--second line--&gt; &#123;%cb false&#125; In progress<br></code></pre></td></tr></table></figure><p><input type="checkbox" disabled checked="checked"> Completed</p><p><input type="checkbox" disabled > In progress</p><hr><h4 id="脚注-参考"><a href="#脚注-参考" class="headerlink" title="脚注|参考"></a>脚注|参考</h4><p>This is a footnote<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="foot note">[2]</span></a></sup>.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>markdown<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>foot note<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ note</title>
    <link href="/2021/03/23/C/"/>
    <url>/2021/03/23/C/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><ul><li>类中定义函数默认为inline</li><li>类默认修饰符为private</li><li>派生类<strong>继承</strong>基类默认为private</li><li>访问修饰符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<span class="hljs-comment">//可外部访问</span><br><span class="hljs-keyword">private</span>: <span class="hljs-comment">//只有类函数和友元函数可访问</span><br><span class="hljs-keyword">protected</span>:<span class="hljs-comment">//外部不可访问，派生类中可访问</span><br></code></pre></td></tr></table></figure><ul><li>派生类中访问修饰符</li></ul><div class="table-container"><table><thead><tr><th>继承基类方式</th><th>public</th><th>private</th><th>protected</th></tr></thead><tbody><tr><td>public</td><td>public</td><td>private</td><td>protected</td></tr><tr><td>private</td><td>private</td><td>private</td><td>private</td></tr><tr><td>protected</td><td>protected</td><td>private</td><td>protected</td></tr></tbody></table></div><h5 id="friend友元"><a href="#friend友元" class="headerlink" title="friend友元"></a>friend友元</h5><ul><li><p>友元可访问类中的私有和protected变量</p></li><li><p>破坏封装性，提高运行效率</p></li><li>友元没有继承性，没有传递性，友元单向</li><li>友元函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>  <span class="hljs-keyword">int</span> a;<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">int</span> <span class="hljs-title">geta</span><span class="hljs-params">(A tmp)</span></span>;<br>&#125;;<br><br><span class="hljs-function">itn <span class="hljs-title">geta</span><span class="hljs-params">(A tmp)</span></span>&#123; <span class="hljs-keyword">return</span> A.a; &#125;<br></code></pre></td></tr></table></figure><ul><li>友元类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">geta</span><span class="hljs-params">(A tmp)</span></span>&#123; <span class="hljs-keyword">return</span> tmp.a; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="const函数只能访问const对象或函数"><a href="#const函数只能访问const对象或函数" class="headerlink" title="const函数只能访问const对象或函数"></a>const函数只能访问const对象或函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> apple_number;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;<br>&#125;;<br>Apple::<span class="hljs-built_in">take</span>(<span class="hljs-keyword">int</span> num) <span class="hljs-keyword">const</span>&#123; <span class="hljs-comment">//只能访问const变量/函数</span><br>  cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br>Apple::<span class="hljs-built_in">add</span>(<span class="hljs-keyword">int</span> num)&#123;<span class="hljs-comment">//可以访问所有类对象/函数</span><br>  <span class="hljs-built_in">take</span>(num);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="static函数只能访问static对象或函数，static成员函数没有this指针"><a href="#static函数只能访问static对象或函数，static成员函数没有this指针" class="headerlink" title="static函数只能访问static对象或函数，static成员函数没有this指针"></a>static函数只能访问static对象或函数，static成员函数没有this指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> &#123;</span> <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMsg</span><span class="hljs-params">()</span> </span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Welcome to Apple!&quot;</span>; <br>        &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  Apple::<span class="hljs-built_in">printMsg</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h5><ul><li>派生类不会继承基类运算符重载、友元函数、构造函数、析构函数</li></ul><h5 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h5><ul><li>虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型；</li><li>默认参数静态绑定，默认参数的使用需要看指针或者应用本身的类型，而不是对象的类型(与上一条正好相反)；</li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p>多文件需访问const需显示声明extern const</p></li><li><p>const指针就近修饰</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * p; <br><span class="hljs-comment">/*指向const int类型的指针</span><br><span class="hljs-comment">不能通过指针来修改对象的值</span><br><span class="hljs-comment">若指向非const变量，也不能修改变量值</span><br><span class="hljs-comment">*/</span><br>    <br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p = &amp;i;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">常指针，必须初始化</span><br><span class="hljs-comment">不能修改指针，但是可以修改指针指向的变量</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)。</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li>static只会被初始化一次</li><li>static生命周期贯穿程序始终</li><li>static没有this指针，无法访问vptr</li></ul><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><ul><li>在编译阶段编译器内联：<ul><li>会采用内联的函数：编译阶段能确定的函数</li><li>不会采用内联的函数：编译阶段无法确定的函数<ul><li>eg. virtual函数呈现多态性时无法内联</li></ul></li></ul></li><li>原理：复制</li><li>不一采用内联函数：<ul><li>函数内部代码较长，复制后消耗较多内存；</li><li>函数内部有循环，执行函数时间比调用函数大(无需使用内联)。</li></ul></li><li>应使用内联：<ul><li>函数代码较短</li><li>函数调用时间大于执行时间</li></ul></li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li>用volatile声明的变量可以被编译器未知的事件修改</li><li>volatile一般用于多线程</li><li>volatile告诉编译器<ul><li>不对变量优化</li><li>每次对变量读写都要从内存取出，而非使用寄存器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> local = <span class="hljs-number">10</span>; <span class="hljs-comment">//使用volatile声明，可以被修改</span><br>    <span class="hljs-keyword">int</span> *ptr = (<span class="hljs-keyword">int</span>*) &amp;local;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Initial value of local : %d \n&quot;</span>, local);<br>    *ptr = <span class="hljs-number">100</span>;<span class="hljs-comment">//有效修改了*ptr</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Modified value of local: %d \n&quot;</span>, local); <span class="hljs-comment">//100</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/******************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> local = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> *ptr = (<span class="hljs-keyword">int</span>*) &amp;local;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Initial value of local : %d \n&quot;</span>, local);<br>    *ptr = <span class="hljs-number">100</span>; <span class="hljs-comment">//无效，无法修改*ptr</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Modified value of local: %d \n&quot;</span>, local);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><ul><li>assert是宏，定义在 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">assert.h<br></code></pre></td></tr></table></figure><ul><li>若assert条件错误，则终止(Abort)程序</li><li>用于检测逻辑不可能情况</li><li>若要忽略断言，加上:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NDEBUG <span class="hljs-comment">//要加载assert.h之前，不然会重复#define NDEBUG</span></span><br><span class="hljs-comment">//#include &lt;assert.h&gt;</span><br></code></pre></td></tr></table></figure><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><ul><li>c++调用c函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123; <span class="hljs-comment">//只在c++中支持，所有extern “C”的声明都要放在cpp中</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tmp.h&quot;</span></span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要调用其它文件中的变量、函数需要在变量声明前加extern修饰</li></ul><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><ul><li>C与C++中struct区别</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">c</th><th>c++</th></tr></thead><tbody><tr><td style="text-align:left">结构体内声明函数</td><td style="text-align:left">不能声明函数</td><td>能声明函数</td></tr><tr><td style="text-align:left">使用访问修饰符</td><td style="text-align:left">不能使用访问修饰符</td><td>可以使用：public、protected、private</td></tr><tr><td style="text-align:left">定义结构体</td><td style="text-align:left">必须加struct</td><td>不需要加struct</td></tr><tr><td style="text-align:left">继承</td><td style="text-align:left">无继承</td><td>可以继承，可以使用virtual</td></tr><tr><td style="text-align:left">结构体和函数同名</td><td style="text-align:left">可以正常运行调用</td><td>定义结构体必须带struct</td></tr></tbody></table></div><ul><li>与Class的区别<ul><li>struct默认访问是public</li><li>struct用于数据结构实体</li><li>class用于对象实体</li></ul></li></ul><h2 id="Lambda表达式-匿名函数"><a href="#Lambda表达式-匿名函数" class="headerlink" title="Lambda表达式(匿名函数)"></a>Lambda表达式(匿名函数)</h2><h2 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h2><ul><li>同等于typedef</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> VI = vector&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">//equal to typedef vector&lt;int&gt; VI</span><br></code></pre></td></tr></table></figure><ul><li>using 指定在之后的作用域中使用该命名空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//之后使用std命名空间</span><br><span class="hljs-comment">//using namespace std::cout; //之后使用std::cout函数</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;f()&quot;</span>&lt;&lt;endl;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Base::f(int)&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">private</span> Base &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">using</span> Base::f; <span class="hljs-comment">//不带形参，使用基类的函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Derived::f(int)&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base b;<br>    Derived d;<br>    d.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//f()</span><br>    d.<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//Derived::f(int)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dynamic-cast-amp-static-cast"><a href="#dynamic-cast-amp-static-cast" class="headerlink" title="dynamic_cast &amp; static_cast"></a>dynamic_cast &amp; static_cast</h2><ul><li>强制类型转换，用法：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static_cast</span>&lt;new_type&gt;(e);<br><span class="hljs-keyword">dynamic_cast</span>&lt;new_type&gt;(e);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2019/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2019/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="网络与因特网"><a href="#网络与因特网" class="headerlink" title="网络与因特网"></a>网络与因特网</h2><h3 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h3><h5 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h5><blockquote><p>具体组成</p><ul><li>端系统或主机</li><li>通信链路</li><li>分组交换机<ul><li>路由器</li><li>链路层交换机</li></ul></li></ul><p>服务描述</p><ul><li><p>通信基础设施</p><blockquote><p>允许终端系统上运行分布式 应用程序，并彼此交换数据</p></blockquote></li><li><p>为分布式应用程序􏰀供的通信服务</p><blockquote><ul><li>无连接服务</li><li>面向连接服务</li><li>不􏰀供数据传递时间保证(发送端到接收端)的服务 </li></ul></blockquote></li></ul></blockquote><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><blockquote><p>定义了两个或多个通信实体间所交换报文的<strong>格式和次序</strong>，以及在报文发送和/或接收或者其他事件方面所采取的行动(<strong>响应</strong>)</p><p>要素</p><ul><li>语法</li><li>语义</li><li>同步</li></ul></blockquote><h5 id="internet标准"><a href="#internet标准" class="headerlink" title="internet标准"></a>internet标准</h5><blockquote><p>IETF: </p><blockquote><p>Internet Engineering Task Force</p><p>因特网工程任务组</p></blockquote><p>RFC</p><blockquote><p>Request for comments </p><p>请求评论 </p><p><img src="1.png" width=600></p><p><img src="2.png" width=600></p></blockquote></blockquote><h5 id="端系统上的因特网服务"><a href="#端系统上的因特网服务" class="headerlink" title="端系统上的因特网服务"></a>端系统上的因特网服务</h5><blockquote><p>面向连接的服务 TCP</p><blockquote><p>目的：在端系统间传送数据 </p><p>握手</p><blockquote><p>客户和服务器事先进入戒备状态，为接下来的分组交换做好准备</p></blockquote><ul><li>可靠、顺序、字节流传输<ul><li>丢失: 确认和重传 </li></ul></li><li>流量控制 <ul><li>发送者不至于淹没接收者 </li></ul></li><li>拥塞控制 <ul><li>当网络拥塞时发送者降低发送速率</li></ul></li><li>不提供时延保证</li></ul><p>应用</p><blockquote><p>HTTP , FTP , Telnet, SMTP </p></blockquote></blockquote><p>无连接服务 UDP</p><blockquote><p>目的：在端系统间传送数据 </p><ul><li>不可靠数据传输 </li><li>无流量控制  </li><li>无拥塞控制</li></ul><p>应用</p><blockquote><p>流媒体,视频会议, DNS, Internet电话</p></blockquote></blockquote></blockquote><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><h5 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h5><blockquote><p>每个端到端的数据流被划分成分组来发送</p><blockquote><ul><li>所有分组共享网络资源  </li><li>每个分组使用全部链路带宽 </li><li>资源按需使用</li></ul></blockquote><p>统计复用</p><blockquote><ul><li>资源需求总量可以大于可获得资源的总量 </li><li>拥塞: 采用分组队列, 等待使用链路 </li><li>存储转发 <ul><li>在1个链路上传输 </li><li>每经过1个链路转发1次 </li><li>转发分组前，要求收到完整分组 </li></ul></li></ul></blockquote><p>分类</p><blockquote><ul><li><p>数据报网络: TCP/IP</p><ul><li>分组目的地址决定下一跳 </li><li>会话期间路由可以改变 </li></ul></li><li><p>虚电路网络: X.25,FR,ATM  </p><ul><li><p>每个分组有1个标签，标签决定下1跳</p></li><li><p>连接建立时确定固定的路径, 并且将保持于整个会话期间</p></li><li><p>路由器必须为每个连接维护状态信息</p></li></ul></li></ul></blockquote><p>优点</p><blockquote><ul><li>适合大量的突发数据传输<ul><li>资源共享</li><li>简单, 不需要建立连接</li></ul></li></ul></blockquote><p>缺点:</p><blockquote><ul><li>过渡竞争导致分组延迟与丢失 </li><li>需要可靠数据传输、拥塞控制协议 </li></ul></blockquote></blockquote><h5 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h5><blockquote><p>每次会话预留沿其路径(线路)所需的独占资源—电话网</p><p>多路复用</p><ul><li><p>分片分配到会话 </p></li><li><p>分片没有被会话使用的情况下，分片空载(不共享) </p></li><li><p>电路级性能(有保证) </p></li><li><p>要求呼叫建立—建立一个专门的端到端线路(意味着每个链路上预留一个线路)</p></li></ul><p>分片方式</p><ul><li>频分FDMA</li><li>时分TDMA</li></ul></blockquote><h5 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h5><blockquote><p><img src="3.png" width=600></p></blockquote><h5 id="分组时延"><a href="#分组时延" class="headerlink" title="分组时延"></a>分组时延</h5><blockquote><p>原因：分组到达输出链路的速率超过输出链路的容量</p><p>分组时延类型</p><ul><li><p>节点处理时延</p><blockquote></blockquote></li><li><p>排队时延</p><blockquote></blockquote></li><li><p>传输时延</p><blockquote><ul><li>R=链路带宽 (bps) </li><li>L=分组长度 (bits) </li><li>发送分组比特流的时 间 = L/R </li></ul></blockquote></li><li><p>传播时延</p><blockquote><ul><li>d = 物理链路的长度 </li><li>s = 介质的信号传播速度 (~2x10^8^ m/sec)</li><li>传播延迟=d/s</li></ul></blockquote></li></ul><p>总的节点延迟：$d<em>{nodal} = d</em>{proc} + d<em>{queue} + d</em>{trans} + d_{prop}$</p><p>prop:传播时延、queue:排队时延、trans:传输时延</p></blockquote><h5 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h5><blockquote><ul><li>路由器输入链路和输出链路的缓冲区容量有限 </li><li>当分组到达路由器输入链路发现缓冲区已满，则路由器只好丢弃分组 </li><li>当分组在路由器内部要转发到输出链路时发现输出缓冲区队列已满，路由器只好丢弃分组 </li><li>丢失的分组可能被前路由节点、源节点重传，或不重传 </li><li>丢包率或分组丢失率</li></ul></blockquote><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><blockquote><p>接收端接收数据的比特速率 (bps)</p><ul><li>瞬时吞吐量: 某一瞬间的吞吐量  </li><li>平均吞吐量: 一段时间内的吞吐量均值</li></ul><p>吞吐量=$min(R_s, R_c)$</p></blockquote><h3 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h3><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><div class="table-container"><table><thead><tr><th>层号</th><th>层的名称</th><th>层的英文名称</th><th>层的英文缩写</th></tr></thead><tbody><tr><td>7</td><td>应用层</td><td>Application</td><td>A</td></tr><tr><td>6</td><td><strong>表示层</strong></td><td>Presentation</td><td>P</td></tr><tr><td>5</td><td><strong>会话层</strong></td><td>Session</td><td>S</td></tr><tr><td>4</td><td>运输层</td><td>Transport</td><td>T</td></tr><tr><td>3</td><td>网络层</td><td>Network</td><td>N</td></tr><tr><td>2</td><td>数据链路层</td><td>Data Link</td><td>DL</td></tr><tr><td>1</td><td>物理层</td><td>Physical</td><td>PL</td></tr></tbody></table></div><h5 id="分层的意义"><a href="#分层的意义" class="headerlink" title="分层的意义"></a>分层的意义</h5><blockquote><p>清楚的结构允许我们对大型复杂系统定义其特定部分，探讨其各部分的关系 </p><p>模块化使得系统的维护、升级简化</p></blockquote><h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><blockquote><p>各层可能重复较低层功能 </p></blockquote><h5 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h5><p>五层因特网协议栈</p><div class="table-container"><table><thead><tr><th style="text-align:center">应用层</th></tr></thead><tbody><tr><td style="text-align:center">传输层</td></tr><tr><td style="text-align:center">网络层</td></tr><tr><td style="text-align:center">网络接口层(数据链路层)</td></tr><tr><td style="text-align:center">网络接口层(物理层)</td></tr></tbody></table></div><h5 id="网际协议栈"><a href="#网际协议栈" class="headerlink" title="网际协议栈"></a>网际协议栈</h5><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">应用层</th><th style="text-align:center">支持网络应用， 报文传送</th><th style="text-align:center">HTTP,FTP, SMTP,DNS,STTP</th></tr></thead><tbody><tr><td style="text-align:center">运输层</td><td style="text-align:center">主机进程间数据、报文传送、地址可靠校验</td><td style="text-align:center">TCP, UDP</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">主机间分组传送</td><td style="text-align:center">IP协议, 路由协议</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:center">相邻网络节点间的数据帧传送</td><td style="text-align:center">PPP, Ethernet</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:center">物理介质上的比特传送</td></tr></tbody></table></div><p>各层发方从上层到下层，收方从下层到上层传递数据</p></blockquote><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><h5 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h5><blockquote><ul><li>住宅接入网<ul><li>点对点接入</li><li>不能同时网上冲浪和拨打电话: 不能一直在线</li><li>HFC：混合光纤同轴电缆</li><li>ADSL：非对称数字用户线路</li><li><img src="4.png" width=600></li></ul></li><li>机构接入网络(学校,公司) </li><li>无线接入网络<ul><li>通过基站</li></ul></li></ul></blockquote><h5 id="物理介质"><a href="#物理介质" class="headerlink" title="物理介质"></a>物理介质</h5><blockquote><ul><li><p>物理链路:在发送方和接受方间,传播位(bit)信号</p></li><li><p>导引型媒体</p><blockquote><p>信号在固态介质中有向传播</p><ul><li>光纤、双绞线和同轴电缆  </li></ul></blockquote></li><li><p>非导引型媒体</p><blockquote><p>信号在大气空间或外太空 空间自由传播</p><ul><li>无线电</li></ul></blockquote></li><li><p>物理介质</p><blockquote><p>双绞线:两根彼此绝缘、相互缠绕成螺旋状的铜线</p><blockquote><p>缠绕的目的是减少电磁干扰</p><ul><li>屏蔽双绞线 STP</li><li>非屏蔽双绞线 UTP</li></ul></blockquote><p>同轴电缆</p><blockquote><p>两根彼此绝缘的同心导体</p><p>双向传输 </p></blockquote><p>光纤线缆</p><blockquote><p>光纤传导光脉冲, 每个光脉冲代表1位</p><p>高速传输</p><p>低误码率</p></blockquote><p>无线电磁波</p><blockquote><ul><li>地面微波</li><li>局域无线通道 </li><li>广域无线通道 </li><li>卫星通信 </li></ul><p>电磁频谱承载信号</p><p>双向 </p><p>传播环境的影响 </p></blockquote></blockquote></li></ul></blockquote><h5 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h5><blockquote><ul><li><p>第一层:国家/国际级ISP (NAP)</p><blockquote><p>ISP彼此对等，直接互连或通过网络接入点互连</p></blockquote></li><li><p>第二层：区域级ISP(向第一层付费)</p><blockquote><p>可以使用专用对等点互连，或使用NAP互连</p></blockquote></li><li><p>第三层：本地ISP</p><blockquote><p>最后的接入网络 </p></blockquote></li></ul></blockquote><h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><h5 id="植入恶意软件"><a href="#植入恶意软件" class="headerlink" title="植入恶意软件"></a>植入恶意软件</h5><ul><li>病毒 </li><li>蠕虫 </li><li>特洛伊木马  </li></ul><h5 id="攻击服务器和网络基础设施"><a href="#攻击服务器和网络基础设施" class="headerlink" title="攻击服务器和网络基础设施"></a>攻击服务器和网络基础设施</h5><ul><li>拒绝服务攻击(DoS) </li><li>三种类型 <ul><li>弱点攻击 </li><li>带宽洪泛 </li><li>连接洪泛 </li></ul></li></ul><h5 id="嗅探分组"><a href="#嗅探分组" class="headerlink" title="嗅探分组"></a>嗅探分组</h5><ul><li>分组嗅探器:记录每个流经的分组拷贝的被动接收机 </li><li>容易受到攻击的网络:无线网络和以太网LAN </li></ul><h5 id="伪装"><a href="#伪装" class="headerlink" title="伪装"></a>伪装</h5><ul><li>ip哄骗</li></ul><h5 id="修改或删除报文"><a href="#修改或删除报文" class="headerlink" title="修改或删除报文"></a>修改或删除报文</h5><ul><li>中间人攻击</li></ul><hr><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h3><h5 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h5><blockquote><p>网页(Web页，或称文档) </p><p>每个对象被一个URL(Uniform Resource Locator统一资源定位符)寻址 </p></blockquote><h5 id="没有应用程序写在网络核心设备上"><a href="#没有应用程序写在网络核心设备上" class="headerlink" title="没有应用程序写在网络核心设备上"></a>没有应用程序写在网络核心设备上</h5><h5 id="应用层体系结构"><a href="#应用层体系结构" class="headerlink" title="应用层体系结构"></a>应用层体系结构</h5><blockquote><p>客户机/服务器体系结构</p><blockquote><p>服务器: </p><ul><li>总是打开的主机 </li><li>具有固定的、众所周知的IP地址 </li><li>主机群集常被用于创建强大的虚拟服务器</li></ul><p>客户机</p><ul><li>同服务器端通信 </li><li>可以间断的同服务器连接 </li><li>可以拥有动态IP地址 </li><li>客户机相互之间不直接通信</li></ul></blockquote><p>纯P2P体系结构</p><blockquote><ul><li>没有总是打开的服务器</li><li>任意一对主机直接相互通信 </li><li>对等方间歇连接并且可以改变IP地址</li></ul><p>优点：自扩展性</p><p>缺点：难以管理</p></blockquote><p>客户机/服务器和P2P混合的体系结构 </p></blockquote><h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><blockquote><p><strong>进程</strong>：运行在端系统上的程序</p><p><strong>客户机进程</strong>：发起通信的进程</p><p><strong>服务器进程</strong>：等待联系的进程</p><ul><li>同一主机上的两个进程通过内部进程通信机制进行通信</li><li>不同主机上的进程通过交换报文相互通信</li><li>具有P2P体系结构的应用程序有客户机进程和服务器进程</li></ul><p><strong>套接字</strong></p><blockquote><p>进程与计算机网络的接口</p><p>进程通过它的套接字在网络上发送和接收报文</p><ul><li>套接字又叫做应用程序编程接口API</li><li>用户通过API对运输层的控制仅限于<ul><li>选择传输协议</li><li>能设定几个参数 </li></ul></li></ul></blockquote></blockquote><h5 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h5><blockquote><p> 主机上的进程标识包括<strong>IP地址</strong>和<strong>端口号</strong></p></blockquote><h5 id="传输服务需求"><a href="#传输服务需求" class="headerlink" title="传输服务需求"></a>传输服务需求</h5><blockquote><p><img src="5.png" width=600></p></blockquote><h5 id="因特网运输协议􏰀供的服务"><a href="#因特网运输协议􏰀供的服务" class="headerlink" title="因特网运输协议􏰀供的服务"></a>因特网运输协议􏰀供的服务</h5><ul><li>TCP</li><li>UDP</li></ul><h5 id="应用层的网络应用"><a href="#应用层的网络应用" class="headerlink" title="应用层的网络应用"></a>应用层的网络应用</h5><blockquote><p><img src="6.png" width=600></p></blockquote><h3 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h3><h5 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h5><blockquote><p> 超文本传输协议(hypertext transfer protocol)</p><ul><li><strong>端口号：80</strong></li><li>C/S模式</li><li>使用TCP(步骤)<ul><li>客户初始化与HTTP服务器80端口的TCP连接(创建套接字)</li><li>HTTP服务器接受来自客户的TCP连接请求, 建立连接</li><li>Browser (HTTP client)和 Web服务器 (HTTP server) 交换HTTP消息(应用层协议消息)包括HTTP请求和响应消息 </li><li>关闭TCP连接</li></ul></li><li>无状态协议<ul><li>HTTP服务器不维护客户先前的状态信息 </li></ul></li></ul></blockquote><h5 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h5><blockquote><ul><li><p>定义往返时间RTT</p><blockquote><p>1个小分组从客户主机到服务器再到客 户主机所花费的时间</p><p><img src="7.png" width=300></p></blockquote></li><li><p>非持久HTTP连接</p><blockquote><p>每个TCP连接上只传送一个对象</p><p>HTTP/1.0默认</p><p>步骤</p><ul><li>HTTP客户初始化1个与HTTP服务器的TCP连接</li><li>HTTP服务器在80端口监听来自HTTP客户的TCP连接请求。收到连接请求, 接受, 建立连接, 通知客户</li><li>HTTP客户发送1个HTTP请求消息(含URL到TCP连接套接字) </li><li>HTTP服务器接收请求消息, 产生1个响应消息</li><li>HTTP服务器结束TCP连接</li><li>HTTP 客户接收消息</li><li>重复步骤</li></ul><p>响应时间</p><ul><li><p>1个RTT用于建立TCP连接</p></li><li><p>1个RTT用于HTTP请求</p></li><li><p>Html文件传输时间 </p><blockquote><p>total = 2RTT+transmit time</p></blockquote></li></ul><p>遇到的问题</p><blockquote><ul><li>每个对象需要2个RTT </li><li>OS必须为每个TCP连接分配主机资源</li><li>大量客户的并发TCP连接形成服务器的严重负担 </li></ul></blockquote></blockquote></li><li><p>持久HTTP连接</p><blockquote><p>一个TCP连接上可以传送多个对象</p><p>HTTP/1.1默认 </p><ul><li>服务器发送响应消息后保持连接</li><li>同1客户/服务器的后续HTTP消息继续在该连接上传送 </li></ul><p><strong>分类</strong></p><blockquote><ul><li>不带流水线的持久HTTP连接<ul><li>客户先前响应消息收到,才发出新的请求消息</li><li>每个引用对象经历1个RTT </li></ul></li><li>带流水线的持久HTTP连接<ul><li>HTTP/1.1默认使用</li><li>客户遇到1个引用对象就发送请求消息</li><li>所有引用对象只经历1个RTT </li></ul></li></ul></blockquote></blockquote></li></ul></blockquote><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><blockquote><p>ASCII文本</p><p><img src="8.png" widht=600></p><p><img src="9.png" widht=600></p><p><img src="10.png" widht=600></p><ul><li>POST:输入值在请求报文的实体主体中被上载到服务器</li><li>GET:表单(各字段)输入值被上载,以URL请求行的字段</li></ul></blockquote><h5 id="HTTP响应消息"><a href="#HTTP响应消息" class="headerlink" title="HTTP响应消息"></a>HTTP响应消息</h5><blockquote><p><img src="11.png" width=600></p><p>HTTP 响应的状态码</p><ul><li><p>200 OK</p><ul><li>请求成功, 所请求信息在响应消息中返回 </li></ul></li><li><p>301 Moved Permanently</p><ul><li>所请求的对象已永久迁移, 新的URL在本响应消息的(location:)头部指出</li></ul></li><li>400 Bad Request<ul><li>该请求不能被服务器解读</li></ul></li><li>404 Not Found <ul><li>服务器上不存在所请求文档  </li></ul></li><li>505 HTTP Version Not Supported </li></ul></blockquote><h5 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h5><blockquote><ul><li>Cookie首部行在 HTTP响应消息中 </li><li>Cookie首部行在 HTTP请求消息中 </li><li>cookie文件保存在用户主机中并被用户浏览器管理</li><li>cookie也保存在Web站点的后端数据库 </li></ul><p>作用</p><ul><li>身份认证 </li><li>虚拟购物车</li><li>推荐广告 </li><li>用户会话状态  </li></ul></blockquote><h5 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h5><blockquote><p>代理服务器</p><p>用户配置浏览器: Web 访问经由缓存 </p><ul><li>所有HTTP请求指向缓存 <ul><li>对象在缓存中:缓存器返回对象</li><li>否则缓存器向起始服务器发出请求,接收对象后转发给客户机 </li></ul></li></ul><p>优点</p><ul><li>减少对客户机请求的响应</li><li>减少内部网络与接入链路上的通信量 </li><li>能从整体上大大降低因特网上的Web流量 </li></ul></blockquote><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><blockquote><p>文件传输协议</p><ul><li>传输文件到远程主机/从远程主机下载文件</li><li>C/S架构</li><li><strong>端口号：20,21</strong></li></ul><p>步骤</p><ul><li><img src="12.png" width=600></li></ul><p>文件传输模型</p><blockquote><ul><li><img src="13.png" width=600></li><li><img src="14.png" width=600></li></ul></blockquote><p>ftp数据连接建立方式</p><blockquote><p><img src="15.png" width=600></p></blockquote><p>ftp命令</p><blockquote><ul><li>USER username</li><li>PASS password </li><li>LIST:返回当前远程目录的文件列表</li><li>RETR filename:获取 远程主机当前目录下的1个文件(get) </li><li>STOR filename:存放 1个文件到远程主机当前目录下(put) </li></ul></blockquote><p>ftp应答</p><blockquote><ul><li>状态码及其相应短语(同HTTP)</li><li>331 Username OK,password required</li><li>125 data connection already open; transfer starting</li><li>425 Can’t open data connection</li><li>452 Error writing file</li></ul></blockquote></blockquote><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h5 id="组成成分"><a href="#组成成分" class="headerlink" title="组成成分"></a>组成成分</h5><ul><li>用户代理</li><li>邮件服务器 </li><li>简单邮件传送协议和邮件接收协议 </li></ul><h5 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h5><blockquote><ul><li>客户使用TCP来可靠传输邮件消息到服务器<strong>端口号25</strong> </li><li>直接传送: 发送服务器到接收服务器</li><li><p>传输的3个阶段 </p><ul><li><p>握手 (问候)</p></li><li><p>邮件消息的传输 </p></li><li><p>结束 </p></li></ul></li><li>命令/应答的交互 <ul><li>命令: ASCII文本格式 </li><li>应答: 状态码及其短语 </li></ul></li><li>邮件消息必须是7-bit ASCII </li><li>使用持久连接</li><li>crlf .crlf判断邮件结束</li></ul></blockquote><h5 id="邮件消息格式"><a href="#邮件消息格式" class="headerlink" title="邮件消息格式"></a>邮件消息格式</h5><blockquote><p><img src="16.png" width=600></p><p><img src="17.png" width=600></p></blockquote><h5 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h5><blockquote><p>SMTP</p><blockquote><p>递送/存储邮件消息到接收者邮件服务器</p></blockquote><p>邮件访问协议</p><blockquote><p>从服务器获取邮件消息</p><ul><li><p>POP: Post Office Protocol 邮局协议</p><ul><li><p><strong>110端口</strong></p></li><li><p>身份认证 (代理 &lt;—&gt;服务器)</p><ul><li><p>客户命令</p><blockquote><p>user username</p><p>pass password</p></blockquote></li><li><p>服务器响应</p><blockquote><p>+OK</p><p>-ERR</p></blockquote></li></ul></li><li><p>下载邮件消息 </p><ul><li>list: 列出邮件编号</li><li>retr: 按编号取邮件  </li><li>dele: 删除 </li><li>quit </li></ul></li><li><p><img src="18.png" width=300></p></li><li><p>POP3会话无状态</p></li><li><p>POP3模式</p><ul><li>Download-and-delete</li><li>Download-and-keep </li></ul></li></ul></li><li><p>IMAP: Internet Message Access Protocol</p><ul><li><strong>143端口</strong></li><li>更多功能特征 </li><li>允许用户像对待本地邮箱那样操纵远程邮箱的邮件</li><li>保存所有邮件消息在服务器</li><li>允许用户在服务器的各文件夹中管理邮件消息</li><li>IMAP跟踪用户状态信息 </li></ul></li></ul></blockquote></blockquote><h3 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a>DNS(Domain Name System)</h3><h5 id="DNS提供的功能"><a href="#DNS提供的功能" class="headerlink" title="DNS提供的功能"></a>DNS提供的功能</h5><ul><li>53port</li><li>主机名到IP地址的转换</li><li>主机别名<ul><li>一个主机可以有一个规范主机名和多个主机别名</li></ul></li><li>邮件服务器别名</li><li>负载分配 <ul><li>DNS实现冗余服务器:一 个IP地址集合可以对应于同一个规范主机名 </li></ul></li></ul><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><blockquote><p>采用分布式数据库</p><p>不采用集中式DNS的原因</p><ul><li>单点故障 </li><li>巨大访问量</li><li>远距离集中式数据库 </li><li>维护</li><li>不可扩展 </li></ul><p><img src="19.png" width=600></p><p>13个DNS根服务器</p><ul><li>10个美国</li><li>1个英国</li><li>1个瑞典</li><li>1个日本</li></ul><p>顶级域名服务器：TLD：top level domain</p><p><img src="20.png" width=600></p><p><img src="21.png" width=600></p></blockquote><h5 id="DNS工作机制"><a href="#DNS工作机制" class="headerlink" title="DNS工作机制"></a>DNS工作机制</h5><blockquote><p>DNS查询方式</p><ul><li><p>递归查询</p><blockquote><p><img src="25.png" width=600></p></blockquote></li><li><p>迭代查询</p><blockquote><p><img src="26.png" width=600></p></blockquote></li></ul><p>DNS缓存</p><blockquote><p>一旦名字服务器获得DNS映射, 它将缓存该映射到局部内存</p><ul><li>服务器在一定时间后将丢弃缓存的信息 </li><li>本地DNS服务器可以缓存TLD服务器的IP地址</li><li>因此根DNS服务器不会被经常访问 </li></ul></blockquote><p>权威DNS服务器记录更新:IETF动态更新/通报机制</p><p>DNS记录</p><blockquote><p><img src="22.png" width=600></p></blockquote></blockquote><h5 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h5><blockquote><p>查询报文与应答报文</p><p>查询报文</p><blockquote><p><img src="23.png" width=600></p></blockquote><p>应答报文</p><blockquote><p><img src="24.png" width=600></p></blockquote></blockquote><h5 id="在DNS数据库中插入记录"><a href="#在DNS数据库中插入记录" class="headerlink" title="在DNS数据库中插入记录"></a>在DNS数据库中插入记录</h5><blockquote><p>如果你想在注册登记机构注册你的域名network.com，则 </p><ul><li>需要􏰀供你自己的基本权威DNS服务器和辅助权威DNS服 务器的名字和IP地址 </li><li>该注册登记机构将下列两条资源记录插入注册机构的DNS 系统中: <ul><li>(network.com, dns1.network.com, NS)</li><li>(dns1.network.com, 212.212.212.1, A) </li></ul></li><li>如果你想建立一个网站，则可以将网址www.network.com以 类型A的方式记录到你的权威DNS服务器dns1.network.com中</li><li>如果你想建一个邮件服务器，则可以将mail.network.com以 类型MX的方式记录到你的权威DNS服务器 dns1.network.com中</li></ul></blockquote><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><h5 id="P2P集中式目录"><a href="#P2P集中式目录" class="headerlink" title="P2P集中式目录"></a>P2P集中式目录</h5><blockquote><p><img src="27.png" width=600></p><p>问题</p><ul><li>单点故障  </li><li>性能瓶颈 </li><li>侵犯版权 </li></ul></blockquote><h5 id="Gnutella协议"><a href="#Gnutella协议" class="headerlink" title="Gnutella协议"></a>Gnutella协议</h5><blockquote><ul><li>全分布</li><li>没有集中式服务器 </li><li>公共域协议 </li><li>许多Gnutella客户机实现 Gnutella协议</li><li>查询洪泛</li></ul><p><img src="28.png" width=600></p><p>加入对等方</p><blockquote><ul><li>加入对等方X必须发现在Gnutella网络中的其他对等方:使用对等方列表 </li><li>X试图与该列表上的对等方建立一条TCP连接，直到与Y 创建一条连接</li><li>X向Y发送一个Ping报文;Y转发该Ping报文</li><li>所有的对等方接收Ping报文并响应一个Pong报文</li><li>X接收到许多Pong报文。然后能同某些其他对等方建立 TCP连接</li></ul></blockquote><p>对等方离开</p><blockquote><ul><li><p>主动离开</p><blockquote><p>离开节点的所有对等方都会刷新自身的激活对等方列表,并开始与列表中的新的对等方建立连接 </p></blockquote></li><li><p>断网</p><blockquote><p>发送信息的时候对等方没有响应,则表明对等方离开,节点刷新自身的激活对等方列表,并开始与列表中的 新的对等方建立连接 </p></blockquote></li></ul></blockquote></blockquote><h5 id="KaZaA协议"><a href="#KaZaA协议" class="headerlink" title="KaZaA协议"></a>KaZaA协议</h5><blockquote><ul><li>对等方成为组长或被指派给一个组长</li><li>对等方和组长之间建立 TCP连接 </li><li>组长之间建立TCP连接 </li><li>组长维护它的子对等方共享的内容</li><li>每个文件有文件的散列码标识 </li><li>客户机送向组长发送关键词的查询  </li><li>组长响应匹配 <ul><li>逐项匹配:元数据，散列值，IP地址 </li></ul></li><li>如果组长转发查询给其他组长则其他组长响应匹配 </li><li>客户端选择要下载的文件 </li><li>请求排队:限制对等方并行上载数量，新的请求进行排队</li><li>激励优先权:根据不同的上载下载比例,优先服务贡献大者 </li><li>并行下载:将一个文件分成若干段，从多个对等方并行下载 </li></ul></blockquote><h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="运输层-1"><a href="#运输层-1" class="headerlink" title="运输层"></a>运输层</h3><blockquote><p>为两个实体<strong>进程</strong>提供逻辑通信</p><p>网络层：<strong>实体</strong>间的逻辑通信</p><p>运输层协议运行在端系统</p><ul><li>发送方:将应用程序报文分成数据段传递给网络层 </li><li>接受方:将数据段重新组装成报文传递到应用层</li></ul><p>运输层协议</p><blockquote><ul><li>可靠按序递交(TCP) <ul><li>流量控制</li><li>拥塞控制</li><li>连接建立</li></ul></li><li>不可靠的无序传递(UDP)</li><li>不提供<ul><li>时延保证</li><li>带宽保证 </li></ul></li></ul></blockquote></blockquote><h3 id="多路复用多路分解"><a href="#多路复用多路分解" class="headerlink" title="多路复用多路分解"></a>多路复用多路分解</h3><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><blockquote><blockquote><p>在发送主机从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层在发送主机从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层</p></blockquote></blockquote><h5 id="多路分解"><a href="#多路分解" class="headerlink" title="多路分解"></a>多路分解</h5><blockquote><blockquote><p>在接收主机将接收到的数据段传递到正确的套接字 </p><blockquote><p>工作方式</p><ul><li>主机接收IP数据报<ul><li>每个数据报有源IP地址，目的IP地址 </li><li>每个数据报搬运一个数据段 </li><li>每个数据段有源和目的端口号</li></ul></li><li>主机用IP地址和端口号指明数据段属于哪个合适的套接字</li></ul></blockquote></blockquote></blockquote><h5 id="面向连接的多路分解"><a href="#面向连接的多路分解" class="headerlink" title="面向连接的多路分解"></a>面向连接的多路分解</h5><blockquote><ul><li>TCP套接字由4部分<strong>指定和表示</strong>，服务器支持多个同时的TCP套接字<ul><li>源IP地址(S-IP)</li><li>源端口号(SP)</li><li>目的IP地址(D-IP)</li><li>目的端口号(DP)</li></ul></li><li>Web服务器对每个连接的客户都有不同的套接字</li><li>非持久HTTP将对每个请求有一个不同的套接字 </li></ul></blockquote><h5 id="无连接多路分解"><a href="#无连接多路分解" class="headerlink" title="无连接多路分解"></a>无连接多路分解</h5><blockquote><ul><li>UDP套接字由2个因素<strong>指定</strong><ul><li>目的IP地址(D-IP)</li><li>目的端口号(DP)</li><li>因此具有不同的源IP地址且/或源端口号，但具有相同的目的IP地址和目的端口号的IP数据报指向同样的套接字 </li></ul></li><li>UDP套接字由2部分<strong>表示</strong><ul><li>源端口号(SP)</li><li>目的端口号(DP)</li></ul></li><li>请求报文段中提供返回地址(包括IP地址和端口号) </li></ul></blockquote><h3 id="无连接传输UDP"><a href="#无连接传输UDP" class="headerlink" title="无连接传输UDP"></a>无连接传输UDP</h3><h5 id="UDP用户数据报协议"><a href="#UDP用户数据报协议" class="headerlink" title="UDP用户数据报协议"></a>UDP用户数据报协议</h5><blockquote><ul><li>不可靠数据传输<ul><li>数据段可能丢失</li></ul></li><li>无序提交<ul><li>可能会传递失序的报文段到应用程序</li></ul></li><li>面向报文(有多大发多大，有多大收多大)<ul><li>发送方UDP对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并， 也不拆分，而是保留这些报文的边界</li><li>接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文</li><li>应用程序必须选择合适大小的报文  </li></ul></li><li>无流量控制</li><li>无拥塞控制</li><li>无连接<ul><li>在UDP接收者发送者之间没有握手 </li><li>每个UDP数据段的处理独立于其他数据段</li></ul></li></ul><p>UDP数据报</p><blockquote><ul><li>首部<ul><li>源端口(SP) 2bytes</li><li>目的端口(DP) 2bytes</li><li>报文长度 2bytes</li><li>检验和 2bytes</li></ul></li><li>数据</li></ul></blockquote></blockquote><h5 id="UPD协议的优点-小、简单、快"><a href="#UPD协议的优点-小、简单、快" class="headerlink" title="UPD协议的优点(小、简单、快)"></a>UPD协议的优点(小、简单、快)</h5><blockquote><ul><li>无连接<ul><li>减少时延</li><li>简单，无需建立连接</li></ul></li><li>很小的数据段首部(8 bytes)</li><li>没有拥塞控制<ul><li>UDP能够用想象的快的速度传递</li><li>适合多媒体通信的要求</li></ul></li><li>支持一对一、一对多、多对一和多对多的交互通信</li></ul></blockquote><h5 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h5><blockquote><p>在计算检验和时，临时把“<strong>伪首部</strong>”和 UDP 用户数据报连接在一起</p><p>目的：对传输的数据进行差错检测</p><p>发送方</p><blockquote><ul><li>将数据段看成16bit的整数序列</li><li>计算校验和</li><li>送者将校验和值放入UDP的校验和域  </li></ul></blockquote><p>接收方</p><blockquote><ul><li>计算接收到数据段的校验和</li><li>检查计算的校验和是否等于校验和域中的值<ul><li>是，没有校验错误，提交数据</li><li>否，有校验错误，进行错误处理</li></ul></li></ul></blockquote><p>计算方法</p><blockquote><ul><li>按反码的加法进行和运算，<strong>循环进位</strong></li><li>结果取反为校验和</li></ul></blockquote></blockquote><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><h5 id="可靠数据传输服务"><a href="#可靠数据传输服务" class="headerlink" title="可靠数据传输服务"></a>可靠数据传输服务</h5><blockquote><ul><li><p>停等协议：发送方发送一个报文，然后等待接受方的响应</p></li><li><p>可能用到的响应</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">rdt_send</span>()<span class="hljs-comment">//发送数据</span><br><span class="hljs-built_in">rdt_rcv</span>()<span class="hljs-comment">//接收数据</span><br><span class="hljs-built_in">make_pkt</span>()<span class="hljs-comment">//数据打包</span><br><span class="hljs-built_in">udt_send</span>()<span class="hljs-comment">//不可靠发送</span><br><span class="hljs-built_in">extract</span>()<span class="hljs-comment">//取出数据</span><br><span class="hljs-built_in">deliver_data</span>()<span class="hljs-comment">//传输数据</span><br><span class="hljs-built_in">corrupt</span>()<span class="hljs-comment">//数据乱序</span><br><span class="hljs-built_in">notcorrupt</span>()<span class="hljs-comment">//数据有序</span><br><span class="hljs-built_in">isACK</span>()<span class="hljs-comment">//接收无误    </span><br><span class="hljs-built_in">isNAK</span>()<span class="hljs-comment">//接收有错</span><br></code></pre></td></tr></table></figure></li><li><p>Rdt1.0：完全可靠信道上的可靠数据传输</p><blockquote><p> 在完美可靠的信道上 </p><p> 没有bit错误  </p><p> 没有分组丢失 </p><ul><li>发送方发送数据到下层信道</li><li>接收方从下层信道接收数据</li><li><img src="29.png" width=600></li></ul></blockquote></li><li><p>Rdt2.0：具有bit错误的信道 </p><blockquote><p>下层信道可能使发送报文Bit受损(失序、死锁)</p><hr><p>发送报文引入校验和</p><p>接收方判断接收报文的校验和</p><p>发送ACK或者NAK(停等协议)</p><p>发送方收到NAK重传上一个报文</p><ul><li>ACK: 接收方明确告诉发送方，分组接收<strong>正确</strong></li><li>NAK: 接收方明确告诉发送方，分组接收<strong>错误</strong></li></ul><p><img src="30.png" width=600></p><p>致命错误</p><ul><li>ACK/NAK出错<ul><li>发送方并不知道接收方发生了什么</li><li>接收方不能判定接收的报文是重复的还是新报文  </li></ul></li></ul></blockquote></li><li><p>Rdt2.1</p><blockquote><p>ACK/NAK bit错(失序、死锁) </p><hr><p>发送报文引入0、1序号 </p><p>ACK/NAK引入校验</p><p><img src="31.png" width=600></p><p><img src="32.png" width=600></p></blockquote></li><li><p>Rdt2.2</p><blockquote><p>ACKs引入0，1 </p><hr><p>不需要NAK</p><p>发送方收到重复ACK将导致和NAK一样的处理</p></blockquote></li><li><p>Rdt3.0</p><blockquote><p>丢包(失序、死锁) </p><hr><p>发送方对每个报文启动超时重传机制</p></blockquote></li><li><p>GBN</p><blockquote><p>0、1效率太低 </p><hr><p>发送端滑动窗口(大小N) </p><p>接收端ACK期望接收的序号i </p><p>丢弃失序的报文</p><p>发送端发i+1,i+2,…i+N报</p></blockquote></li><li><p>GS</p><blockquote><p>N重传损失太大</p><hr><p>接收端滑动窗口(大小N) </p><p>接收端缓冲接受的失序报文 </p><p>接收端对失序报文ACK </p><p>发送端对窗口内报文ACK做标记 </p></blockquote></li></ul></blockquote><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><blockquote><ul><li><p>全双工数据: </p><ul><li><p>同一个连接上的双向数 据流 </p></li><li><p>MSS:最大报文段长 </p></li></ul></li><li>面向连接: <ul><li>在数据交换前握手,初始化发送方和接收方的状态 </li><li>流量控制:<ul><li>发送方不会淹没接收方 </li></ul></li></ul></li></ul></blockquote><h5 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h5><blockquote><ul><li>TCP在IP不可靠服务之上创建rdt服务 </li><li>流水线技术处理报文段 </li><li>累积确认 </li><li>TCP使用单个重发定时器 </li><li>触发重发:<ul><li>超时事件  </li><li>重复确认 </li></ul></li></ul></blockquote><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h5 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h5><blockquote><ul><li>将分组从发送方主机传送到接收方主机 </li></ul><ul><li>发送方将数据段封装成分组 </li><li>接收方将分组解封装后将数据段递交给传输层 </li><li>网络层协议存在于每台主机和路由器上 </li><li>路由器检查所有经过它的IP分组的分组头 </li></ul></blockquote><p>网络层功能</p><blockquote><ul><li>转发 forwarding<ul><li>将分组移动到合适的链路层接口</li></ul></li><li>选路 routing<ul><li>决定分组从源到端的路径</li></ul></li><li>建立连接</li></ul></blockquote><h5 id="网络层服务模型"><a href="#网络层服务模型" class="headerlink" title="网络层服务模型"></a>网络层服务模型</h5><blockquote><ul><li>单个数据<ul><li>确保交付</li><li>具有时延上界</li></ul></li><li>分组的流<ul><li>有序的分组提交</li><li>确保最小带宽</li><li>确保最大时延抖动</li><li>安全性服务</li></ul></li><li>现在的因特网网络层并没有􏰀供上述服务</li></ul></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">网路体系结构</th><th style="text-align:center">服务模型</th><th style="text-align:center">带宽保证</th><th style="text-align:center">无丢包保证</th><th style="text-align:center">排序</th><th style="text-align:center">定时</th><th style="text-align:center">拥塞指示</th></tr></thead><tbody><tr><td style="text-align:center">Internet</td><td style="text-align:center">尽力而为</td><td style="text-align:center">无</td><td style="text-align:center">无</td><td style="text-align:center">任何顺序</td><td style="text-align:center">不维持</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">ATM</td><td style="text-align:center">CBR</td><td style="text-align:center">恒定速率</td><td style="text-align:center">是</td><td style="text-align:center">有序</td><td style="text-align:center">维持</td><td style="text-align:center">无拥塞</td></tr><tr><td style="text-align:center">ATM</td><td style="text-align:center">ABR</td><td style="text-align:center">保证最小速率</td><td style="text-align:center">无</td><td style="text-align:center">有序</td><td style="text-align:center">不维持</td><td style="text-align:center">提供拥塞指示</td></tr></tbody></table></div><h3 id="虚电路网络和数据报网络"><a href="#虚电路网络和数据报网络" class="headerlink" title="虚电路网络和数据报网络"></a>虚电路网络和数据报网络</h3><h5 id="虚电路-VC"><a href="#虚电路-VC" class="headerlink" title="虚电路(VC)"></a>虚电路(VC)</h5><blockquote><ul><li>数据传输前建立虚电路，传输完毕后拆除虚电路  </li><li>每个分组携带VC标识(并非目的地址)  </li><li>在源-目的路径上每个路由器要维护每个连结的状态信息 </li><li>链路、路由器资源(带宽、缓冲区)可能分配给VC </li></ul></blockquote><h5 id="vc的组成"><a href="#vc的组成" class="headerlink" title="vc的组成"></a>vc的组成</h5><blockquote><ul><li>路径</li><li>VC号</li><li>转发表项</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统结构</title>
    <link href="/2019/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <url>/2019/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h2 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h2><h4 id="Flynn’s-分类，市场分类"><a href="#Flynn’s-分类，市场分类" class="headerlink" title="Flynn’s 分类，市场分类"></a>Flynn’s 分类，市场分类</h4><blockquote><p>​    </p></blockquote><h4 id="系统结构的原始定义和现在的定义"><a href="#系统结构的原始定义和现在的定义" class="headerlink" title="系统结构的原始定义和现在的定义"></a>系统结构的原始定义和现在的定义</h4><blockquote><p><strong>原始定义:</strong></p><p>程序员看见的系统属性，即结构及行为，区分数据流动和控制逻辑，及物理实现</p><p><strong>现在定义:</strong></p><p>是在满足功能、性能和价格目标的条件下，设计、选择和互连硬件部件构成计算机。</p></blockquote><h4 id="了解实现技术、功耗、成本的趋势，可靠性"><a href="#了解实现技术、功耗、成本的趋势，可靠性" class="headerlink" title="了解实现技术、功耗、成本的趋势，可靠性"></a>了解实现技术、功耗、成本的趋势，可靠性</h4><blockquote><ul><li>摩尔定律</li><li>带宽增加速度与响应时间改进的平方成比例</li><li>带宽改进优于时延</li><li>多核有更高的功率利用率</li><li>模块可用性：</li><li>$\frac{平均无故障时间}{平均故障间隔时间}$</li></ul></blockquote><h4 id="性能评价指标-响应时间、CPU时间、吞吐量"><a href="#性能评价指标-响应时间、CPU时间、吞吐量" class="headerlink" title="性能评价指标:响应时间、CPU时间、吞吐量"></a>性能评价指标:响应时间、CPU时间、吞吐量</h4><blockquote><p>​    </p></blockquote><h4 id="性能评价方法"><a href="#性能评价方法" class="headerlink" title="性能评价方法:"></a>性能评价方法:</h4><blockquote><p>基准测试程序，SPEC测试程序集及指标( SPEC Ratio、 Spec mark ) </p></blockquote><h5 id="SPEC"><a href="#SPEC" class="headerlink" title="SPEC:"></a>SPEC:</h5><blockquote><p>提供基于现有应用程序的一套标准化源代码作为基准测试程序(SM为SPEC速率的几何平均值)</p><ul><li>$SM = \sqrt[n] {\prod_{i-1}^{n} SPECRatio_i}$</li><li>$SPECRatio_i = \frac{参考计算机执行时间}{A机执行时间}$</li></ul></blockquote><h5 id="TPC"><a href="#TPC" class="headerlink" title="TPC:"></a>TPC:</h5><blockquote><p>测试每秒处理的事务数</p></blockquote><h4 id="量化-Amdahl定律，CPU时间计算"><a href="#量化-Amdahl定律，CPU时间计算" class="headerlink" title="量化:Amdahl定律，CPU时间计算"></a>量化:Amdahl定律，CPU时间计算</h4><blockquote><p><strong>CPU时间：</strong>执行一组指令用的时间</p><ul><li><p>$Instruction_Num * \overline{Instruction_Time}$</p></li><li><p>$\overline{Instruction_Time}=CPI * Clock_Cycle_Time$</p></li></ul><p><strong>Amdahl定律</strong></p><ul><li><p>$S_e(加速比) = \frac{改进后的性能/(未改进执行时间)}{未改进的性能/(改进后的执行时间)}$</p></li><li><p>$改进后的执行时间 = \frac{改进部分执行时间}{加速比}+不可改进部分执行时间$</p></li></ul><p>$F_e$：改进部分所占执行时间比例</p><ul><li>$T_n = T_0(1 - F_e + \frac{F_e}{S_e})$</li><li>改进后系统加速比为：</li><li>$\frac{1}{1 - F_e + \frac{F_e}{S_e}}$</li></ul></blockquote><h4 id="了解性价比-桌面机，服务器"><a href="#了解性价比-桌面机，服务器" class="headerlink" title="了解性价比:桌面机，服务器"></a>了解性价比:桌面机，服务器</h4><blockquote><p>​    </p></blockquote><h2 id="第2章-指令系统"><a href="#第2章-指令系统" class="headerlink" title="第2章 指令系统"></a>第2章 指令系统</h2><h4 id="指令集系统结构分类及特点"><a href="#指令集系统结构分类及特点" class="headerlink" title="指令集系统结构分类及特点"></a>指令集系统结构分类及特点</h4><blockquote><p>堆栈、累加器、通用寄存器</p></blockquote><h4 id="通用寄存器系统结构的分类及特点"><a href="#通用寄存器系统结构的分类及特点" class="headerlink" title="通用寄存器系统结构的分类及特点"></a>通用寄存器系统结构的分类及特点</h4><blockquote><ul><li><p>r-m</p></li><li><p>r-r/load-store</p></li></ul></blockquote><h4 id="存储器寻址-基本单位、小端与大端模式、对齐访问"><a href="#存储器寻址-基本单位、小端与大端模式、对齐访问" class="headerlink" title="存储器寻址:基本单位、小端与大端模式、对齐访问"></a>存储器寻址:基本单位、小端与大端模式、对齐访问</h4><blockquote><p>​    </p></blockquote><h4 id="最常用寻址方式"><a href="#最常用寻址方式" class="headerlink" title="最常用寻址方式"></a>最常用寻址方式</h4><blockquote><p>​    </p></blockquote><h4 id="常用操作数类型"><a href="#常用操作数类型" class="headerlink" title="常用操作数类型"></a>常用操作数类型</h4><blockquote><ul><li>用操作码编码指定</li><li>用硬件解释字段表示数据类型</li></ul></blockquote><h4 id="常用指令操作"><a href="#常用指令操作" class="headerlink" title="常用指令操作"></a>常用指令操作</h4><blockquote><p>​    </p></blockquote><h4 id="常用指令系统编码方式"><a href="#常用指令系统编码方式" class="headerlink" title="常用指令系统编码方式"></a>常用指令系统编码方式</h4><blockquote><ul><li>变长编码：代码长度可以减少</li><li>定长编码：性能提高，利用流水线</li><li>混合方法：折中方式</li></ul></blockquote><h4 id="MIPS系统结构的指令格式、寻址方式特点。"><a href="#MIPS系统结构的指令格式、寻址方式特点。" class="headerlink" title="MIPS系统结构的指令格式、寻址方式特点。"></a>MIPS系统结构的指令格式、寻址方式特点。</h4><blockquote><p>32位定长指令</p></blockquote><h2 id="第3章-流水线技术"><a href="#第3章-流水线技术" class="headerlink" title="第3章 流水线技术"></a>第3章 流水线技术</h2><h4 id="流水线定义"><a href="#流水线定义" class="headerlink" title="流水线定义"></a>流水线定义</h4><blockquote><p>利用执行指令操作间的并行性，实现多条指令重叠执行的技术</p></blockquote><h4 id="流水线的三种冒险及解决方法"><a href="#流水线的三种冒险及解决方法" class="headerlink" title="流水线的三种冒险及解决方法"></a>流水线的三种冒险及解决方法</h4><blockquote><p><strong>控制冒险</strong></p><ul><li>WB先写，ID后读</li><li>分离指令寄存器和数据寄存器</li><li>增加硬件资源或功能部件完全流水</li><li>停顿流水线</li></ul><p><strong>数据冒险</strong></p><ul><li>WB先写，ID后读</li><li>Forwarding</li><li>Load数据冒险</li><li>停顿</li></ul><p><strong>控制冒险</strong></p><ul><li>停顿流水线</li><li>预测转移不发生</li><li>预测转移发生</li><li>转移延迟</li></ul></blockquote><h4 id="流水线模型机指令系统、无相关流水线模型机多条指令执行过程，流水线模型机的控制信号的产生"><a href="#流水线模型机指令系统、无相关流水线模型机多条指令执行过程，流水线模型机的控制信号的产生" class="headerlink" title="流水线模型机指令系统、无相关流水线模型机多条指令执行过程，流水线模型机的控制信号的产生"></a>流水线模型机指令系统、无相关流水线模型机多条指令执行过程，流水线模型机的控制信号的产生</h4><blockquote><p>​    </p></blockquote><h4 id="流水线模型机中结构相关处理，数据前推、load前推实现，-控制相关处理，指令执行的时序图"><a href="#流水线模型机中结构相关处理，数据前推、load前推实现，-控制相关处理，指令执行的时序图" class="headerlink" title="流水线模型机中结构相关处理，数据前推、load前推实现， 控制相关处理，指令执行的时序图"></a>流水线模型机中结构相关处理，数据前推、load前推实现， 控制相关处理，指令执行的时序图</h4><blockquote><p>​    </p></blockquote><h4 id="精确异常与非精确异常"><a href="#精确异常与非精确异常" class="headerlink" title="精确异常与非精确异常"></a>精确异常与非精确异常</h4><blockquote><p><strong>精确异常</strong></p><ul><li>异常发生之前的指令正常结束，之后的指令暂停，并在处理完异常之后能重新启动。</li><li>要求顺序处理异常</li><li>设置异常向量，异常发生，记录异常，禁止写操作。</li><li>一条指令将离开流水线，检测异常向量</li><li>若多个异常，响应最早流水段的异常</li></ul><p><strong>非精确异常</strong></p><ul><li>异常乱序</li></ul></blockquote><h4 id="经典5段流水线扩展浮点流水线，涉及到的写冲突、相关及处理"><a href="#经典5段流水线扩展浮点流水线，涉及到的写冲突、相关及处理" class="headerlink" title="经典5段流水线扩展浮点流水线，涉及到的写冲突、相关及处理"></a>经典5段流水线扩展浮点流水线，涉及到的写冲突、相关及处理</h4><blockquote><p>除法部件不参与流水线</p><p>RAW</p><ul><li>ID级检测源寄存器是否和EX/A/DIV/M各级流水线的目的寄存器相同</li></ul><p>WAW</p><ul><li>ID级检测目的寄存器是否和EX/A/DIV/M各级流水线的目的寄存器相同</li></ul><p>WAR</p></blockquote><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><blockquote><ul><li>忽略这个异常</li><li>缓存结果，cpu执行完之前不改变任何状态(中间寄存器或历史文件未来文件)</li><li>确认无异常，才继续流水线</li><li></li></ul></blockquote><h2 id="第4章-指令级并行及限制"><a href="#第4章-指令级并行及限制" class="headerlink" title="第4章 指令级并行及限制"></a>第4章 指令级并行及限制</h2><h4 id="静态调度的循环展开方法，名相关，寄存器换名-编译器实现"><a href="#静态调度的循环展开方法，名相关，寄存器换名-编译器实现" class="headerlink" title="静态调度的循环展开方法，名相关，寄存器换名(编译器实现)"></a>静态调度的循环展开方法，名相关，寄存器换名(编译器实现)</h4><h4 id="动态调度，记分牌算法，-Tomasulo算法"><a href="#动态调度，记分牌算法，-Tomasulo算法" class="headerlink" title="动态调度，记分牌算法， Tomasulo算法"></a>动态调度，记分牌算法， Tomasulo算法</h4><blockquote><p><strong>记分牌</strong></p><ul><li><strong>IS</strong>: <code>无WAW &amp; 无结构冒险</code></li><li><strong>RO</strong>：<code>源操作数就绪 &amp; 无 RAW</code></li><li><strong>EXE</strong></li><li><strong>WR</strong>：<code>无WAR</code></li><li>等待此寄存器的R即为yes</li></ul><p><strong>Tomasulo</strong></p><p><strong>IS</strong></p><p>进入条件：<code>有空闲保留栈/缓冲</code></p><p>浮点操作：</p><ul><li>若源操作数有效，写数据，否则写产生源操作数的部件</li><li>本保留栈busy</li><li>送结果寄存器的表</li></ul><p>存取操作</p><ul><li>若地址基址寄存器有效写$V_j$，否则将产生基址寄存器的部件写$Q_j$</li><li>本保留栈busy</li><li>A存偏移</li><li>取：将取缓冲送至寄存器表</li><li>存：若存结果有效写$V_k$，否则写$Q_k$</li></ul><hr><p><strong>EXE</strong></p><p>进入条件：<code>源操作数就绪 &amp; 基址寄存器有效(LD|SD) &amp; 到达缓冲队首(LD|SD)</code></p><p>浮点操作：</p><ul><li>产生结果</li></ul><p>存取操作</p><ul><li>计算A<ul><li>取：读数</li></ul></li></ul><hr><p><strong>WR</strong></p><p>进入条件：<code>CDB空闲 &amp; 结果有效 &amp; 要存入的数据准备好</code></p><ul><li>写寄存器/存储器</li><li>寄存器表相应位置清</li><li>找源操作是本保留栈的将数据填入</li></ul></blockquote><h4 id="动态转移预测，BPB，BTB，前瞻执行的-基本概念"><a href="#动态转移预测，BPB，BTB，前瞻执行的-基本概念" class="headerlink" title="动态转移预测，BPB，BTB，前瞻执行的 基本概念"></a>动态转移预测，BPB，BTB，前瞻执行的 基本概念</h4><blockquote><p>branch prediction buffer：减少判断跳转的停顿</p><p>branch target buffer：记录转移地址在buffer中，转移成功，直接取buffer中的目标地址</p><p>前瞻执行：ROB存放未确认结果</p></blockquote><h2 id="第5章-存储系统"><a href="#第5章-存储系统" class="headerlink" title="第5章 存储系统"></a>第5章 存储系统</h2><h4 id="Cache存储器的三种映像方式-全相联、直接映像，组相联"><a href="#Cache存储器的三种映像方式-全相联、直接映像，组相联" class="headerlink" title="Cache存储器的三种映像方式(全相联、直接映像，组相联)"></a>Cache存储器的三种映像方式(全相联、直接映像，组相联)</h4><blockquote><p>​    </p></blockquote><h4 id="物理地址与Cache地址的映射计算"><a href="#物理地址与Cache地址的映射计算" class="headerlink" title="物理地址与Cache地址的映射计算"></a>物理地址与Cache地址的映射计算</h4><blockquote><p>​    </p></blockquote><h4 id="Cache的映像规则，块标识，替换算法，写策略"><a href="#Cache的映像规则，块标识，替换算法，写策略" class="headerlink" title="Cache的映像规则，块标识，替换算法，写策略"></a>Cache的映像规则，块标识，替换算法，写策略</h4><blockquote><p><code>写策略</code></p><ul><li>写直达：缺失时<strong>不按写分配</strong></li><li>写回：缺失时<strong>写分配</strong></li></ul></blockquote><h4 id="Cache性能优化的方法"><a href="#Cache性能优化的方法" class="headerlink" title="Cache性能优化的方法"></a>Cache性能优化的方法</h4><blockquote><p><code>减少缺失率</code>$^4$</p><ul><li><p>增加块大小</p></li><li><p>增大cache容量</p></li><li><p>更高相联度</p></li><li><p>编译优化</p></li></ul><p><code>减少缺失代价</code>$^5$</p><ul><li><p>多级caches</p></li><li><p>关键字优先</p></li><li><p>读缺失优于写缺失</p></li><li><p>合并写缓冲</p></li><li><p>牺牲缓冲</p></li></ul><p><code>并行减少缺失率与缺失代价</code>$^3$</p><ul><li><p>非阻塞caches</p></li><li><p>硬件预取</p></li><li><p>编译预取</p></li></ul><p><code>减少命中时间</code> $^5$</p><ul><li>小和简单的caches</li><li>避免地址转换</li><li>流水线cache访问</li><li>路预测</li><li>踪迹 caches</li></ul></blockquote><h4 id="主存储器优化性能的技术"><a href="#主存储器优化性能的技术" class="headerlink" title="主存储器优化性能的技术"></a>主存储器优化性能的技术</h4><blockquote><ul><li>增加带宽</li><li>交叉访问存储器 </li></ul></blockquote><h4 id="虚拟存储器基本概念，页式虚拟存储器，映像规则，查找方法，替换算法，写策略，快表TLB的结构与作用-虚拟存储器与cache的综合"><a href="#虚拟存储器基本概念，页式虚拟存储器，映像规则，查找方法，替换算法，写策略，快表TLB的结构与作用-虚拟存储器与cache的综合" class="headerlink" title="虚拟存储器基本概念，页式虚拟存储器，映像规则，查找方法，替换算法，写策略，快表TLB的结构与作用 虚拟存储器与cache的综合"></a>虚拟存储器基本概念，页式虚拟存储器，映像规则，查找方法，替换算法，写策略，快表TLB的结构与作用 虚拟存储器与cache的综合</h4><blockquote><ul><li>全相联</li><li></li></ul></blockquote><h2 id="第6章-多线程和多处理器"><a href="#第6章-多线程和多处理器" class="headerlink" title="第6章 多线程和多处理器"></a>第6章 多线程和多处理器</h2><h4 id="ILP与TLP的基本概念"><a href="#ILP与TLP的基本概念" class="headerlink" title="ILP与TLP的基本概念"></a>ILP与TLP的基本概念</h4><blockquote><p>ILP：指令级并行</p><p>TLP：线程级并行</p></blockquote><h4 id="超标量、粗粒度、细粒度和SMT的基本概念。"><a href="#超标量、粗粒度、细粒度和SMT的基本概念。" class="headerlink" title="超标量、粗粒度、细粒度和SMT的基本概念。"></a>超标量、粗粒度、细粒度和SMT的基本概念。</h4><blockquote><p>超标量：单线程</p><p>粗粒度：仅在长空闲周期才切换线程</p><p>细粒度：可在每个周期切换线程</p><p>同时多线程：SMT，一个周期内发射不同线程的指令</p></blockquote><h4 id="多处理器的两种分类结构。"><a href="#多处理器的两种分类结构。" class="headerlink" title="多处理器的两种分类结构。"></a>多处理器的两种分类结构。</h4><blockquote><ul><li>集中共享存储器架构</li><li>分布式存储器架构</li></ul></blockquote><h4 id="同构多核与异构多核的基本概念。"><a href="#同构多核与异构多核的基本概念。" class="headerlink" title="同构多核与异构多核的基本概念。"></a>同构多核与异构多核的基本概念。</h4><blockquote><p>​    </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2019/06/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2019/06/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h4 id="程序语言分类"><a href="#程序语言分类" class="headerlink" title="程序语言分类"></a>程序语言分类</h4><blockquote><ol><li>强制式语言:基础为冯诺依曼体系结构<ul><li>变量</li><li>赋值</li><li>重复</li></ul></li><li>函数式语言</li><li>逻辑式语言</li><li>对象式语言:抽象数据类型</li></ol></blockquote><h4 id="变量及属性"><a href="#变量及属性" class="headerlink" title="变量及属性"></a>变量及属性</h4><blockquote><p><strong>变量</strong>：一个(一组)已经命名的存储单元</p><ul><li>作用域： 可访问该变量的程序范围<ul><li>静态作用域绑定：按照语法定义作用域</li><li>动态作用域绑定：按照程序执行动态定义作用域</li></ul></li><li>生存期：一个存储区绑定与一个变量的时间区间</li><li>值：变量对应存储单元存的值</li><li>类型：变量的值的类型及操作</li></ul></blockquote><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><blockquote><p>虚拟机是由实际机器加软件实现的机器</p></blockquote><h4 id="抽象机"><a href="#抽象机" class="headerlink" title="抽象机"></a>抽象机</h4><blockquote><p>抽象机是用自动机模型创造出的硬件/软件理论模型</p></blockquote><h4 id="程序单元及单元实例"><a href="#程序单元及单元实例" class="headerlink" title="程序单元及单元实例"></a>程序单元及单元实例</h4><blockquote><p><strong>程序单元</strong>：程序执行过程中独立调用的单位</p><p><strong>活动记录</strong>：执行该程序单元所必须信息&amp;局部变量绑定的存储区</p><p><strong>单元实例</strong>：程序单元运行时由代买段和活动记录组成，称为单元实例</p></blockquote><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><p>数据类型为对存储值的抽象，包括：</p><ul><li>一组值的集合</li><li>一组操作</li></ul><p>分类：</p><ul><li>内部类型:语言定义的数据类型</li><li>自定义类型</li></ul></blockquote><h4 id="数据类型的作用"><a href="#数据类型的作用" class="headerlink" title="数据类型的作用"></a>数据类型的作用</h4><blockquote><ol><li>实现了数据抽象</li><li>使程序员从机器的具体特征中脱离</li><li>提高了编程效率</li></ol></blockquote><h4 id="内部类型的优点"><a href="#内部类型的优点" class="headerlink" title="内部类型的优点"></a>内部类型的优点</h4><blockquote><ul><li>基本表示的不可见</li><li>编译时检测变量的正确性</li><li>编译时确定无二义操作</li><li>精度控制</li></ul></blockquote><h4 id="数据聚合的六种方式"><a href="#数据聚合的六种方式" class="headerlink" title="数据聚合的六种方式"></a>数据聚合的六种方式</h4><blockquote><ol><li>笛卡尔积<ul><li>$A_1 <em> A_2 </em> A_3 <em> \dots </em> A_n $</li><li>C：Struct</li><li>Pascal：Record</li></ul></li><li>有限映像(映射)</li></ol><ul><li>数组</li></ul><ol><li>序列<ul><li>由任意多个数据项组成，每个数据项有相同的数据类型</li></ul></li></ol><ul><li>串/顺序文件</li></ul><ol><li><p>递归</p><ul><li>数据类型T的定义包含T的成分</li><li>二叉树的定义</li></ul></li><li><p>判定或</p><ul><li>在两个不同选择对象间做出适当的选择</li><li>C：Union</li><li>Pascal：Record</li></ul></li><li><p>幂集</p><ul><li>类型是基类型的子集</li></ul></li></ol></blockquote><h4 id="抽象数据类型的定义及使用"><a href="#抽象数据类型的定义及使用" class="headerlink" title="抽象数据类型的定义及使用"></a>抽象数据类型的定义及使用</h4><blockquote><ul><li>在定义该类型的程序单元中，定义类型操作</li><li>在使用该类型的程序单元中，类型表示是隐蔽的</li></ul></blockquote><h4 id="类型检查及分类"><a href="#类型检查及分类" class="headerlink" title="类型检查及分类"></a>类型检查及分类</h4><blockquote><p>对数据对象的类型和操作是否匹配的检查</p><p>动态/静态</p></blockquote><h4 id="等价类型"><a href="#等价类型" class="headerlink" title="等价类型"></a>等价类型</h4><blockquote><p>两个类型可以互相赋值，一个类型的实参可以对应另一个类型的形参</p><ul><li>名等价：类型名相同</li><li>结构等价：类型具有相同的结构</li></ul></blockquote><h4 id="语句级控制结构"><a href="#语句级控制结构" class="headerlink" title="语句级控制结构"></a>语句级控制结构</h4><blockquote><p>控制语句执行顺序的机制：</p><ul><li>顺序</li><li>选择：if else/switch</li><li>重复：for/while</li></ul></blockquote><h4 id="单元级控制结构"><a href="#单元级控制结构" class="headerlink" title="单元级控制结构"></a>单元级控制结构</h4><blockquote><p>控制程序单元间流程的机制</p><ul><li>显示调用<ul><li>调用语句使用被调用语句名来调用</li><li>参数绑定的两种方式<ul><li>位置绑定</li><li>关键字绑定</li></ul></li></ul></li><li>异常处理<ul><li>隐式调用</li><li>发生异常，传递信号，调用特定函数处理</li></ul></li><li>协同程序<ul><li>两个或两个以上的程序单元交替执行</li></ul></li><li>并发单元<ul><li>程序单元并行执行</li></ul></li></ul></blockquote><h4 id="副作用-别名"><a href="#副作用-别名" class="headerlink" title="副作用/别名"></a>副作用/别名</h4><blockquote><p>引用环境：局部变量+非局部变量</p><p>别名：同一引用环境中，几个变量绑定于同一数据对象</p><p>副作用：对绑定的非局部变量修改时产生副作用</p><ul><li>降低程序可读性</li><li>限制数学运算律</li><li>影响目标代码优化</li></ul></blockquote><h4 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h4><blockquote><p>语言是描述计算机执行算法的形式表示</p><p>语法+语义</p></blockquote><h4 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h4><blockquote><p>文法是描述语法结构的形式规则</p></blockquote><h4 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h4><blockquote><p>0型文法：</p><ul><li>$\alpha \rightarrow \beta$</li></ul><p>1型文法(上下文相关文法)：</p><ul><li>$|\beta| \geq |\alpha|$</li></ul><p>2型文法(上下文无关文法):</p><ul><li>$A \rightarrow \alpha$</li><li>在1型文法基础上要求$\alpha$为非终结符</li></ul><p>3型文法(正则文法/右线性文法)</p><ul><li>$A \rightarrow \alpha | A \rightarrow \alpha B$</li></ul></blockquote><h4 id="算符文法"><a href="#算符文法" class="headerlink" title="算符文法"></a>算符文法</h4><blockquote><p>上下文无关文法(2型)，产生式右端没有相接的非终结符，没有空产生式，即为算符文法</p></blockquote><h4 id="语法描述的基本用途"><a href="#语法描述的基本用途" class="headerlink" title="语法描述的基本用途"></a>语法描述的基本用途</h4><blockquote><ol><li>表达语言设计者的意图及设计目标</li><li>指导语言的使用者如何写一个正确的程序</li><li>指导语言的实现者如何检测识别正确程序</li></ol></blockquote><h4 id="推导，语言，句型，句子，文法等价"><a href="#推导，语言，句型，句子，文法等价" class="headerlink" title="推导，语言，句型，句子，文法等价"></a>推导，语言，句型，句子，文法等价</h4><blockquote><p>$S \rightarrow ^{*}\alpha$</p><p>句型：$\alpha \in V^*$</p><p>句子：$\alpha \in V_{T}^{*}$</p><p>语言：由文法推出的所有句子的集合，记L(G)</p><p>文法等价：若两个文法产生的语言相同，则称其等价</p></blockquote><h4 id="短语，句柄，直接短语，素短语"><a href="#短语，句柄，直接短语，素短语" class="headerlink" title="短语，句柄，直接短语，素短语"></a>短语，句柄，直接短语，素短语</h4><blockquote><p>短语：$\alpha A \beta$是一个句型，A-&gt;$\omega$，则$\omega$为句型关于非终结符A的短语</p><ul><li>语法树一个节点的所有子节点的叶子结点构成其短语</li></ul><p>句柄：句型的最左直接短语</p><p>直接短语: A-&gt;$\alpha$</p><p>素短语：</p></blockquote><h4 id="语法树-推导树"><a href="#语法树-推导树" class="headerlink" title="语法树(推导树)"></a>语法树(推导树)</h4><blockquote><p>无二义性文法只有一个语法树</p></blockquote><h4 id="规范规约"><a href="#规范规约" class="headerlink" title="规范规约"></a>规范规约</h4><blockquote><p>最左规约</p></blockquote><h4 id="规范推导"><a href="#规范推导" class="headerlink" title="规范推导"></a>规范推导</h4><blockquote><p>最右推导</p></blockquote><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h4 id="编译的概念-编译及翻译"><a href="#编译的概念-编译及翻译" class="headerlink" title="编译的概念(编译及翻译)"></a>编译的概念(编译及翻译)</h4><blockquote><p>翻译：将一种语言编写的程序转换为另一种语言的完全等效的程序</p><p>编译程序：高级语言 $\rightarrow$ 低级语言</p><ul><li>宿主语言：编写编译程序的语言</li></ul><p>汇编程序：汇编语言 $\rightarrow$ 机器语言</p></blockquote><h4 id="词法分析器的作用"><a href="#词法分析器的作用" class="headerlink" title="词法分析器的作用"></a>词法分析器的作用</h4><blockquote><ul><li>扫描符号串，按词法规则生成单词表</li><li>识别词法错误</li></ul></blockquote><h4 id="单词符号的分类"><a href="#单词符号的分类" class="headerlink" title="单词符号的分类"></a>单词符号的分类</h4><blockquote><ul><li>标识符</li><li>基本字</li><li>常数</li><li>运算符</li><li>界符: ; /<em> </em>/等</li></ul></blockquote><h4 id="公共左因子-左递归的消除"><a href="#公共左因子-左递归的消除" class="headerlink" title="公共左因子/左递归的消除"></a>公共左因子/左递归的消除</h4><p>&gt;</p><h4 id="FIRST-FOLLOW集，预测分析表的构造-预测分析"><a href="#FIRST-FOLLOW集，预测分析表的构造-预测分析" class="headerlink" title="FIRST/FOLLOW集，预测分析表的构造(预测分析)"></a>FIRST/FOLLOW集，预测分析表的构造(预测分析)</h4><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_FIRST_0.png" alt=""></p><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_FIRST_1.png" alt=""></p><blockquote><ul><li>FOLLOW集不漏的求法:<ul><li>终结符：$S \rightarrow Aa, a \in FOLLOW(A)$</li><li>FIRST集：$S \rightarrow AB, FIRST(B) \subseteq FOLLOW(A)$</li><li>尾非终结符：$S \rightarrow \dots A, FOLLOW(S) \subseteq FOLLOW(A)$</li><li>特判$FIRST$为$\varepsilon$时的情况</li></ul></li></ul></blockquote><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_FOLLOW.png" alt=""></p><h4 id="FIRSTVT-LASTVT集，优先关系表构造-算符优先"><a href="#FIRSTVT-LASTVT集，优先关系表构造-算符优先" class="headerlink" title="FIRSTVT/LASTVT集，优先关系表构造(算符优先)"></a>FIRSTVT/LASTVT集，优先关系表构造(算符优先)</h4><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_FIRSTVT.png" alt=""></p><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_LASTVT.png" alt=""></p><h4 id="LR分析法-LR-0-，-SLR-1-，项目规范族及分析表"><a href="#LR分析法-LR-0-，-SLR-1-，项目规范族及分析表" class="headerlink" title="LR分析法(LR(0)， SLR(1))，项目规范族及分析表"></a>LR分析法(LR(0)， SLR(1))，项目规范族及分析表</h4><p>&gt;</p><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>语义检查</p><ul><li>一致性检查</li><li>越界检查</li></ul><p>语义处理</p><ul><li>说明语句：登记信息</li><li>执行语句：生成中间代码</li></ul><h4 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h4><blockquote><p>在语法分析过程中，根据每个产生式对应的语义子程序，进行翻译生成中间代码的方法。</p></blockquote><h4 id="翻译结果-四元式-三地址式"><a href="#翻译结果-四元式-三地址式" class="headerlink" title="翻译结果:四元式/三地址式"></a>翻译结果:四元式/三地址式</h4><p>&gt;</p><h4 id="语义子程序"><a href="#语义子程序" class="headerlink" title="语义子程序"></a>语义子程序</h4><p>&gt;</p><h4 id="局部优化方法"><a href="#局部优化方法" class="headerlink" title="局部优化方法"></a>局部优化方法</h4><blockquote><p>在基本块内优化</p><ul><li>合并已知量</li><li>删除公共子表达式</li><li>删除无用赋值</li><li>删除死代码</li></ul></blockquote><h4 id="全局优化方法"><a href="#全局优化方法" class="headerlink" title="全局优化方法"></a>全局优化方法</h4><blockquote><p>循环优化方法</p><ul><li><p>代码外提</p></li><li><p>强度削弱</p><ul><li>同族归纳变量：$j = c_1 * i + c_2$</li><li>与循环计数器相关的值(同族归纳变量)，将其转换为与循环计数器无关的赋值(需在循环外初始化)</li><li>删除归纳变量</li></ul></li><li><p>将同族归纳变量作为判断条件</p></li></ul></blockquote><h4 id="寄存器分配原则"><a href="#寄存器分配原则" class="headerlink" title="寄存器分配原则"></a>寄存器分配原则</h4><blockquote><ul><li>本身占用寄存器</li><li>有空余寄存器</li><li>无空余寄存器：选择替换一个<ol><li>或在内存中有保留副本的</li><li>或之后最远引用的</li><li>或在之后不再引用的</li></ol></li></ul></blockquote><h4 id="活动记录内容"><a href="#活动记录内容" class="headerlink" title="活动记录内容"></a>活动记录内容</h4><blockquote><ol><li>返回指针</li><li>动态链接</li><li>静态链接</li><li>现场保护</li><li>参数个数</li><li>参数单元</li><li>局部变量</li><li>临时变量</li></ol></blockquote><h4 id="三种分配方式-静态-栈式-堆分配"><a href="#三种分配方式-静态-栈式-堆分配" class="headerlink" title="三种分配方式(静态/栈式/堆分配)"></a>三种分配方式(静态/栈式/堆分配)</h4><blockquote><p>静态分配：编译时进行存储分配</p></blockquote><h4 id="仅含半静态变量的栈式分配"><a href="#仅含半静态变量的栈式分配" class="headerlink" title="仅含半静态变量的栈式分配"></a>仅含半静态变量的栈式分配</h4><p>&gt;</p><h4 id="允许过程嵌套定义的栈式分配"><a href="#允许过程嵌套定义的栈式分配" class="headerlink" title="允许过程嵌套定义的栈式分配"></a>允许过程嵌套定义的栈式分配</h4><p>&gt;</p><h4 id="静态作用域规则"><a href="#静态作用域规则" class="headerlink" title="静态作用域规则"></a>静态作用域规则</h4><blockquote><p>最近嵌套规则</p></blockquote><h4 id="动态作用域规则"><a href="#动态作用域规则" class="headerlink" title="动态作用域规则"></a>动态作用域规则</h4><blockquote><p>最近嵌套规则(最近调用)</p></blockquote><h4 id="数据参数传递的几种方法"><a href="#数据参数传递的几种方法" class="headerlink" title="数据参数传递的几种方法"></a>数据参数传递的几种方法</h4><blockquote><ul><li>传值</li><li>传地址</li><li>传名</li></ul></blockquote><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><blockquote><p>程序流图中有唯一入口结点的强连通子图</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言与微机接口</title>
    <link href="/2019/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <url>/2019/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h2 id="8086微处理器结构"><a href="#8086微处理器结构" class="headerlink" title="8086微处理器结构"></a>8086微处理器结构</h2><h4 id="8086结构"><a href="#8086结构" class="headerlink" title="8086结构"></a>8086结构</h4><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_8086cpu.png" width=400></p><blockquote><p>总线接口部件BIU</p></blockquote><ul><li>从内存取指令到指令队列</li><li>取操作数并放到指定单元</li><li>通过20位地址加法器产生地址</li></ul><blockquote><p>执行部件EU</p></blockquote><ul><li>从指令队列取指令</li><li>译码</li><li>接受总线数据</li><li>算数运算</li></ul><p>专用寄存器</p><ul><li>SP：堆栈指针寄存器</li><li>BP：基址指针寄存器(<strong>SS</strong>:BP)</li><li>DI：目的变址寄存器(DS:DI)</li><li>SI：源变址寄存器(DS:SI)</li></ul><p>通用寄存器</p><ul><li>AX：累加器，所有I/O指令通过AX传送信息</li><li>BX：基址寄存器(DS:BX)，XLAT放表首</li><li>CX：计数寄存器，循环或串操作放计数值</li><li>DX：数据寄存器。I/O寻址时放I/O端口地址。32位乘除法，放高16位数。</li></ul><p>FLAGS</p><div class="table-container"><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>OF</td><td>溢出</td></tr><tr><td>DF</td><td>方向标志,0增</td></tr><tr><td>IF</td><td>中断允许(INTR受影响，NMI不受影响)</td></tr><tr><td>TF</td><td>单步中断</td></tr><tr><td>SF</td><td>符号标志</td></tr><tr><td>ZF</td><td>零标志</td></tr><tr><td>AF</td><td>半进位(低4位向高4位进位、借位)</td></tr><tr><td>PF</td><td>奇校验</td></tr><tr><td>CF</td><td>进位借位标志</td></tr></tbody></table></div><h4 id="8086CPU引脚及功能"><a href="#8086CPU引脚及功能" class="headerlink" title="8086CPU引脚及功能"></a>8086CPU引脚及功能</h4><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_8086_cpu.png" width=300></p><blockquote><p>8086编址</p></blockquote><p>8088/8086有20根地址线，可寻址1MB空间，采用小端存储方式</p><ul><li>物理地址：20位</li><li>逻辑地址：16位段基址，16位段偏移(段最大64K，段基址需为16的倍数，即低4位为0)</li></ul><blockquote><p>8086工作相关</p></blockquote><p>最小模式：只有一块8086</p><p>最大模式：多个cpu，一个主cpu8086，一个协cpu8087</p><p>T状态：cpu处理动作最小的单位</p><blockquote><p>8088最小模式下引脚及功能</p></blockquote><ul><li>8086最小引脚与8088不同为<ul><li>8086：$AD15-AD0$</li><li>8088：$AD7- AD0，A8- A15$</li></ul></li></ul><div class="table-container"><table><thead><tr><th>引脚</th><th>功能</th><th>相关操作</th></tr></thead><tbody><tr><td>AD7 ~ AD0</td><td><strong>地址/数据</strong>(A/D)复用总线，双向，三态<br />1. T1态，为地址总线<br />2. T2~T4态，为数据总线</td><td>存储器/IO</td></tr><tr><td>A8 ~ A15</td><td><strong>地址总线</strong></td><td>存储器/IO</td></tr><tr><td>A19~A16/S6-S3</td><td><strong>地址/状态</strong>复用总线</td><td>存储器/IO</td></tr><tr><td>ALE</td><td><strong>地址锁存信号</strong><br />高电平表示A15 ~ A0地址有效</td><td>存储器/IO</td></tr><tr><td>$\overline{DEN}$</td><td><strong>数据允许信号</strong><br />低电平表示总线上有有效数据</td><td>存储器/IO</td></tr><tr><td>$IO/\overline{M}$</td><td><strong>存储器/IO访问信号</strong></td><td>存储器/IO</td></tr><tr><td>READY</td><td><strong>数据(IO/M)准备就绪信号</strong></td><td>存储器/IO</td></tr><tr><td>$DT/\overline{R}$</td><td><strong>数据传送方向信号</strong><br />高电平写，低电平读</td><td>存储器/IO</td></tr><tr><td>$\overline{RD}$<br />$\overline{WR}$</td><td><strong>读写信号</strong>，三态输出，低电平有效</td><td>存储器/IO</td></tr><tr><td>INTR</td><td><strong>可屏蔽中断请求信号</strong><br />INTR=1，表示有中断请求，IF=1，响应中断</td><td>可屏蔽中断</td></tr><tr><td>$\overline{INTA}$</td><td><strong>中断响应信号</strong><br />第一个负脉冲，表示CPU响应中断申请INTR<br />第二个负脉冲，通知外设向数据总线放中断类型号</td><td>可屏蔽中断</td></tr><tr><td>NMI</td><td><strong>不可屏蔽中断请求信号</strong><br />上升沿触发，执行完当前指令后立即响应中断，不受IF控制</td><td>不可屏蔽中断</td></tr><tr><td>$\overline{TEST}$</td><td><strong>测试信号</strong><br />执行WAIT指令时，每个时钟周期测试$\overline{TEST}$若为1，继续等待，直到为0</td><td>WAIT</td></tr><tr><td>RESET</td><td><strong>复位信号</strong>至少保持4周期<br />标志寄存器为0，IP/DS/SS/ES为0，CS=FFFFH，指令从FFFF0H开始执行</td><td></td></tr><tr><td>HOLD</td><td><strong>总线请求信号</strong><br />其它控制器请求使用总线</td><td>DMA</td></tr><tr><td>HLDA</td><td><strong>总线请求响应</strong><br />高电平时，CPU让出总线</td><td>DMA</td></tr><tr><td>$MN/ \overline{MX}$</td><td><strong>工作模式选择信号</strong><br />高电平表示最小模式</td><td></td></tr><tr><td>CLK</td><td><strong>时钟信号</strong></td></tr></tbody></table></div><blockquote><p>总线周期</p></blockquote><ul><li>一般需要4个时钟周期</li><li>T1：ALE为高电平，A0~A19输出地址</li><li>T2<ul><li>写周期将数据送到总线上，$\overline{DEN}$为低持续到T4结束，$\overline{WR}$为低持续到T3</li><li>读周期A19-A16/S6-S3输出状态到T4结束</li></ul></li><li>T3<ul><li>读周期$\overline{DEN}, \overline{RD}$为低，持续到T4，AD0 - AD7输出数据到T4</li></ul></li><li>T4</li><li>可以加READY信号，若为电平，则延续一个周期T3，到下个周期继续检查READY</li></ul><blockquote><p>8088读周期</p></blockquote><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_8088_read.png" width=400></p><blockquote><p>8088写周期</p></blockquote><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_8088_write.png" width=400></p><h2 id="8086指令系统"><a href="#8086指令系统" class="headerlink" title="8086指令系统"></a>8086指令系统</h2><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><ol><li>立即寻址</li><li>寄存器寻址</li><li>直接寻址 (段重设)</li><li>寄存器间接寻址(BX, BP, SI, DI)</li><li>寄存器相对寻址</li><li>基址变址寻址</li><li>基址变址相对寻址</li></ol><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_data_dir.png"  width=500></p><blockquote><p><strong>PUSH/POP</strong> source/dest</p></blockquote><ul><li>16位</li><li>不能是立即数</li></ul><blockquote><p><strong>MOV</strong> dest, source</p></blockquote><ul><li>段寄存器不能与段寄存器与立即数直接传送</li><li>存储器间不能直接传送</li><li>cs、ip，立即数不能做目的操作数</li></ul><blockquote><p><strong>XCHG</strong> dest, source</p></blockquote><ul><li>交换指令，操作数必须有寄存器</li><li>不能有段寄存器</li></ul><blockquote><p><strong>XLAT</strong> [source]</p></blockquote><ul><li>BX首地址，AL偏移量</li><li>AL&lt;=[BX+AL]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">XLAT<br>XLAT source ;source为表首地址<br></code></pre></td></tr></table></figure><blockquote><p><strong>CBW/CWD</strong></p></blockquote><ul><li>隐含寻址，AX/DX</li><li>CBW AL符号扩展至AH</li><li>CWD AX符号扩展至DX</li></ul><blockquote><p><strong>LEA</strong> dest, source</p></blockquote><ul><li>装入source的偏移地址</li></ul><blockquote><p><strong>LDS/LES</strong> dest, source</p></blockquote><ul><li>LDS REG, MEM<ul><li>将MEME开始的4字节，低2字节送入REG，高2字节送入DS。</li></ul></li><li>LES <ul><li>将MEME开始的4字节，低2字节送入REG，高2字节送入ES。</li></ul></li></ul><blockquote><p><strong>LAHF/SAHF/PUSHF/POPF</strong></p></blockquote><ul><li>LAHF：AH &lt;= Flags低8位</li><li>SAHF：AH =&gt; Flags低8位</li><li>PUSHF：FLAGS入栈</li><li>POPF：将当前栈顶两个单元的内容弹出到FLAGS(会改变TF)</li></ul><h4 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h4><blockquote><p><strong>IN</strong> acc, sourcd; <strong>OUT</strong> dest, acc</p></blockquote><ul><li>只能与AL/AX数据传输</li><li>端口地址为8位时，可以直接给出端口地址</li><li>端口地址为16位时，必须由<strong>DX</strong>给出端口地址</li></ul><h4 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;<br>ADD A, B;A &#x3D; A + B<br>ADC A, B;A &#x3D; A + B + CF<br>INC A;A++<br>;&#x3D;&#x3D;&#x3D;&#x3D;sub&#x3D;&#x3D;&#x3D;&#x3D;<br>SUB A, B<br>SBB A, B;A &#x3D; A - B - CF<br>DEC A;A--<br>NEG A;A &#x3D; 0 - A<br>;&#x3D;&#x3D;&#x3D;&#x3D;mul&#x3D;&#x3D;&#x3D;&#x3D;<br>MUL OPRD<br>;AX &lt;&#x3D; AL x OPRD<br>;DX:AX &lt;&#x3D; AX x OPRD<br>DIV OPRD ;高位存余数，低位存商<br>;AL &lt;&#x3D; AX&#x2F; OPRD; AH &lt;&#x3D; AX % OPRD<br>;AX &lt;&#x3D; DX:AX &#x2F; OPRD; DX &#x3D; DX:AX % OPRD;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>DAA</td><td>AL转为压缩BCD码</td></tr><tr><td>AAA</td></tr></tbody></table></div><h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><p>移动一位：直接给出，移动更多位：必须由CL给出移动位数</p><p>当只位移一位时：</p><ul><li>左移：CF与最高位相同，OF=0</li><li>右移：CF与最低位相同，OF=0</li></ul><p>否则OF状态不定</p><div class="table-container"><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">含义</th><th style="text-align:left">影响标志</th></tr></thead><tbody><tr><td style="text-align:left">SHL/SAL</td><td style="text-align:left">算数逻辑左移<br />低位补0，高位移到CF</td><td style="text-align:left">OF/ZF/CF/PF/SF</td></tr><tr><td style="text-align:left">SHR</td><td style="text-align:left">逻辑右移<br />高位补0，低位移到CF</td><td style="text-align:left">OF/CF</td></tr><tr><td style="text-align:left">SAR</td><td style="text-align:left">算数右移<br />高位补符号，低位移到CF</td><td style="text-align:left">不影响OF、AF影响CF/PF/SF/ZF</td></tr><tr><td style="text-align:left">ROL</td><td style="text-align:left">不带CF的循环左移<br />高位移入CF与最低位</td><td style="text-align:left">CF/OF</td></tr><tr><td style="text-align:left">ROR</td><td style="text-align:left">不带CF的循环右移<br />低位移入CF与最高位</td><td style="text-align:left">CF/OF</td></tr><tr><td style="text-align:left">RCL</td><td style="text-align:left">带CF的循环左移<br />高位移入CF，CF移入最低位</td><td style="text-align:left">CF/OF</td></tr><tr><td style="text-align:left">RCR</td><td style="text-align:left">带CF的循环右移<br />低位移入CF，CF移入最高位</td><td style="text-align:left">CF/OF</td></tr></tbody></table></div><h4 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h4><blockquote><p>串操作指令是8086指令系统中唯一能直接处理源操作数和目的操作数都在内存的指令</p></blockquote><ul><li>源串：DS:SI，可段重设</li><li>目标串: ES:DI，不可段重设</li><li>串长度放在CX中</li><li>串操作后SI/DI自动根据DF变化，DF=0，向地址增量方向修改</li><li>重复前缀在每次执行完串操作后自动修改CX</li></ul><blockquote><p>重复操作前缀</p></blockquote><ul><li>REP</li><li>REPE/REPZ：相等时重复($ZF = 0, CX \neq 0 $)</li><li>REPNE/REPNZ：不相等时重复($ZF = 1, CX \neq 0$)</li></ul><blockquote><ol><li>串传送指令</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;串传送指令<br>MOVS OPRD1, OPRD2;OPRD1为目标串地址，OPRD2为源串地址，目标串地址可段重设<br>MOVSB;一次完成一字节传送<br>MOVSW;一次完成一字传送<br><br>;将2000H: 1200H,开始的100个字节传送到 6000H:0000H开始的内存单元中<br>MOV DS, 2000H;设置源串地址<br>MOV SI, 1200H<br>MOV ES, 6000H;设置目标串地址<br>MOV DI, 0<br>MOV CX, 100<br>CLD;DF&#x3D;0，向地址增量修改<br>REP MOVSB<br></code></pre></td></tr></table></figure><blockquote><ol><li>串比较指令</li></ol></blockquote><ul><li>改变标志位，通常配合REPE/PEPNE使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CMPS OPRD1, OPRD2<br>CMPSB<br>CMPSW<br></code></pre></td></tr></table></figure><blockquote><ol><li>串扫描指令</li></ol></blockquote><ul><li>将目标串(ES:DI)值与AL/AX比较，只影响标志位</li><li>通常与REPE/REPNE配合使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SCAS OPRD<br>SCASB<br>SCASW<br></code></pre></td></tr></table></figure><blockquote><ol><li>串装入指令</li></ol></blockquote><ul><li>把源串(DS:SI)装入AL或AX</li><li>自动修改SI</li><li>对标志位没有影响</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">LODS OPRD<br>LODSB<br>LODSW<br></code></pre></td></tr></table></figure><blockquote><ol><li>串存储指令</li></ol></blockquote><ul><li>把AL/AX装入目标串(ES:DI)</li><li>指令对标志位没有影响</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">STOS OPRD<br>STOSB<br>STOSW<br></code></pre></td></tr></table></figure><h4 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h4><blockquote><p>跳转指令</p></blockquote><ul><li>段内跳转，8/16位地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">JMP WORD PTR[BX]<br></code></pre></td></tr></table></figure><ul><li>段间跳转，32位地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">JMP DWORD PTR[BX]<br></code></pre></td></tr></table></figure><p>JCC只能转移8位补码范围：</p><div class="table-container"><table><thead><tr><th>FLAG/REG</th><th>相关跳转指令</th></tr></thead><tbody><tr><td>ZF</td><td>JZ/JNZ/JE/JNE</td></tr><tr><td>CF</td><td>JC/JNC</td></tr><tr><td>SF</td><td>JS/JNS</td></tr><tr><td>OF</td><td>JO/JNO</td></tr><tr><td>PF</td><td>JP/JNP/JPE/JPO</td></tr><tr><td>CX</td><td>JCXZ (CX=0,转移)</td></tr></tbody></table></div><ul><li>JA/JAE/JB/JBE</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;判断CF或CF+ZF状态，判断无符号数大小<br>JA ;大于 CF &#x3D; 0， ZF &#x3D; 0<br>JAE ;大于等于<br>JB;小于<br>JBE;小于等于<br></code></pre></td></tr></table></figure><ul><li>JG/JGE/JL/JLE</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">JG;大于跳转<br>JGE ;大于等于跳转<br>JL;小于跳转<br>JLE;小于等于跳转<br></code></pre></td></tr></table></figure><blockquote><p>循环指令</p></blockquote><ul><li>循环次数由CX指定，$CX \neq 0 $时，循环</li><li>LOOP<ul><li>$CX = CX - 1;$</li><li>$ CX \neq 0 \rightarrow LOOP$</li></ul></li><li>LOOPZ / LOOPE<ul><li>$CX = CX - 1; $</li><li>$(CX \neq 0 \&amp; ZF = 1) \rightarrow LOOPZ $</li></ul></li><li>LOOPNZ / LOOPNE</li></ul><blockquote><p>过程调用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CALL NEAR PROC;段内调用<br>CALL WORD PTR[SI]<br><br>CALL FAR PROC;段间调用<br>CALL DWORD PTR[SI]<br><br>RET;过程返回<br></code></pre></td></tr></table></figure><blockquote><p>中断指令</p></blockquote><ul><li>INT n，n为中断类型<ul><li>INT执行时将IF、TF复位</li></ul></li><li>IRET：中断返回</li></ul><blockquote><p>FLAGS设置</p></blockquote><div class="table-container"><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>STC (set C)</td><td>CF=1</td></tr><tr><td>CLC (clear C)</td><td>CF=0</td></tr><tr><td>STD</td><td>DF = 1</td></tr><tr><td>CLD</td><td>DF = 0</td></tr><tr><td>STI</td><td>IF = 1(允许可屏蔽中断)</td></tr><tr><td>CLI</td><td>IF = 0(禁止可屏蔽中断)</td></tr></tbody></table></div><blockquote><p>其它</p></blockquote><div class="table-container"><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>HLT</td><td>停止</td></tr><tr><td>NOP</td><td>空操作</td></tr></tbody></table></div><h2 id="汇编语言程序"><a href="#汇编语言程序" class="headerlink" title="汇编语言程序"></a>汇编语言程序</h2><h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><blockquote><p>变量</p></blockquote><ul><li>类型：BYTE/WORD/DWORD/QWORD/TBYTE</li></ul><p>变量的使用</p><ul><li>指令中表示取该数值</li><li>寄存器相对寻址，或基址变址相对寻址时，表示数组</li><li>出现在伪指令中，一定表示偏移</li></ul><blockquote><p>表达式</p></blockquote><ol><li>算数运算符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AX, NUM + (8 - 1) * 2<br></code></pre></td></tr></table></figure><ol><li>逻辑运算符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AL, 0ADH AND 0CCH<br></code></pre></td></tr></table></figure><ol><li>关系运算符<ul><li>EQ\ NE\ LT\ GT\ LE\ GE</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AX, 4 EQ 3;MOV AX, 0000H<br>MOV AX, 4 GT 3;MOV AX, 0FFFFH<br></code></pre></td></tr></table></figure><ol><li>取值运算符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">OFFSET;取标号或变量的偏移地址<br>SEG;取标号或变量的段地址<br>PTR;类型转换<br><br>;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;example&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>MOV SI, OFFSET DATA1<br>MOV AX, SEG DATA<br>MOV AL, BYTE PTR[SI]<br></code></pre></td></tr></table></figure><blockquote><p>数据定义</p></blockquote><ol><li>操作数定义</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">DATA1 DB 11H, 33H<br>DATA2 DW ?;未指定内容的字变量<br>STR DB &quot;hello&quot; ;定义首地址为STR的串<br>DATA3 DQ 0011223344556677H ;四字变量DATA3<br>;内存中地址由低到高存放:77H,66H,55H,44H;<br>;33H,22H,11H,00H<br>DATA4 DT 1234567890H ;定义10字节变量，高位补0<br></code></pre></td></tr></table></figure><ol><li>重复操作符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">n DUP (VALUE)<br></code></pre></td></tr></table></figure><blockquote><p>段定义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SEGMENT_NAME SEGMENT [定位类型][组合类型][&#39;类别&#39;]<br>;page: 256 Bytes<br>;paragraph: 16 Bytes<br></code></pre></td></tr></table></figure><ul><li>定位类型：<ul><li>PARA(Paragraph)</li><li>BYTE</li><li>WORD</li><li>PAGE</li></ul></li><li>组合类型<ul><li>NONE：逻辑段不组合(默认)</li><li>PUBLIC：不同程序模块PUBLIC中有相同名字的<strong>逻辑段被组合成一个逻辑段</strong></li><li>STACK：不同程序模块中用STACK声明的相同名字的<strong>堆栈段组合成一个大的堆栈段</strong></li><li>COMMON：不同程序模块用COMMON声明的同名逻辑段<strong>公用一块地址</strong>，段长为最长逻辑段长度，重叠部分内容为最后一个逻辑段内容</li><li>MEMORY：逻辑段连接时，本段定位在<strong>地址最高</strong>的地方</li><li>AT：设置段逻辑地址</li></ul></li><li>类别<ul><li>用单引号括起来的字符串，逻辑段连接时，将具有相同类别的段装入连续的内存区域</li></ul></li></ul><p>设定段寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ASSUME CS: CODE, DS: DATA, ES: EDATA, SS: STACK<br></code></pre></td></tr></table></figure><blockquote><p>过程定义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NAME PROC [NEAR&#x2F;FAR]<br>;do something<br>RET<br>NAME ENDP<br></code></pre></td></tr></table></figure><blockquote><p>宏定义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NAME MACRO [Par1, Par2]<br>;do something<br>ENDM<br><br>MY_ADD MACRO A, B, C<br>XOR A, A<br>ADD A, B<br>ADD A, C<br>ENDM<br><br>MY_ADD AX, BX, CX<br></code></pre></td></tr></table></figure><blockquote><p>模块定义</p></blockquote><ul><li>NAME 定义模块名</li><li>TITLE 定义标题名/模块名(在没有NAME的情况下)</li><li>无NAME， TITLE，以文件名为程序模块名</li><li>END [标号]: 标号为程序执行开始地址</li></ul><h4 id="BIOS-DOS"><a href="#BIOS-DOS" class="headerlink" title="BIOS/DOS"></a>BIOS/DOS</h4><p>AH &lt;= 功能号，在寄存器填入入口参数，INT n，分析出口参数</p><blockquote><p>BIOS 键盘输入(16H)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AH, 0;AL &lt;&#x3D; 字符码，AH &lt;&#x3D; 扫描码，扫描码最高位为0表示按下<br>INT 16H<br><br>MOV AH, 1;ZF &#x3D; 1:输入缓冲为空<br>INT 16H;ZF &#x3D; 0, AL &lt;&#x3D; 字符码，AH &lt;&#x3D; 扫描码<br><br>MOV AH, 2;判断Shift、Alt、Num是否被按下<br>INT 16H<br></code></pre></td></tr></table></figure><blockquote><p>BIOS 显示输出(10H)</p><p>DOS 功能调用(21H)</p></blockquote><h2 id="8086-I-O及中断"><a href="#8086-I-O及中断" class="headerlink" title="8086 I/O及中断"></a>8086 I/O及中断</h2><h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><blockquote><p>I/O的特点</p></blockquote><ol><li>复杂性</li><li>异步性：外设通常与CPU之间是异步进行操作的</li><li>实时性：实时系统要求输入输出能在时效内服务</li><li>与设备无关性：操作系统屏蔽了设备的差异</li></ol><blockquote><p>I/O的功能</p></blockquote><ul><li>数据的缓冲及缓存</li><li>信号转换</li><li>对外设进行管理</li><li>中断处理</li></ul><blockquote><p>I/O编址</p></blockquote><ol><li>统一编址(占用了内存的编址)<ul><li>内存外设信号共用，不需专门的I/O指令</li></ul></li><li>独立编址<ul><li>地址线信号由$IO/ \overline{M}$决定</li></ul></li></ol><blockquote><p>三态门输入接口 74LS<strong>244</strong></p></blockquote><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_74LS244.png" width=250></p><blockquote><p>锁存器输出接口 74LS273</p></blockquote><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_74LS273.png" width=450></p><blockquote><p>带输出允许端的输出接口 74LS<strong>374</strong>/74LS<strong>373</strong></p></blockquote><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_74LS374.png" width=700></p><ul><li>带锁存OE的D触发输出接口</li><li>74LS374：上升沿触发</li><li>74LS373：高电平锁存</li></ul><blockquote><p>74LS<strong>138</strong></p></blockquote><ul><li><p>$\overline{G_2A}, \overline{G_2B}, G $</p></li><li><p>$ A, B, C$</p></li><li><p>$ \overline{Y_0} - \overline{Y_7}$</p></li></ul><h4 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h4><blockquote><p>无条件传送</p></blockquote><p>要求外设总是处于准备好状态</p><ul><li>简单</li><li>只能用于简单外设</li></ul><blockquote><p>查询工作方式</p></blockquote><p>满足条件才传送</p><p>每满足一次条件只能进行一次数据传输</p><ul><li>简单</li><li>效率低，实时性差，速度慢</li></ul><blockquote><p>中断控制方式</p></blockquote><p>外设需要时向CPU提出请求中断</p><ul><li>效率高、实时性好、速度快</li><li>需要写相应中断程序</li></ul><blockquote><p>直接存储器存取方式(DMA)</p></blockquote><p>外设不经cpu直接与存储器发生数据交换</p><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_DMA_CTR.png" width=500></p><p>DMA工作方式</p><ul><li>周期窃取：每个DMA周期只传送一个单位数据便释放总线</li><li>数据块传送：DMA获得总线后，传送完一个数据块才释放总线</li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>执行程序时，发生随机事件，cpu中断正在执行的程序，转去处理事件；处理完后转回中断程序继续执行。这一过程称为中断。</p><blockquote><p>中断源(8088/8086系统有<strong>256</strong>个中断源)</p></blockquote><ul><li>内部中断<ul><li>异常中断：异常事件引起</li><li>软件中断：中断指令引起</li></ul></li><li>外部中断<ul><li>可屏蔽中断：INTR中断</li><li>非屏蔽中断：NMI中断，不受IF限制</li><li>外部中断响应过程</li></ul></li></ul><p><img src="http://118.24.109.65/photo_db/233_Markdown_IMG_中断.png" width=550></p><ul><li><p>中断向量表</p><ul><li>存放中断服务程序入口，每个入口占4字节，低字为中断程序段内偏移，高字为段基址</li><li>表从0000H开始，共1k，可存256个中断程序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;将中断类型为8H的中断程序 INT0 放入中断向量表<br>MOV AX, 0000H<br>MOV DS, AX<br>MOV SI, 8H * 4;中断类型x4<br>MOV [SI], OFFSET INT0;将中断程序偏移填入中断向量表<br>MOV [SI+2], SEG INT0;将中断程序段基址填入中断向量表<br></code></pre></td></tr></table></figure></li></ul><h2 id="数字接口"><a href="#数字接口" class="headerlink" title="数字接口"></a>数字接口</h2><h4 id="8259A"><a href="#8259A" class="headerlink" title="8259A"></a>8259A</h4><blockquote><p>引脚</p></blockquote><div class="table-container"><table><thead><tr><th>引脚</th><th>功能</th><th>功能</th></tr></thead><tbody><tr><td>D7 - D0</td><td>数据总线</td><td>数据传送</td></tr><tr><td>IR7 - IR0</td><td>中断请求输入</td><td>中断</td></tr><tr><td>INT</td><td>向系统发INTR信号</td><td>中断</td></tr><tr><td>$\overline{INTA }$</td><td>CPU发送的中断响应</td><td>中断</td></tr><tr><td>$\overline{CS}$</td><td>片选信号</td><td></td></tr><tr><td>$\overline{RD}, \overline{WR}$</td><td>读写信号</td><td>读写控制</td></tr><tr><td>A0</td><td>内部寄存器选择信号</td><td>读写控制</td></tr><tr><td>CAS2-CAS0</td><td>级联信号</td><td>级联</td></tr><tr><td>$\overline{SP}/\overline{EN}$</td><td>做输入：SP；0：从片<br />做输出：EN；控制总线方向</td><td>级联</td></tr></tbody></table></div><blockquote><p>寄存器</p></blockquote><div class="table-container"><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>中断请求寄存器IRR</td><td>有中断请求，相应位置1，响应后清0</td></tr><tr><td>中断屏蔽寄存器IMR</td><td>相应位置1，屏蔽该中断</td></tr><tr><td>优先级别寄存器PR</td><td></td></tr><tr><td>现行服务寄存器ISR</td><td>执行中断，置1，EOI后置0</td></tr></tbody></table></div><blockquote><p>优先级管理</p></blockquote><div class="table-container"><table><thead><tr><th>方式</th><th>描述</th></tr></thead><tbody><tr><td>完全嵌套方式(固定优先级)</td><td>IR0-IR7，优先级依次降低，只有更高优先级中断可以中断当前中断</td></tr><tr><td>特殊全嵌套</td><td>允许同级中断嵌套，其余与完全嵌套方式相同</td></tr><tr><td>优先级自动循环</td><td>中断服务后优先级自动降为最低</td></tr><tr><td>优先级特殊循环</td><td>通过OCW2确定初始最低优先级</td></tr></tbody></table></div><blockquote><p>屏蔽中断</p></blockquote><ul><li>IMR相应位置1</li><li>手动设置ISR，IMR</li></ul><blockquote><p>EOI方式</p></blockquote><div class="table-container"><table><thead><tr><th>方式</th><th>描述</th></tr></thead><tbody><tr><td>自动中断结束</td><td>在第二个$\overline{INTA}$后延，8259A将ISR置0(正在中断处理，但ISR没有相应指示)<br />设置ICW4</td></tr><tr><td>正常中断结束</td><td>用于全嵌套方式，将当前ISR中优先级最高的位复位<br />设置OCW2</td></tr><tr><td>特殊中断结束方式</td><td>用于优先级会改变的非全嵌套方式<br />OCW2指定清除ISR中的某一位</td></tr></tbody></table></div><blockquote><p>系统总线连接方式</p></blockquote><ul><li>缓冲方式：8259A通过总线驱动器和总线相连(多片8259A)</li><li>非缓冲方式：8959A直接与数据总线相连</li></ul><blockquote><p>中断触发</p></blockquote><ul><li>电平触发：一段高电平触发</li><li>边沿触发：上升沿触发</li></ul><blockquote><p>ICW</p></blockquote><ul><li>ICW1，A0=0，控制初始化</li></ul><div class="table-container"><table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>SNGL</th><th>D0</th></tr></thead><tbody><tr><td>16/32位系统中不起作用</td><td>16/32位系统中不起作用</td><td>16/32位系统中不起作用</td><td>1</td><td>0:边沿触发<br />1：电平触发</td><td>16/32位系统中不起作用</td><td>0：多片<br />1：单片</td><td>0：不需要ICW4<br />1；需要ICW4</td></tr></tbody></table></div><ul><li>ICW2， A0 = 1，中断类型初始化<ul><li>填入IR0的中断类型号需是8的倍数(低三位为0)</li></ul></li><li>ICW3，主从芯片设置</li><li>ICW4，A0 = 1，方式控制设置</li></ul><div class="table-container"><table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>SFNM</th><th>BUF</th><th>M/S</th><th>AEOI</th><th>$\mu PM$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0:全嵌套方式<br />1：特殊全嵌套方式</td><td>0：非缓冲方式<br />1：缓冲方式</td><td>0：缓冲方式(从)<br />1：缓冲方式(主)</td><td>0：正常结束中断<br />1；自动结束中断</td><td>0：8080/8085<br />1：8086/8088</td></tr></tbody></table></div><blockquote><p>初始化方法</p></blockquote><ul><li>将数据传送到AX/AL</li><li>OUT到相应地址</li></ul><blockquote><p>OCW</p></blockquote><ul><li>OCW1，A0 = 1， 中断屏蔽操作命令字<ul><li>将要屏蔽的位置1</li><li>被保存在IMR中</li></ul></li><li>OCW2， A0 = 0， EOI/设置优先级特殊循环最低优先级<ul><li>前三位</li></ul></li></ul><div class="table-container"><table><thead><tr><th>R</th><th>SL</th><th>EOI</th><th>D4</th><th>D3</th><th>L2, L1, L0</th></tr></thead><tbody><tr><td>0：固定优先级<br />1：循环优先级</td><td>0：L2~L0无效<br />1：L2~L0为最低优先级</td><td>1：中断结束</td><td>0</td><td>0</td><td>设置最低优先级别<br />特殊优先级中设置被复位的位</td></tr></tbody></table></div><ul><li>OCW3<ul><li>设置中断屏蔽方式</li><li>查询中断请求<ul><li>设置P=1，对偶地址读中断请求</li><li>最高位为1：有中断请求，最低三位为优先级最高的中断</li></ul></li><li>读8959A状态(IRR/ISR/IMR)<ul><li>对偶地址读可读IRR/ISR</li><li>对奇地址读只读IMR</li></ul></li></ul></li></ul><div class="table-container"><table><thead><tr><th>D7</th><th>ESMM</th><th>SMM</th><th>D4</th><th>D3</th><th>p</th><th>RR</th><th>RIS</th></tr></thead><tbody><tr><td>x</td><td>0：不设置中断屏蔽方式<br />1：设置中断屏蔽方式</td><td>ESMM=1：<br />0：清除特殊屏蔽<br />1：设置特殊屏蔽</td><td>0</td><td>1</td><td>0：非查询方式<br />1：查询方式</td><td>1：读</td><td>0：读IRR<br />1：读ISR</td></tr></tbody></table></div><h4 id="8253"><a href="#8253" class="headerlink" title="8253"></a>8253</h4><blockquote><p>软件控制/硬件控制</p></blockquote><ul><li>软件控制：写入计数器初值触发</li><li>硬件控制：GATE上升沿触发</li></ul><div class="table-container"><table><thead><tr><th>SC1</th><th>SC0</th><th>RW1</th><th>RW0</th><th>M2</th><th>M1</th><th>M0</th><th>BCD</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>0:计数OUT为低，结束OUT为高<br />1:计数OUT为高，结束发出一个负脉冲</td><td>1:重复计数</td><td>0：软件触发<br />1：硬件触发：GATE上升沿触发</td></tr></tbody></table></div><h4 id="8255"><a href="#8255" class="headerlink" title="8255"></a>8255</h4><blockquote><p>方式1</p></blockquote><ul><li>输入(INTE与STB公用)</li></ul><div class="table-container"><table><thead><tr><th>信号</th><th>作用</th></tr></thead><tbody><tr><td>$\overline{STB}$</td><td>选通信号(外设发给8255) A:PC4; B:PC2</td></tr><tr><td>IBF</td><td>输入缓冲满，8255输出 A:PC5; B:PC1</td></tr><tr><td>INTR</td><td>中断信号，8255输出 A:PC3; B:PC0</td></tr><tr><td>INTE</td><td>中断允许<br />A:PC4<br />B:PC2</td></tr></tbody></table></div><ul><li>输出(INTE与ACK公用)</li></ul><div class="table-container"><table><thead><tr><th>信号</th><th>作用</th></tr></thead><tbody><tr><td>$\overline{OBF}$</td><td>输出缓冲满，8255输出 A:7 B:1</td></tr><tr><td>$\overline{ACK}$</td><td>外设发出，已取走数据 A:6 B:2</td></tr><tr><td>INTR</td><td>A:3 B:0</td></tr><tr><td>INTE</td><td>A:PC6<br />B:PC2</td></tr></tbody></table></div><blockquote><p>方式2</p></blockquote><p>只有A口有，综合输入输出信号</p><h2 id="模拟量输入输出"><a href="#模拟量输入输出" class="headerlink" title="模拟量输入输出"></a>模拟量输入输出</h2><blockquote><p>D/A转换技术指标</p></blockquote><ul><li>分辨率：二进制数每变化一位，输出电压的变化</li><li>转换精度：实际输出和理论值的最大偏差</li><li>转换时间：从开始转换到与满量程差$\pm \frac{1}{2}$LSB所对应模拟量所需的时间</li></ul><blockquote><p>0832产生锯齿波</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;正向锯齿波：从最小值增长到最大值，到最大值立刻跳变为最小值<br>START:MOV DX, port<br>NEXT0:MOV AL, 0<br>NEXT1:OUT DX, AL<br>INC AL<br>CMP AL, 0<br>JNZ NEXT1<br>JMP NEXT0<br>;反向锯齿波：从最小值跳变到最大值，然后从最大值减小到最小值<br>MOV DX, port<br>MOV AL, 0<br>NEXT:OUT DX, AL<br>DEC AL<br>JMP NEXT<br>;三角波：从最小到最大，再到最小<br></code></pre></td></tr></table></figure><blockquote><p>AD转换器分类</p></blockquote><ul><li>计数型(速度慢、价格低)</li><li>双积分型：分辨率高、抗干扰好、转换速度慢</li><li>逐位反馈型：转换精度高、速度快、抗干扰性差</li></ul><blockquote><p>AD转换技术指标</p></blockquote><ul><li><p>转换精度</p></li><li><p>量化间隔：一个LSB对应的模拟量</p></li><li><p>量化误差</p></li><li>转换时间：进行一次转换所需的时间</li></ul>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dart note</title>
    <link href="/2019/04/22/Dart/"/>
    <url>/2019/04/22/Dart/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//三种定义方式</span><br><span class="hljs-built_in">bool</span> isNoble(<span class="hljs-built_in">int</span> atomicNumber)&#123;...&#125; <span class="hljs-comment">//申明返回类型</span><br>isNoble(<span class="hljs-built_in">int</span> atomicNumber)&#123;...&#125; <span class="hljs-comment">//忽略类型定义</span><br>boo isNoble(<span class="hljs-built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="hljs-keyword">null</span>;<span class="hljs-comment">//返回单行表达式结果</span><br></code></pre></td></tr></table></figure><h4 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//调用方法时可指定参数</span><br>enableFlags(bold: <span class="hljs-keyword">true</span>, hidden: <span class="hljs-keyword">false</span>);<br><span class="hljs-comment">//可选参数, device参数在函数调用时可以缺省</span><br><span class="hljs-built_in">String</span> say(<span class="hljs-built_in">String</span> from, <span class="hljs-built_in">String</span> msg, [<span class="hljs-built_in">String</span> device]) &#123;...&#125;<br><span class="hljs-comment">//默认参数值</span><br><span class="hljs-keyword">void</span> enableFlags(&#123;<span class="hljs-built_in">bool</span> bold = <span class="hljs-keyword">false</span>, <span class="hljs-built_in">bool</span> hidden = <span class="hljs-keyword">false</span>&#125;)&#123;...&#125;<br></code></pre></td></tr></table></figure><h4 id="The-main-function"><a href="#The-main-function" class="headerlink" title="The main function"></a>The main function</h4><blockquote><p>应用必须有main函数入口才能执行，main返回值为void并且有可选参数List<String></p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main()&#123;...&#125;<br><span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; arguments)&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Functions-as-first-class-object"><a href="#Functions-as-first-class-object" class="headerlink" title="Functions as first-class object"></a>Functions as first-class object</h4><blockquote><p>方法可作为参数传递给另一个方法(函数式编程)，也可以将方法赋值给一个变量</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> a = (msg) =&gt; <span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;msg.toUpperCase()&#125;</span>&#x27;</span>; <span class="hljs-comment">//方法赋值给变量</span><br><br><span class="hljs-comment">//将方法作为参数传递</span><br><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>printElement(element) &#123;<br><span class="hljs-built_in">print</span> (element);  <br>&#125;<br>list.forEach(printElement);<br></code></pre></td></tr></table></figure><h4 id="Anonymous-functions-匿名方法"><a href="#Anonymous-functions-匿名方法" class="headerlink" title="Anonymous functions(匿名方法)"></a>Anonymous functions(匿名方法)</h4><blockquote><p>匿名方法未给其命名，可直接调用或者将其赋值给其他变量</p></blockquote><h4 id="Lexical-closure-词法闭包"><a href="#Lexical-closure-词法闭包" class="headerlink" title="Lexical closure(词法闭包)"></a>Lexical closure(词法闭包)</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">Returns a function that adds [addBy] to the</span></span><br><span class="hljs-comment">/// <span class="markdown">function&#x27;s argument.</span></span><br><span class="hljs-built_in">Function</span> makeAdder(<span class="hljs-built_in">num</span> addBy) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">num</span> i) =&gt; addBy + i;<br>&#125;<br><br>main() &#123;<br>  <span class="hljs-comment">// Create a function that adds 2.</span><br>  <span class="hljs-keyword">var</span> add2 = makeAdder(<span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// Create a function that adds 4.</span><br>  <span class="hljs-keyword">var</span> add4 = makeAdder(<span class="hljs-number">4</span>);<br><br>  <span class="hljs-keyword">assert</span>(add2(<span class="hljs-number">3</span>) == <span class="hljs-number">5</span>);<br>  <span class="hljs-keyword">assert</span>(add4(<span class="hljs-number">3</span>) == <span class="hljs-number">7</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><blockquote><p>只列举独特的操作符，其余操作符与其它语言类似</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">~/</td><td style="text-align:left">除号，返回整数</td></tr><tr><td style="text-align:left">==</td><td style="text-align:left">定义在左边对象上的函数，用于判等</td></tr><tr><td style="text-align:left">as</td><td style="text-align:left">类型转换</td></tr><tr><td style="text-align:left">is</td><td style="text-align:left">如果对象是指定的类型返回 <strong>True</strong></td></tr><tr><td style="text-align:left">is!</td><td style="text-align:left">如果对象是指定的类型返回 <strong>False</strong></td></tr><tr><td style="text-align:left">??=</td><td style="text-align:left">若变量为null，则赋值，否则不变</td></tr><tr><td style="text-align:left">..</td><td style="text-align:left">级联操作符，用以访问一个方法返回值的成员变量</td></tr><tr><td style="text-align:left">condition ?? expr1 : expr2;</td><td style="text-align:left">特殊算数表达式，若condition为null则执行expr1</td></tr><tr><td style="text-align:left">?.</td><td style="text-align:left">和 <code>.</code> 类似，但是左边的操作对象不能为 null。例如 foo?.ba 如果foo 为 null 则返回 null，否则返回bar</td></tr></tbody></table></div><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">x == y;<br>x .== y;  <span class="hljs-comment">//==是定义以在左侧对象的函数</span><br>b ??= value; <span class="hljs-comment">//如果 b 是 null，则赋值给 b；如果不是 null，则 b 的值保持不变</span><br></code></pre></td></tr></table></figure><blockquote><p>级联操作符：</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#button&#x27;</span>) <span class="hljs-comment">// Get an object.</span><br>  ..text = <span class="hljs-string">&#x27;Confirm&#x27;</span>    <span class="hljs-comment">// Use its members.</span><br>  ..classes.add(<span class="hljs-string">&#x27;important&#x27;</span>)<br>  ..onClick.listen((e) =&gt; <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&#x27;Confirmed!&#x27;</span>));<br><span class="hljs-comment">//级联调用可以嵌套</span><br><span class="hljs-keyword">final</span> addressBook = (<span class="hljs-keyword">new</span> AddressBookBuilder()<br>      ..name = <span class="hljs-string">&#x27;jenny&#x27;</span><br>      ..email = <span class="hljs-string">&#x27;jenny@example.com&#x27;</span><br>      ..phone = (<span class="hljs-keyword">new</span> PhoneNumberBuilder()<br>            ..number = <span class="hljs-string">&#x27;415-555-0100&#x27;</span><br>            ..label = <span class="hljs-string">&#x27;home&#x27;</span>)<br>          .build())<br>    .build();<br><span class="hljs-comment">//无法再void上使用级联操作</span><br></code></pre></td></tr></table></figure><hr><h3 id="Control-flow-statements"><a href="#Control-flow-statements" class="headerlink" title="Control flow statements"></a>Control flow statements</h3><ul><li>for、forEach(与c++相同)</li><li>switch中可用continue跳转至一个标签</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> command = <span class="hljs-string">&#x27;CLOSED&#x27;</span>;<br><span class="hljs-keyword">switch</span> (command) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CLOSED&#x27;</span>:<br>    executeClosed();<br>    <span class="hljs-keyword">continue</span> nowClosed; <span class="hljs-comment">// Continues executing at the nowClosed label.</span><br>nowClosed:<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NOW_CLOSED&#x27;</span>:<br>    <span class="hljs-comment">// Runs for both CLOSED and NOW_CLOSED.</span><br>    executeNowClosed();<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><h4 id="Constructor-构造函数"><a href="#Constructor-构造函数" class="headerlink" title="Constructor(构造函数)"></a>Constructor(构造函数)</h4><blockquote><p>一般构造函数与语法糖</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <span class="hljs-built_in">num</span> x, y;<br>  <br>  Point(<span class="hljs-built_in">num</span> x, <span class="hljs-built_in">num</span> y)&#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//使用语法糖简化构造函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <span class="hljs-built_in">num</span> x, y;<br>  <br>  <span class="hljs-comment">// Syntactic sugar for setting x and y</span><br>  <span class="hljs-comment">// before the constructor body runs.</span><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>命名构造函数</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">num</span> x;<br>  <span class="hljs-built_in">num</span> y;<br><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br><br>  <span class="hljs-comment">// Named constructor</span><br>  Point.fromJson(<span class="hljs-built_in">Map</span> json) &#123;<br>    x = json[<span class="hljs-string">&#x27;x&#x27;</span>];<br>    y = json[<span class="hljs-string">&#x27;y&#x27;</span>];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>构造函数调用顺序</p><ol><li>initializer list（初始化参数列表）</li><li>superclass’s no-arg constructor（超类的无名构造函数）</li><li>main class’s no-arg constructor（主类的无名构造函数</li></ol><p>调用超类的构造函数</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">String</span> firstName;<br><br>  Person.fromJson(<span class="hljs-built_in">Map</span> data) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;in Person&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// Person does not have a default constructor;</span><br>  <span class="hljs-comment">// you must call super.fromJson(data).</span><br>  Employee.fromJson(<span class="hljs-built_in">Map</span> data) : <span class="hljs-keyword">super</span>.fromJson(data) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;in Employee&#x27;</span>);<br>  &#125;<br>&#125;<br><br>main() &#123;<br>  <span class="hljs-keyword">var</span> emp = <span class="hljs-keyword">new</span> Employee.fromJson(&#123;&#125;);<br><br>  <span class="hljs-comment">// Prints:</span><br>  <span class="hljs-comment">// in Person</span><br>  <span class="hljs-comment">// in Employee</span><br>  <span class="hljs-keyword">if</span> (emp <span class="hljs-keyword">is</span> Person) &#123;<br>    <span class="hljs-comment">// Type check</span><br>    emp.firstName = <span class="hljs-string">&#x27;Bob&#x27;</span>;<br>  &#125;<br>  (emp <span class="hljs-keyword">as</span> Person).firstName = <span class="hljs-string">&#x27;Bob&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>初始化列表</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//通过在参数列表后加&#x27;:&#x27;，通过逗号分隔表达式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">num</span> x;<br>  <span class="hljs-built_in">num</span> y;<br><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br><br>  <span class="hljs-comment">// Initializer list sets instance variables before</span><br>  <span class="hljs-comment">// the constructor body runs.</span><br>  Point.fromJson(<span class="hljs-built_in">Map</span> jsonMap)<br>      : x = jsonMap[<span class="hljs-string">&#x27;x&#x27;</span>],<br>        y = jsonMap[<span class="hljs-string">&#x27;y&#x27;</span>] &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;In Point.fromJson(): (<span class="hljs-subst">$x</span>, <span class="hljs-subst">$y</span>)&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>重定向构造函数</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//有时候一个构造函数会调动类中的其他构造函数。 一个重定向构造函数是没有代码的，在构造函数声明后，使用 冒号调用其他构造函数。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">num</span> x;<br>  <span class="hljs-built_in">num</span> y;<br><br>  <span class="hljs-comment">// The main constructor for this class.</span><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br><br>  <span class="hljs-comment">// Delegates to the main constructor.</span><br>  <span class="hljs-comment">//调用完此构造函数后再调用主构造函数</span><br>  Point.alongXAxis(<span class="hljs-built_in">num</span> x) : <span class="hljs-keyword">this</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>常量构造函数</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//如果你的类提供一个状态不变的对象，你可以把这些对象 定义为编译时常量。要实现这个功能，需要定义一个 const 构造函数， 并且声明所有类的变量为 final。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutablePoint</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">num</span> x;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">num</span> y;<br>  <span class="hljs-keyword">const</span> ImmutablePoint(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ImmutablePoint origin =<br>      <span class="hljs-keyword">const</span> ImmutablePoint(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Factory constructors</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程</title>
    <link href="/2019/01/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2019/01/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、软件工程概述"><a href="#一、软件工程概述" class="headerlink" title="一、软件工程概述"></a>一、软件工程概述</h2><h4 id="软件的定义"><a href="#软件的定义" class="headerlink" title="软件的定义"></a>软件的定义</h4><p>程序+数据+文档 (不准确)</p><ul><li>程序是按事先设计的功能和性能要求执行的指令序列</li><li>数据是使程序能正确处理信息的数据结构</li><li><strong>文档是与程序开发、维护、使用有关的图文资料*</strong><ol><li>提高软件开发过程能见度</li><li>记录开发过程有关信息，便于使用维护</li><li>作为开发人员阶段工作成果和结束标志</li><li>提高开发效率</li><li>作为软件运行、维护、培训资料</li><li>便于用户了解软件功能、性能</li></ol></li></ul><h4 id="软件的特点"><a href="#软件的特点" class="headerlink" title="软件的特点*"></a>软件的特点*</h4><ol><li><strong>软件是开发出来的、工程化的，并不是制造出的</strong><ul><li>充满了个人行为和个人因素</li><li>尚未实现自动化</li></ul></li></ol><hr><h4 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h4><blockquote><p><strong>软件开发维护时出现的一系列严重问题*</strong></p></blockquote><ul><li>超预算、超出计划时间</li><li>软件运行效率低</li><li>软件质量差</li><li>软件不符合要求</li><li>项目难管理，代码难维护</li><li>软件不能交付</li></ul><blockquote><p><strong>软件危机的原因</strong></p></blockquote><ul><li><strong>软件的发展速断远滞后于硬件的发展速度</strong></li><li>软件本身逻辑复杂</li><li>软件规模庞大</li><li>忽视需求分析</li><li>错误认为:软件开发=程序编写</li><li>轻视软件维护</li></ul><hr><h4 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h4><blockquote><p><strong>IEEE定义</strong></p></blockquote><ul><li>应用系统化、学科化、定量方法开发、运行维护软件</li><li>对第一点的研究</li></ul><blockquote><p><strong>目标</strong></p></blockquote><p>  在时间和预算内，按需求开发易修改、高效、可靠、可维护、适应能力强、可移动、可重用的软件。</p><blockquote><p><strong>三要素*</strong></p></blockquote><ol><li>方法</li><li>工具</li><li>过程</li></ol><hr><h2 id="二、软件过程模型"><a href="#二、软件过程模型" class="headerlink" title="二、软件过程模型"></a>二、软件过程模型</h2><h4 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h4><p>软件从系统设计、投入使用到被淘汰的全过程</p><hr><h4 id="CMMI成熟度模型标准"><a href="#CMMI成熟度模型标准" class="headerlink" title="CMMI成熟度模型标准"></a>CMMI成熟度模型标准</h4><div class="table-container"><table><thead><tr><th style="text-align:center">级别</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1.初始级</td><td style="text-align:center">有能力的人和个人英雄主义</td></tr><tr><td style="text-align:center">2.可重复级</td><td style="text-align:center">基本的项目管理</td></tr><tr><td style="text-align:center">3.已定义级</td><td style="text-align:center">过程标准化</td></tr><tr><td style="text-align:center">4.量化管理级</td><td style="text-align:center">量化管理</td></tr><tr><td style="text-align:center">5.优化级</td><td style="text-align:center">持续的过程改进</td></tr></tbody></table></div><hr><h4 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h4><blockquote><p><strong>瀑布模型*</strong></p></blockquote><ul><li>开发过程与软件生命周期一致，也被称为<strong>经典的生命周期模型</strong></li><li>以<strong>文档驱动</strong></li></ul><p><strong>特点*</strong>：</p><ol><li>阶段有顺序性与依赖性<ul><li>前一阶段的工作完成，后一阶段才能开始</li><li>前一阶段的输出文档是后一阶段的输入文档</li></ul></li><li>推迟实现的观点<ul><li>编码前设置系统分析设计阶段，主要考虑系统的逻辑模型，不考虑物理实现</li><li>尽可能推迟物理实现</li></ul></li><li><p>质量保证的观点</p><ul><li>每个阶段必须完成规定文档</li><li>每个阶段结束前要对所有文档评审</li></ul><pre><code class=" mermaid">graph LRA[可行性研究] --&gt; B[需求分析]B --&gt; C[概要设计] C --&gt; D[详细设计] D --&gt; E[实现] E --&gt; F[组装测试] F --&gt; G[验收测试] G --&gt; H[使用维护] H --&gt; I[退役]</code></pre></li></ol><p><strong>缺点*</strong> </p><ul><li>不灵活，下一阶段开始前，当前阶段需要固定</li><li>严格文档驱动，增大工作量</li><li>线性开发，只有等到过程末期才能见到开发成果，增大开发风险</li><li>早期需投入大量成本，难以应对客户需求变更</li></ul><p><strong>适用场合*</strong></p><p>需求明确且在将来没有太大改变的情况</p><blockquote><p> <strong>演化模型</strong></p></blockquote><p>首先实现软件最核心，最重要的功能</p><p><strong>适用场合</strong></p><ol><li>需求不明确或需求经常变更</li><li>适用于中小型系统</li></ol><p><strong>分类</strong></p><ul><li><blockquote><p>快速原型模型(原型模型)*</p></blockquote><p>思路：先开发原型，实现最主要的功能，征求用户意见并完善，在确定使用该原型后，开始完整的开发。</p><p>优点：</p><ol><li>软件、文档能明确符合用户需求</li><li>快速</li><li>可以在原型基础上开发或者抛弃</li></ol><p>缺点：为快速建立原型，设计者可能不会用长远的眼光和维护的角度考虑系统</p></li><li><blockquote><p>并行开发模型</p></blockquote><ul><li>所有任务同时存在，又处于不同的状态</li></ul></li></ul><blockquote><p><strong>增量过程模型</strong></p></blockquote><ul><li><p>增量模型*</p><ul><li>在前面增量基础上开发后面增量</li><li>迭代思想</li><li>第一个增量通常是核心产品</li></ul></li><li><p>RAD：快速开发</p></li><li><p>螺旋模型*</p><p>优点：</p><ul><li>强调风险管理</li><li>支持需求动态变化</li><li>评估更加准确</li></ul><p>缺点：</p><ul><li>若每次迭代效率不高，会影响成本及效率</li><li>团队需要较高的知识水平</li><li>只适用于大型软件开发</li></ul></li></ul><ul><li><blockquote><p><strong>增量模型和螺旋模型的异同*</strong> </p></blockquote><p>相同：都是现代式迭代方式</p><p>不同</p><ol><li>两者迭代层次不同，增量模型是活动级迭代，螺旋模型是过程级迭代</li><li>需求分析时间不同，增量先做总体需求分析，再编码测试，逐个增量；螺旋模型在开发周期内采用瀑布模型</li><li>交付软件方式不同，增量每次的增量开发都是在上一次增量的基础上提交新的一部分软件；螺旋每次提交新的完整的系统</li><li>风险管理不同，增量通过扩充技术与经常客户反馈；螺旋直接植入风险分析</li></ol></li></ul><hr><h2 id="三、需求分析"><a href="#三、需求分析" class="headerlink" title="三、需求分析"></a>三、需求分析</h2><h4 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h4><p>软件需求的来源及收集软件需求的方法</p><hr><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>确定系统必须有的功能和性能，系统要求的运行环境，并预测系统发展前景。</p><p>核心在于<strong>建立分析模型</strong>(DD、DFD等)</p><ul><li>功能性需求：系统应该做什么</li><li>非功能性需求：必须遵守的标准与约束(性能等)</li></ul><p><strong>步骤*</strong>：</p><ol><li>需求获取</li><li>需求提炼</li><li>需求描述(撰写需求规格说明书)</li><li>需求验证</li></ol><p>任务：</p><ol><li>建立分析模型</li><li>编写需求说明</li></ol><hr><h4 id="数据字典-Data-Dictionary-DD"><a href="#数据字典-Data-Dictionary-DD" class="headerlink" title="数据字典(Data Dictionary DD)*"></a>数据字典(Data Dictionary DD)*</h4><blockquote><p>数据项</p></blockquote><ul><li>数据项名</li><li>类型</li><li>长度</li><li>取值范围</li></ul><blockquote><p> 数据流</p></blockquote><ul><li>数据流名</li><li>简介其作用</li><li>数据流来源</li><li>数据流去向</li><li>数据流组成</li></ul><blockquote><p> 数据文件或数据库</p></blockquote><ul><li>数据文件名</li><li>简述存放数据</li><li>输入数据</li><li>输出数据</li><li>数据存放的数据结构</li><li>存取频率</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">表示</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">定义为</td></tr><tr><td style="text-align:center">A+B</td><td style="text-align:center">与</td></tr><tr><td style="text-align:center">[A\</td><td style="text-align:center">B]</td><td>或</td></tr><tr><td style="text-align:center">{A}</td><td style="text-align:center">X由多个A组成</td></tr><tr><td style="text-align:center">(A)</td><td style="text-align:center">可选</td></tr><tr><td style="text-align:center">m{A}n</td><td style="text-align:center">A至少出现m次，至多出现n次</td></tr><tr><td style="text-align:center">“A”</td><td style="text-align:center">基本数据元素，默认值</td></tr><tr><td style="text-align:center">a…b</td><td style="text-align:center">取值区间</td></tr></tbody></table></div><hr><h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><p><img src="e-r_.png" width=400px></p><ul><li>实体(矩形)</li><li>属性(椭圆)(<strong>主键</strong>：属性名下打下划线)</li><li>关系(菱形)</li></ul><p><strong>关系模式</strong>：实体名(属性)</p><p><img src="E-R.png" width=400px></p><hr><h4 id="数据流图-Data-Flow-Diagram-DFD"><a href="#数据流图-Data-Flow-Diagram-DFD" class="headerlink" title="数据流图(Data Flow Diagram DFD)"></a>数据流图(Data Flow Diagram DFD)</h4><p><img src="dfd.png" widht=400px></p><ul><li><p>加工框应有编号</p></li><li><p>分解前后的数据流一致</p></li><li><p>顶层：只包含一个加工</p></li><li><p>底层：加工不能再分解(最好不要超过7个)</p></li><li><p>父子平衡</p></li><li><p>加工之间可有有多股数据流</p></li><li><p>除从文件流入、流出的数据流，其它数据流须有名字</p></li></ul><hr><h4 id="状态-变迁图-Status-Transfer-Diagram-STD"><a href="#状态-变迁图-Status-Transfer-Diagram-STD" class="headerlink" title="状态-变迁图(Status Transfer Diagram STD)"></a>状态-变迁图(Status Transfer Diagram STD)</h4><p><strong>状态</strong>：矩形；<strong>转换</strong>：有向箭头；<strong>规则表达式</strong>：转换条件</p><p>类似有限状态自动机</p><p>Petri网</p><hr><h4 id="加工说明-PSPEC"><a href="#加工说明-PSPEC" class="headerlink" title="加工说明(PSPEC)"></a>加工说明(PSPEC)</h4><p> 判定树</p><p> 判定表(条件+执行动作)</p><hr><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><blockquote><p><strong>静态模型</strong></p></blockquote><ul><li><blockquote><p>用例图</p></blockquote><p>用例图是显示一组用例、参与者以及它们之间关系的图</p><p><strong>内容</strong>：</p><ul><li><p>参与者</p><ul><li>系统<strong>外部</strong>的人或物，以某种方式参与了系统执行</li><li>参与者在不同的组成部分可能扮演不同角色</li><li><strong>外部、与系统交互</strong>(可能隐含时间、温度等)</li><li><img src="Actor.png" width="50px"></li></ul></li><li><p>用例</p><ul><li>执行的操作</li><li>考虑每个参与者是如何使用系统的</li><li><img src="用例.png" style="width:50px"></li></ul></li><li><p>泛化、扩展、包含关系</p><ul><li><p>泛化：同一业务的不同技术实现</p><p><img src="泛化.png" width=200px></p></li><li><p>包含：基本用例会用到包含用例</p><ul><li>包含用例应是可重用的</li></ul></li><li><p>扩展：对基础用例的扩展</p></li></ul></li></ul><p><img src="用例图实例.png" width=400px></p><ul><li><blockquote><p>业务场景图：</p></blockquote></li></ul><p>​    <img src="业务场景图_借书.png" width=400px></p></li><li><blockquote><p>类图</p></blockquote><p><img src="类图.png" width=400px></p></li><li><blockquote><p>对象图</p></blockquote></li><li><blockquote><p>组件图</p></blockquote></li><li><blockquote><p>部署图</p></blockquote></li></ul><blockquote><p><strong>动态模型</strong></p></blockquote><ul><li><blockquote><p>顺序图</p></blockquote><p><img src="顺序图.png" width=400px></p></li></ul><hr><h2 id="四、软件设计工程"><a href="#四、软件设计工程" class="headerlink" title="四、软件设计工程"></a>四、软件设计工程</h2><h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构*"></a>软件架构*</h4><p>开发架构、逻辑架构、数据架构、运行架构、物理架构</p><blockquote><ol><li>开发架构(程序)</li></ol></blockquote><ul><li>程序单元<ul><li>源文件、配置文件</li><li>程序库、框架</li><li>目标单元</li></ul></li><li>程序单元组织<ul><li>项目划分</li><li>项目目录结构</li><li>编译依赖关系</li></ul></li></ul><blockquote><ol><li>逻辑架构(职责)</li></ol></blockquote><ul><li>职责划分<ul><li>逻辑层</li><li>子系统、模块</li><li>关键类</li></ul></li><li>职责协作<ul><li>接口</li><li>协作关系</li></ul></li></ul><blockquote><ol><li>数据架构</li></ol></blockquote><ul><li>数据单元<ul><li>文件</li><li>数据库</li></ul></li><li>存储格式</li></ul><blockquote><ol><li>运行架构(控制流)</li></ol></blockquote><ul><li>控制流<ul><li>进程、线程</li><li>中断</li></ul></li><li>控制流组织<ul><li>启动与停机</li><li>控制通信</li><li>加锁与同步</li></ul></li></ul><blockquote><ol><li>物理架构</li></ol></blockquote><ul><li>物理节点<ul><li>PC、服务器</li><li>物理硬件</li><li>软件安装、部署</li><li>系统软件选型</li></ul></li><li>物理节点拓扑<ul><li>连接方式、拓扑结构</li><li>物理层</li></ul></li></ul><hr><h4 id="体系结构设计原则"><a href="#体系结构设计原则" class="headerlink" title="体系结构设计原则"></a>体系结构设计原则</h4><ul><li>合适性</li><li>结构稳定性</li><li>可扩展性</li><li>可复用性</li></ul><hr><h4 id="模块设计原则"><a href="#模块设计原则" class="headerlink" title="模块设计原则"></a>模块设计原则</h4><ul><li><p>信息隐藏</p></li><li><p>高内聚</p><blockquote><p>内聚(Cohesion)：模块内部各成分间的关联程度</p></blockquote></li><li><p>低耦合</p><blockquote><p>耦合(Coupling)：模块间的依赖程度</p></blockquote></li></ul><hr><h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚*"></a>内聚*</h4><div class="table-container"><table><thead><tr><th>内聚</th><th>特点</th><th>强度</th></tr></thead><tbody><tr><td>巧合内聚</td><td>模块内句段没有什么联系</td><td>弱</td></tr><tr><td>逻辑内聚</td><td>将几种功能组合，通过参数判断执行哪一个功能</td><td></td></tr><tr><td>时间内聚</td><td>模块中包含了需同一时间执行的多个任务</td><td></td></tr><tr><td>过程内聚</td><td>模块各部分相关，且必须按照指定顺序执行</td><td></td></tr><tr><td>通信内聚</td><td>模块中各部分有同一输入数据或产生同一输出数据</td><td></td></tr><tr><td>顺序内聚</td><td>模块各部分与同一个功能相关，前一个部分的输出是后一个部分的输入数据</td><td></td></tr><tr><td>功能内聚</td><td>模块内的各个部分共同完成一个单一功能</td><td>强</td></tr></tbody></table></div><hr><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合*"></a>耦合*</h4><div class="table-container"><table><thead><tr><th>耦合</th><th>特点</th><th>强度</th></tr></thead><tbody><tr><td>内容耦合</td><td>一个模块对另一个模块进行直接修改或引用或两个模块共享一部分代码</td><td>高</td></tr><tr><td>公共耦合</td><td>一组模块公用数据环境(全局变量在多个模块间使用)</td><td></td></tr><tr><td>外部耦合</td><td>模块间通过软件之外的环境连接</td><td></td></tr><tr><td>控制耦合</td><td>一个模块传送给另一个模块的信息中包含了控制信息</td><td></td></tr><tr><td>标记耦合</td><td>两个模块通过参数表传递一个数据结构的一部分</td><td></td></tr><tr><td>数据耦合</td><td>两个模块仅通过模块参数交换信息，且交换信息全为简单数据</td><td></td></tr><tr><td>非直接耦合</td><td>两个模块间没有直接关系</td><td>无</td></tr></tbody></table></div><hr><h4 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h4><p>调用其它模块的数目</p><hr><h4 id="扇入"><a href="#扇入" class="headerlink" title="扇入"></a>扇入</h4><p>被其它模块调用的数目</p><hr><h4 id="结构化程序"><a href="#结构化程序" class="headerlink" title="结构化程序*"></a>结构化程序*</h4><blockquote><p> 程序代码仅仅通过<strong>顺序、选择、循环</strong>三种结构连接，且每个代码块只有<strong>一个入口和一个出口</strong></p></blockquote><hr><h4 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图*"></a>程序流程图*</h4><p>缺点*：</p><ol><li>容易使程序员过早考虑控制流程而不是全局结构</li><li>箭头代表控制流，可以随意转移控制，可能使程序过于混乱</li><li>表示数据结构方面存在不足</li></ol><p>为使流程图描述<strong>结构化程序</strong>，必须只能用下面五中基本控制结构</p><p><img src="程序流程图.png" style="width:400px"></p><hr><h4 id="NS图-盒图"><a href="#NS图-盒图" class="headerlink" title="NS图(盒图)"></a>NS图(盒图)</h4><p><img src="NS图.png" style="width:400px"></p><p><img src="NS实例图.png" style="width:400px"></p><hr><h4 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h4><p>必定是<strong>结构化</strong>的</p><p><img src="PAD图.png" style="width:400px"></p><p><img src="PAD实例图.png" style="width:400px"></p><hr><h4 id="模块化和软件成本"><a href="#模块化和软件成本" class="headerlink" title="模块化和软件成本*"></a>模块化和软件成本*</h4><p><img src="module.png" widht=400px></p><hr><h4 id="设计性语言PDL-Program-Design-Laguage"><a href="#设计性语言PDL-Program-Design-Laguage" class="headerlink" title="设计性语言PDL(Program Design Laguage)"></a>设计性语言PDL(Program Design Laguage)</h4><p>伪代码</p><hr><h2 id="五、软件生产率与工作量的度量"><a href="#五、软件生产率与工作量的度量" class="headerlink" title="五、软件生产率与工作量的度量"></a>五、软件生产率与工作量的度量</h2><h4 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h4><p>定义：对软件产品、开发过程、资源简单属性的<strong>定量</strong>描述</p><hr><h4 id="为什么需要软件度量"><a href="#为什么需要软件度量" class="headerlink" title="为什么需要软件度量"></a>为什么需要软件度量</h4><p>客观准确的项目估算，是项目成功的基础</p><hr><h4 id="项目估算"><a href="#项目估算" class="headerlink" title="项目估算"></a>项目估算</h4><ol><li>项目规模</li><li>项目工作量</li><li>项目资源</li><li>项目时间</li><li>项目成本</li></ol><hr><h4 id="面向规模度量-直接度量"><a href="#面向规模度量-直接度量" class="headerlink" title="面向规模度量(直接度量)*"></a>面向规模度量(直接度量)*</h4><ul><li>生产率 PM = L / E ( L:代码总量 E:软件工作量(人月) )</li><li>每千行代码平均成本： CKL = S / L (S:项目总开销)</li><li>文档代码比：DI = Pd / L</li><li><p>代码出错率：EQRI = Ne / L</p><p>优点：简单直观</p><p>缺点：</p></li><li><p>只适合于过程式设计语言</p></li><li>初期难以估算代码行数</li></ul><hr><h4 id="功能点分析法"><a href="#功能点分析法" class="headerlink" title="功能点分析法*"></a>功能点分析法*</h4><ul><li><p>不能直接度量</p></li><li><p>初期即可估算</p></li><li><p>功能点计算依赖于经验公式，主观因素较多</p></li><li><p>与语言无关</p></li><li><p>没有涉及算法复杂度</p></li><li><p>FP = (0.65 + 0.01  x $\sum F_i$)  x CT</p><ul><li>CT：5个信息量的加权和</li><li>$F_i$：14个因素的复杂性调节值(影响越大，数值越大)</li><li>0.65 0.01皆为经验常数</li></ul></li><li><p>CT的计算</p><blockquote><ul><li>用户输入数×加权因子(简单=3,平均=4,复杂=5)</li><li>用户输出数×加权因子(简单=3,平均=4,复杂=5)</li><li>用户查询数×加权因子(简单=3,平均=4,复杂=5)</li><li>文件数×加权因子(简单=3,平均=4,复杂=5)</li><li>外部界面数×加权因子(简单=3,平均=4,复杂=5)</li></ul><p>CT = 上述计算值的总和</p></blockquote></li><li><p>PM：平均生产率(代码行/人月)</p></li><li><p>C：每个人月的成本</p></li></ul><hr><h2 id="六、软件测试策略"><a href="#六、软件测试策略" class="headerlink" title="六、软件测试策略"></a>六、软件测试策略</h2><h4 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷*"></a>软件缺陷*</h4><blockquote><ol><li>软件未实现要求功能</li><li>软件出现了指明不能出现的错误</li><li>软件实现了产品说明书未提到的功能</li><li>软件未实现产品说明书未明确提到但应该实现的目标</li><li>软件难以理解、不易使用、运行缓慢</li></ol><p>满足一条就是发生了一个软件缺陷</p></blockquote><h4 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h4><blockquote><p>在特定条件下对软件观察或记录结果，对系统或组件的某些方面进行评估的过程</p></blockquote><h4 id="软件测试目标"><a href="#软件测试目标" class="headerlink" title="软件测试目标*"></a>软件测试目标*</h4><blockquote><ol><li>确认系统满足预期使用和用户需要</li><li>确认解决了需解决的问题</li><li>为测试的过程建立责任和可解释性</li><li>发现软件系统的异常</li><li>提供软件系统的性能的评估</li><li>为管理人员提供真实信息</li><li>鉴别程序在功能方面的异常聚集处</li></ol></blockquote><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例*"></a>测试用例*</h4><blockquote><p>是测试输入、执行条件、预期结果的集合</p></blockquote><h4 id="单元测试-模块测试"><a href="#单元测试-模块测试" class="headerlink" title="单元测试(模块测试)*"></a>单元测试(模块测试)*</h4><blockquote><p>验证模块是否按照详细设计的规格进行正确运行</p><ol><li>模块接口：模块输入/输出是否正确(个数、次序、类型)</li><li>局部数据结构</li><li>边界条件</li><li>所有独立路径：确保所有语句至少执行一遍</li><li>所有错误处理路径</li></ol><h5 id="驱动模块-：调用被测模块，传数据给被测模块并接受返回结果"><a href="#驱动模块-：调用被测模块，传数据给被测模块并接受返回结果" class="headerlink" title="驱动模块* ：调用被测模块，传数据给被测模块并接受返回结果"></a>驱动模块* ：调用被测模块，传数据给被测模块并接受返回结果</h5><h5 id="桩模块-：代替被测模块调用的模块-隔离缺陷"><a href="#桩模块-：代替被测模块调用的模块-隔离缺陷" class="headerlink" title="桩模块*：代替被测模块调用的模块(隔离缺陷)"></a>桩模块*：代替被测模块调用的模块(隔离缺陷)</h5><pre><code class=" mermaid">graph LRA[驱动模块]B[被测模块]C[桩模块]D[桩模块]A--&gt;BB--&gt;CB--&gt;D</code></pre></blockquote><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试*"></a>集成测试*</h4><blockquote><p>测试多模块间的协同工作</p><ol><li><p>非增量式集成：将所有经过单元测试的模块组合，对整体进行测试</p></li><li><p>增量式集成：根据程序结构图，按一定次序选一个(或一组)尚未测试的模块集成到已测试好的模块中进行测试</p><ol><li><p>自顶向下集成：从主控模块开始，按照程序结构图将模块按深度优先或广度优先的方式逐个集成到结构中并测试(要打桩)</p><ul><li>较早验证主程序功能</li><li>缺陷隔离较好</li><li>可以较早验证主要的控制判断点</li><li>桩模块编写费时</li></ul></li><li><p>自底向上集成</p><blockquote><p>将低层模块组合成能实现特定功能的簇，为每个簇写驱动程序并测试</p><p>用上层模块替换驱动程序</p><p>每次对新的簇测试后都要进行回顾测试</p></blockquote></li></ol></li></ol></blockquote><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试*"></a>系统测试*</h4><blockquote><p>测试整个系统是否满足<strong>规格说明</strong></p><ul><li><p>功能测试</p><ul><li>运行软件所有功能，验证系统有无严重错误</li></ul></li><li><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试*"></a>压力测试*</h4><ul><li><h5 id="采用比平常高一个数量级的反常测试用例来测试"><a href="#采用比平常高一个数量级的反常测试用例来测试" class="headerlink" title="采用比平常高一个数量级的反常测试用例来测试*"></a>采用比平常高一个数量级的反常测试用例来测试*</h5></li><li><p>系统运行正常至发生故障时，可以运行到何种情况</p></li></ul></li><li><p>性能测试</p><ul><li>响应时间(发出请求到收到反馈的时间)</li><li>吞吐量、辅助存储区大小、处理精度</li></ul></li><li><p>界面测试</p></li><li><p>安全性测试</p><ul><li>系统安全、保密性措施是否完善</li></ul></li><li><p>恢复测试</p><ul><li>排除故障后系统是否还能正常工作</li></ul></li><li><p>配置测试、兼容性测试、本地化测试、文档测试、易用性测试</p></li></ul></blockquote><h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试*"></a>验收测试*</h4><blockquote><h5 id="从用户角度来看系统是否满足合同定义要求，以及产品是否能符合业务上的需要"><a href="#从用户角度来看系统是否满足合同定义要求，以及产品是否能符合业务上的需要" class="headerlink" title="从用户角度来看系统是否满足合同定义要求，以及产品是否能符合业务上的需要*"></a>从用户角度来看系统是否满足合同定义要求，以及产品是否能符合业务上的需要*</h5><ul><li>用户为主、软件开发人员、QA(质量保证)人员也要参加</li></ul></blockquote><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试*"></a>回归测试*</h4><blockquote><p>有选择的重新测试系统或其组件，验证软件的修改是否导致不希望出现的影响</p></blockquote><h4 id="alpha-测试和-beta-测试"><a href="#alpha-测试和-beta-测试" class="headerlink" title="$\alpha$测试和$\beta$测试*"></a>$\alpha$测试和$\beta$测试*</h4><blockquote><p>$\alpha$测试：用户在<strong>开发环境</strong>下进行的测试</p><p>$\beta $测试：多用户在<strong>实际环境</strong>下的测试，并返回相关错误给开发者</p></blockquote><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试*"></a>黑盒测试*</h4><blockquote><p>忽略内部结构，只关注输入输出；功能、数据驱动</p><ul><li>等价类划分<ul><li>每个等价类中的数据对于揭露程序错误都是等效的</li><li>有效等价类：合理的、有意义的输入数据构成的集合</li><li>无效等价类：不合理、无意义输入构成的集合</li><li>新测试用例尽量多的覆盖未被覆盖的有效等价类的数据</li><li>设计新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复直至所有无效等价类都被覆盖</li></ul></li><li>边界值分析<ul><li>选取正好等于、刚刚大于、刚刚小于边界值的数据作为测试</li></ul></li></ul></blockquote><h4 id="白盒测试-逻辑结构驱动"><a href="#白盒测试-逻辑结构驱动" class="headerlink" title="白盒测试(逻辑结构驱动)*"></a>白盒测试(逻辑结构驱动)*</h4><blockquote><p>考虑内部组件机制，对所有逻辑路径进行测试</p><ul><li>所有独立路径至少测一次</li><li>所有逻辑判断的结果至少测一次</li><li>循环的边界和界内运行</li><li>内部数据结构有效性</li></ul><p>语句覆盖：<strong>每个语句</strong>至少执行一次</p><p>分支(判定)覆盖：<strong>每个判断的分支</strong>至少执行一次</p><p>条件覆盖：所有判断的<strong>每个条件的所有可能</strong>至少出现一次</p><p>判定/条件覆盖：</p><blockquote><p><strong>每个判断分支，所有判断的每个条件可能</strong>都至少出现一次</p><p>判定/条件覆盖 = 判定覆盖 + 条件覆盖</p></blockquote><p>条件组合覆盖：<strong>每个判定的所有组合</strong>都至少出现一次</p><blockquote><p>不能保证路径覆盖，满足条件组合覆盖就一定满足判定覆盖、条件覆盖、判定/条件覆盖</p></blockquote><p>路径覆盖：<strong>所有路径</strong>都至少被经过一次</p></blockquote><h4 id="测试评估标准"><a href="#测试评估标准" class="headerlink" title="测试评估标准"></a>测试评估标准</h4><blockquote><ul><li><h5 id="覆盖率-：测试集合占测试需求集合之比"><a href="#覆盖率-：测试集合占测试需求集合之比" class="headerlink" title="覆盖率*：测试集合占测试需求集合之比"></a>覆盖率*：测试集合占测试需求集合之比</h5></li><li><p>故障插入：人为插入故障到程序，一部分故障有可能不会暴露</p></li><li><p>变异分值</p></li></ul></blockquote><h4 id="静态分析方法"><a href="#静态分析方法" class="headerlink" title="静态分析方法*"></a>静态分析方法*</h4><blockquote><p>不运行程序，通过检查、阅读发现代码错误评估代码质量</p><ul><li>检查需求<ul><li>完整性：是否完整描述一个功能</li><li>正确性：是否正确反应客户要求</li><li>可行性</li><li>必要性</li><li>无二义性</li><li>可验证性</li><li>需求规格的说明标准<ul><li>完整性：是否包含所有需求</li><li>一致性：重复？相互矛盾</li></ul></li></ul></li><li>检查设计<ul><li>在编码前进行</li><li>检查功能设计，消除歧义</li></ul></li><li>检查代码</li></ul></blockquote><hr><h2 id="七、软件维护"><a href="#七、软件维护" class="headerlink" title="七、软件维护"></a>七、软件维护</h2><h4 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h4><blockquote><h5 id="ISO-IEC定义-：软件产品出现问题或需要改进，对其代码及相关文档的修改，目的是对现有的软件产品进行修改的同时保证其完整性"><a href="#ISO-IEC定义-：软件产品出现问题或需要改进，对其代码及相关文档的修改，目的是对现有的软件产品进行修改的同时保证其完整性" class="headerlink" title="ISO-IEC定义*：软件产品出现问题或需要改进，对其代码及相关文档的修改，目的是对现有的软件产品进行修改的同时保证其完整性"></a>ISO-IEC定义*：软件产品出现问题或需要改进，对其代码及相关文档的修改，目的是对现有的软件产品进行修改的同时保证其完整性</h5><p>目的：</p><ol><li>改正程序的错误缺陷</li><li>改进设计以适应新的软硬件环境</li><li>增加新的应用范围</li></ol></blockquote><h4 id="软件维护必要性"><a href="#软件维护必要性" class="headerlink" title="软件维护必要性*"></a>软件维护必要性*</h4><blockquote><ol><li>能改正错误</li><li>能改善设计</li><li>能实现软件的改进</li><li>能与其他系统交互</li><li>能为为使用不同的硬件、软件、系统新性能及通信设备对软件进行改进</li><li>能完成遗留程序移植</li><li>软件退出使用</li></ol></blockquote><h4 id="完善性维护"><a href="#完善性维护" class="headerlink" title="完善性维护*"></a>完善性维护*</h4><blockquote><p>增加新功能、增强性能、改进效率，提高可维护性</p><ul><li>占比最大</li></ul></blockquote><h4 id="改正性维护"><a href="#改正性维护" class="headerlink" title="改正性维护*"></a>改正性维护*</h4><blockquote><p>识别纠正软件错误</p></blockquote><h4 id="适应性维护"><a href="#适应性维护" class="headerlink" title="适应性维护*"></a>适应性维护*</h4><blockquote><p>因外部环境与数据环境发生变化而修改软件</p><ul><li>配置管理时，把环境因素的可变化考虑在内</li><li>将与外部环境相关的部分归到特定的程序模块中</li><li>使用内部程序列表、外部文件，以及处理的例行程序包</li></ul></blockquote><h4 id="预防性维护"><a href="#预防性维护" class="headerlink" title="预防性维护*"></a>预防性维护*</h4><blockquote><p>采用先进的软件工程方法对需要维护的软件或其部分进行重新进行设计、编制、测试</p></blockquote><h4 id="软件维护困难性"><a href="#软件维护困难性" class="headerlink" title="软件维护困难性*"></a>软件维护困难性*</h4><blockquote><ol><li>配置管理不到位，软件的改动没有被标记</li><li>人员变动产生的影响</li><li>维护人员大多不是编写代码的人员</li><li>错误大多只有在运行中发现</li></ol></blockquote><h4 id="软件再工程"><a href="#软件再工程" class="headerlink" title="软件再工程"></a>软件再工程</h4><blockquote><p>对现有的软件进行审查和改造，对其重构</p></blockquote><h4 id="正向工程"><a href="#正向工程" class="headerlink" title="正向工程"></a>正向工程</h4><blockquote><p>通过现代软件工程概念、原理、技术方法，重新开发现有的某些系统</p></blockquote><h4 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h4><blockquote><p>分析目标系统，识别系统构件及其交互关系，通过高层抽象和其它形式来展现目标系统的过程</p></blockquote><hr><h2 id="八、项目管理"><a href="#八、项目管理" class="headerlink" title="八、项目管理"></a>八、项目管理</h2><h4 id="软件项目管理要素"><a href="#软件项目管理要素" class="headerlink" title="软件项目管理要素*"></a>软件项目管理要素*</h4><p> 管理方法在软件开发与维护中的应用，以保证整个过程是系统的、有原则的、可量化的</p><blockquote><h5 id="人员-People"><a href="#人员-People" class="headerlink" title="人员(People)*"></a>人员(People)*</h5></blockquote><p>  人力资源管理成熟度模型PCMM</p><p>  初始级-&gt;重复级-&gt;定义级-&gt;定量级-&gt;优化级(与CMMI成熟度模型排序一样)</p><blockquote><h5 id="产品-Product"><a href="#产品-Product" class="headerlink" title="产品(Product)*"></a>产品(Product)*</h5><h5 id="过程-Process"><a href="#过程-Process" class="headerlink" title="过程(Process)*"></a>过程(Process)*</h5></blockquote><p>  选择合适的过程模型</p><blockquote><h5 id="项目-Project"><a href="#项目-Project" class="headerlink" title="项目(Project)*"></a>项目(Project)*</h5></blockquote><p>  将人力和非人力资源集合在一个临时性的组织中实现一个规定的目标</p><ul><li>有明确的目标</li><li>有生命周期</li><li>项目任务可分解</li><li>有明确的客户</li><li>需要多种资源</li><li>有不确定性因素</li></ul><hr><h4 id="团队组织形式"><a href="#团队组织形式" class="headerlink" title="团队组织形式*"></a>团队组织形式*</h4><blockquote><p>民主分权制(DD)</p></blockquote><p>  软件工程团队没有永久的领导者，存在问题的方法和决策都是小组共识</p><ul><li>较低模块化，需较高的通信量时宜采用</li><li>较高士气</li><li>横向沟通</li></ul><blockquote><p>有控制的分权制(CD)</p></blockquote><p> 有明确的领导分工，解决问题由团队活动，解决方案由组长分配到各个小组实施</p><ul><li>较大项目宜采用</li><li>高度模块化宜采用(交流少)</li><li>横向纵向沟通都会发生</li></ul><blockquote><p>有控制的集中制(CC)</p></blockquote><p> 团队内问题的解决协调由一个团队领导者执行</p><ul><li>较大项目宜采用</li><li>高度模块化宜采用</li><li>纵向沟通</li></ul><hr><h4 id="虚拟团队"><a href="#虚拟团队" class="headerlink" title="虚拟团队*"></a>虚拟团队*</h4><p>地理上分散的团队，三个主要方面：目标、人、联系，其中目标是虚拟团队在一起的原因</p><blockquote><p>优势</p></blockquote><p>提高生产力，扩大市场机遇，进行知识转移</p><blockquote><p>缺点</p></blockquote><p>沟通不足，领导不力，成员不称职</p><h2 id="九、Java"><a href="#九、Java" class="headerlink" title="九、Java"></a>九、Java</h2><blockquote><p>JDK每个目录文件功能</p></blockquote><p>bin：存放Java启动命令及其他开发工具命令，该目录应保存到PATH变量中</p><p>db：开源的java数据库</p><p>include：c语言头文件，支持用Java本地接口和Java虚拟机接口实现本机代码编程</p><p>jre：java.home指向的目录</p><blockquote><p> import语句规定</p><p>构造方法要求</p></blockquote><p>类似C++</p><blockquote><p>运算符优先级</p></blockquote><p><img src="java.png" widht=400px></p><blockquote><p>Switch语句</p></blockquote><p>和C一样</p><blockquote><p>变量又称为属性</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2019/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2019/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h2 id="一、计算机"><a href="#一、计算机" class="headerlink" title="一、计算机"></a>一、计算机</h2><h4 id="计算机发展"><a href="#计算机发展" class="headerlink" title="计算机发展"></a>计算机发展</h4><blockquote><ol><li>电子管计算机<ul><li>ENIAC：第一台计算机、十进制表示、累加器风格</li></ul></li><li>晶体管计算机<ul><li>内存：磁芯存储器</li><li>外存：磁鼓、磁带</li><li>变址、中断、I/O</li><li>出现高级语言</li></ul></li><li>中/大规模集成电路计算机<ul><li>微程序、cache、虚拟存储器、流水线</li></ul></li><li>超大规模集成电路计算机</li></ol><p>摩尔定律：每18个月，集成度翻一番，速度提高一倍，价格降低一倍</p></blockquote><hr><h4 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h4><blockquote><p>采用”存储程序“工作方式：将程序与数据存入主存中，能不在人为干涉下，逐条取指并执行</p><p>EDSAC为第一台存储程序计算机</p><p>五大部件</p></blockquote><ul><li>运算器、控制器、存储器、输入、输出设备</li></ul><hr><h4 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h4><blockquote><ul><li>系统软件：有效、安全使用管理计算机的软件和为开发和运行应用软件而提供的软件<ul><li>操作系统、语言处理系统、数据库管理系统、各类实用程序</li></ul></li><li>应用软件</li></ul></blockquote><hr><h4 id="计算机系统结构划分"><a href="#计算机系统结构划分" class="headerlink" title="计算机系统结构划分"></a>计算机系统结构划分</h4><blockquote><p>应用</p><p>算法</p><p>编程</p><p>操作系统</p><p>ISA 指令集体系结构</p><p>微体系结构</p><p>功能部件 RTL</p><p>电路</p><p>器件</p></blockquote><hr><h4 id="翻译程序分类"><a href="#翻译程序分类" class="headerlink" title="翻译程序分类"></a>翻译程序分类</h4><blockquote><ol><li>汇编程序：将汇编程序翻译成机器语言</li><li>解释程序：将语言逐条翻译成机器语言执行</li><li>编译程序：将高级语言翻译成汇编或机器语言</li></ol></blockquote><hr><h4 id="程序开发过程"><a href="#程序开发过程" class="headerlink" title="程序开发过程"></a>程序开发过程</h4><blockquote><ol><li>预处理阶段： .cpp-&gt;<strong>.i</strong></li><li>编译阶段：对预处理后的文件编译，生成汇编语言源程序文件 <strong>.s</strong></li><li>汇编阶段：对汇编源程序进行汇编，生成一个<strong>可重定位目标文件</strong>，是<strong>二进制文件</strong> <strong>.o</strong></li><li>链接阶段：将可重定位目标文件和标准函数库合并为一个<strong>可执行目标文件</strong> </li></ol></blockquote><hr><h4 id="计算机性能测试"><a href="#计算机性能测试" class="headerlink" title="计算机性能测试"></a>计算机性能测试</h4><blockquote><p><strong>CPI</strong>:执行一条指令所需的时钟周期数 CPI=总周期数/总指令条数</p><p><strong>MIPS</strong>：(Million Instructions Per Second) 每秒执行多少百万条指令</p><p>用基准程序</p></blockquote><hr><h4 id="计算机用户"><a href="#计算机用户" class="headerlink" title="计算机用户"></a>计算机用户</h4><ol><li>最终用户：使用程序完成特定任务(应用层)</li><li>系统管理员：对系统进行配置、管理维护(操作系统提供的抽象层)</li><li>应用程序员：使用高级编程语言编制软件的程序员(编程层)</li><li>系统程序员：设计开发系统软件的程序员(ISA层)</li></ol><hr><h4 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h4><p>ISA，指令集体系结构，规定了如何使用硬件，涉及内容：</p><ul><li>指令集合</li><li>操作数类型</li><li>寄存器组结构</li><li>存储空间的大小与编址方式</li><li>大端，小端？</li><li>寻址方式</li><li>指令执行控制方式，包括程序计数器、条件码定义</li></ul><hr><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li>吞吐率：单位时间的工作量</li><li>响应时间(执行时间)：从开始到作业结束所用的时间</li></ul><h2 id="二、运算"><a href="#二、运算" class="headerlink" title="二、运算"></a>二、运算</h2><h4 id="补码溢出"><a href="#补码溢出" class="headerlink" title="补码溢出"></a>补码溢出</h4><ul><li>最高次高位进位不同</li><li>和的符号和加数符号不同</li></ul><p>E1~移~ + E2~移~ = [E1 + E2]~补~</p><p>E1~移~ - E2~移~ = [E1 - E2]~补~</p><hr><h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>码距d为奇数，可以发现d-1位错，纠正(d-1)/2位错</p><p>码距为偶数，可以发现d/2位错，纠正d/2-1位错</p><ul><li>奇偶校验码距为2，能发现1位错，不能纠错</li><li>海明校验码距为3，能发现2位错，纠1位错</li></ul><hr><h4 id="海明校验-SEC"><a href="#海明校验-SEC" class="headerlink" title="海明校验(SEC)"></a>海明校验(SEC)</h4><p>n位数据引入k为校验码，需满足：</p><blockquote><p> $2^K \geq 1 + K + n$</p></blockquote><ul><li>故障字全0：无错</li><li>故障字中有1个1：1位校验位错</li><li>故障字中有多个1：1位数据位错(分组确认)</li></ul><hr><h4 id="浮点数加减步骤"><a href="#浮点数加减步骤" class="headerlink" title="浮点数加减步骤"></a>浮点数加减步骤</h4><blockquote><ul><li>对阶</li><li>尾数加减(隐藏位参与运算)</li><li>规格化</li><li>舍入(保护位|舍入位|粘位)<ul><li>就近舍入(偶数优先)</li><li>正无穷向舍入</li><li>负无穷向舍入</li><li>朝0舍入</li></ul></li><li>判断溢出</li></ul></blockquote><hr><h4 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h4><blockquote><script type="math/tex; mode=display">F_i = X_i \bigoplus Y_i \bigoplus C_{i-1}</script><script type="math/tex; mode=display">C_i = C_{i-1}(X_i + Y_i) + X_i Y_i</script><p>$P_i = X_i + Y_i$：进位传递函数</p><p>$G_I = X_i Y_i$：进位生成函数</p></blockquote><ol><li>全先行加法器</li><li>局部现行加法器：将数据分组，组内并行，组间串行</li><li>多级现行加法器：将数据分组，组内并行，组间并行</li></ol><hr><h4 id="字、字长"><a href="#字、字长" class="headerlink" title="字、字长"></a>字、字长</h4><blockquote><p>字：处理信息的宽度，用于度量数据类型大小</p><p>字长：整数运算数据通路宽度，反映了计算机的一种处理信息的能力</p></blockquote><hr><h2 id="三、指令系统"><a href="#三、指令系统" class="headerlink" title="三、指令系统"></a>三、指令系统</h2><h4 id="指令必须包含-显示或隐含-的内容"><a href="#指令必须包含-显示或隐含-的内容" class="headerlink" title="指令必须包含(显示或隐含)的内容"></a>指令必须包含(显示或隐含)的内容</h4><ol><li>操作码</li><li>原操作数或操作数地址</li><li>结果的地址</li><li>下条指令地址</li></ol><hr><h4 id="指令设计原则"><a href="#指令设计原则" class="headerlink" title="指令设计原则"></a>指令设计原则</h4><ol><li>指令尽量短</li><li>要有充足的操作码位数</li><li>操作码含义唯一</li><li>指令长度是字节的整数倍</li><li>合理选择地址字段的个数</li><li>尽量规整</li></ol><h2 id="四、存储器"><a href="#四、存储器" class="headerlink" title="四、存储器"></a>四、存储器</h2><h4 id="CS：片选信号"><a href="#CS：片选信号" class="headerlink" title="CS：片选信号"></a>CS：片选信号</h4><h4 id="存储器逻辑框图"><a href="#存储器逻辑框图" class="headerlink" title="存储器逻辑框图"></a>存储器逻辑框图</h4><ul><li>片选信号CS</li><li>写使能WE</li><li>读出数据线D</li><li>片内地址线A</li></ul><hr><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><blockquote><p>直接映射</p></blockquote><p>主存地址：主存群号+群内块号+块内地址</p><ul><li>命中率最低</li><li>关联度最低</li><li>判断命中开销最小，命中时间最短</li><li>标记所占空间最小</li><li>无须替换算法</li></ul><blockquote><p>全相联映射</p></blockquote><p>主存地址：主存块号+块内地址</p><ul><li>命中率最高</li><li>关联度最高</li><li>判断命中时间最长</li><li>标记所占空间最大</li></ul><blockquote><p>组相联映射</p></blockquote><p>主存地址：主存群号+cache组号+块内地址</p><ul><li>n路：每组的行数为n</li></ul><blockquote><p>关联度</p></blockquote><ol><li>关联度越高，命中率越高</li><li>关联度越低，判断命中开销越小，命中时间越短</li><li>关联度越低，标记所占的空间开销越小</li></ol><hr><h4 id="cache替换算法"><a href="#cache替换算法" class="headerlink" title="cache替换算法"></a>cache替换算法</h4><blockquote><p>先进先出FIFO</p><p>最近少用LRU</p></blockquote><hr><h4 id="存储周期"><a href="#存储周期" class="headerlink" title="存储周期"></a>存储周期</h4><blockquote><p>存储器一次读写所需时间</p></blockquote><h4 id="DRAM芯片刷新-一次刷一行"><a href="#DRAM芯片刷新-一次刷一行" class="headerlink" title="DRAM芯片刷新(一次刷一行)"></a>DRAM芯片刷新(一次刷一行)</h4><blockquote><ul><li>集中刷新(整体刷新一遍)</li><li>分散刷新(将存储周期分为两部分)</li><li>异步刷新</li></ul></blockquote><hr><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>寻道时间：磁头找到磁道所需时间</p><blockquote><p>磁盘操作流程</p></blockquote><ol><li>所有磁头同步寻道(由柱面号控制)</li><li>选择磁头(由磁头号控制)</li><li>磁头等待扇区到磁头下方(扇区号控制，需从0扇区开始顺序定位到指定扇区)</li><li>读写该扇区的内容</li></ol><blockquote><p>磁盘响应时间 = 寻道时间 + 转到指定扇区时间 + 数据传输时间 + 磁盘控制器开销 + 排队时间 </p></blockquote><hr><h4 id="磁盘冗余阵列-RAID"><a href="#磁盘冗余阵列-RAID" class="headerlink" title="磁盘冗余阵列(RAID)"></a>磁盘冗余阵列(RAID)</h4><blockquote><p>出现原因：CPU、主存发展快、辅存提高慢</p><ul><li>RAID是一组物理磁盘驱动器，但只有一个逻辑驱动器</li><li>数据分布在一组物理磁盘上</li><li>冗余磁盘存放校验信息</li></ul><hr><p>RAID0</p><ul><li>无冗余</li><li>并行发送，I/O响应快</li><li>数据传输速率较高</li><li><p>不保证可靠性</p><p><img src="RAID0.png" style="width=400px"></p></li></ul><hr><p>RAID1</p><ul><li>实现1对1冗余(直接备份完整一份)</li><li>读：读定位时间更少的磁盘</li><li>写：写两次磁盘</li><li><p>可靠性高、价格昂贵</p><p><img src="RAID1.png" style="width=400px"></p></li></ul><hr><p>RAID2</p><ul><li>海明校验生成冗余盘，纠正一位错，检测两位错</li><li>条区小，传输速率高，但I/O响应差</li><li>并行读写</li><li>写操作要同时写数据盘和校验盘</li><li><p>贵(已不再使用)</p><p><img src="RAID2.png" style="width=400px"></p></li></ul><hr><p>RAID3</p><ul><li>奇偶校验生成单个冗余盘</li><li>条区交叉分布，使用小条区，数据传输速率高，I/O响应差</li><li>用于大容量I/O请求场合</li><li><p>磁盘可以奇偶校验恢复</p><p><img src="RAID3.png" style="width=400px"></p></li></ul><hr><p>RAID4</p><ul><li>一个冗余盘存放奇偶校验码</li><li>大条区交叉分布，I/O响应快</li><li>独立存取技术，每个磁盘操作独立进行I/O响应快</li><li><p>少量写：有写损失，需先读之前数据，才能更新校验</p></li><li><p>大量写：直接根据新数据计算奇偶校验，无需读原数据</p><p><img src="RAID4.png" style="width=400px"></p></li></ul><hr><p>RAID5</p><ul><li>奇偶校验放在各个磁盘中</li><li>独立存取技术，I/O响应快</li><li><p>成本低，效率高</p><p><img src="RAID5.png" style="width=400px"></p></li></ul><hr><p>RAID6</p><ul><li>对RAID5的扩展，引入第二种奇偶校验，可靠性很高</li><li>写入速度慢</li></ul><hr><p>RAID7</p><ul><li>在RAID6基础上，采用Cache，速度有较大提高</li></ul></blockquote><h2 id="五、总线"><a href="#五、总线" class="headerlink" title="五、总线"></a>五、总线</h2><h4 id="I-O性能指标"><a href="#I-O性能指标" class="headerlink" title="I/O性能指标"></a>I/O性能指标</h4><ul><li>吞吐率：单位时间内传输数据量</li><li>响应时间：响应I/O请求的时间</li></ul><h4 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h4><p>解决各种信息的输入输出</p><ul><li>输入系统：将人感知的信息转化成二进制输入到系统中</li><li>输出系统：将二进制转换成人能感知的信息</li></ul><hr><h4 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h4><blockquote><ul><li>芯片内总线:芯片内部元件间连接</li><li>系统总线:系统主要功能部件间连接</li><li>通信总线:主机与I/O设备间连接</li></ul><hr><ul><li>数据总线</li><li>地址总线</li><li>控制总线</li></ul></blockquote><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><blockquote><p>控制线</p><blockquote><ul><li>clock、reset</li><li>总线请求</li><li>中断相关</li><li>存储器读写信号</li><li>传输确认</li></ul></blockquote><p>地址线(宽度反映最大寻址空间)</p><p>数据线(宽度反映一次传输数据大小)</p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote><p>总线裁决：选择哪个设备使用总线</p><p>总线定时：确定总线事务每一步的开始结束</p><p>设计趋势：点对点、异步、串行</p><p>传输方式：</p><ul><li>突发(发送一个地址后，连续传数据，后续地址默认自增)</li><li>非突发：一个地址对应一个数据</li></ul></blockquote><h4 id="I-O控制器-I-O接口的职能"><a href="#I-O控制器-I-O接口的职能" class="headerlink" title="I/O控制器(I/O接口的职能)"></a>I/O控制器(I/O接口的职能)</h4><blockquote><ul><li>数据缓冲</li><li>错误或状态检测</li><li>控制和定时</li><li>数据格式转换</li><li>与主机和设备通信</li></ul></blockquote><h4 id="I-O设备寻址方式"><a href="#I-O设备寻址方式" class="headerlink" title="I/O设备寻址方式"></a>I/O设备寻址方式</h4><blockquote><p>统一编址：与主存空间统一编址，将主存空间分出一部分给I/O串口编号</p><p>独立编址</p></blockquote><h4 id="I-O传输方式"><a href="#I-O传输方式" class="headerlink" title="I/O传输方式"></a>I/O传输方式</h4><blockquote><p>轮询方式</p><blockquote><p>OS主动询问设备状态</p></blockquote><p>程序中断方式</p><blockquote><p>设备通知cpu，中断当前进程</p></blockquote><p>直接存储器访问方式(DMA)</p><blockquote><p>存储设备直接与主存进行数据交换</p></blockquote></blockquote><p>IN命令：读设备信息到CPU，OUT命令：写CPU信息到设备</p><hr><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><blockquote><p><strong>过程</strong>：中断检测(硬件实现)、中断响应(硬件实现)、中断处理(软件实现)</p><p><strong>中断响应条件</strong></p><ul><li>开中断状态</li><li>指令执行完(异常无须指令执行完就要处理)</li><li>有未被屏蔽的中断请求</li></ul><p><strong>中断响应过程</strong></p><ul><li>关中断</li><li>保护断点与程序状态</li><li>识别中断源(硬件、软件通过判断优先级识别)</li></ul><p><strong>中断处理过程</strong></p><ul><li>保护现场及旧屏蔽字</li><li>查明原因</li><li>设置新屏蔽字</li><li>开中断</li><li>处理中断(可被新的中断打断)</li><li>关中断</li><li>恢复现场及旧屏蔽字</li><li>开中断</li><li>清中断请求</li><li>返回</li></ul></blockquote><hr><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p> 出现原因</p><blockquote><ul><li>轮询cpu利用率低，传输效率低</li><li>中断需响应中断请求，需处理断点、保护现场，开销过大</li></ul><p>特点</p><ul><li>高速缓存和主存间直接传输数据</li><li>通过DMA控制器控制数据传输</li></ul><p>采用请求-响应方式</p><ul><li>DMA控制器优先级比CPU更高</li><li>DMA控制器向cpu发送DMA请求，CPU中断，将总线控制权交给DMA控制器</li></ul></blockquote><p> DMA数据传输方式</p><blockquote><ul><li>CPU停止法：DMA传输时，CPU脱离总线<ul><li>CPU访存受限，主线周期没有充分利用</li><li>弥补缺点方法：<ul><li>引入缓存</li><li>周期挪用</li></ul></li></ul></li><li>周期挪用：DMA传输时，CPU让出一个总线事务周期让DMA控制总线，传送完一个数据后立刻释放总线<ul><li>总线切换开销较大</li></ul></li><li>交替分时：每个存储周期分为两个时间，一个给CPU，一个给DMA</li></ul></blockquote><p> DMA控制器的功能</p><blockquote><ul><li>请求：接收外设发来的”总线请求”信号，并向CPU发送DMA信号</li><li>响应：cpu响应后，DMA控制器能接管对总线的控制</li><li>能在地址线给出主存地址，并修改主存地址</li><li>识别传送方向</li><li>确定数据个数</li><li>能发出DMA结束信号</li></ul></blockquote><p> DMA操作步骤</p><blockquote><ol><li>DMA控制器初始化(软件实现)<ul><li>准备内存</li><li>设置传送参数</li><li>启动外设</li></ul></li><li>DMA数据传输(硬件实现)</li><li>DMA结束处理(软件实现)</li></ol></blockquote><hr><h2 id="六、指令"><a href="#六、指令" class="headerlink" title="六、指令"></a>六、指令</h2><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><ol><li>立即寻址：指令给出操作数本身</li><li>直接寻址：指令给出操作数的地址</li><li>间接寻址：地址存放存储操作数地址的<strong>主存单元</strong>地址</li><li>寄存器间接寻址：地址为<strong>寄存器号</strong>，其中存放操作数的有效地址</li><li>变址寻址：指令给出存放<strong>基址</strong>的地址，偏移量由变址寄存器给出</li><li>相对寻址：相对PC的地址</li><li>基址寻址：指令给出存放<strong>偏移量</strong>的地址，基址由基址寄存器给出</li></ol><blockquote><p>Clock-to-signal 一定大于 Clock-to-Q</p></blockquote><hr><h4 id="指令系统设计风格"><a href="#指令系统设计风格" class="headerlink" title="指令系统设计风格"></a>指令系统设计风格</h4><blockquote><p>按操作数位置</p></blockquote><ol><li>累加器型：运算的一个操作数隐含在累加器中</li><li>栈型：操作数必须来自栈顶</li><li>通用寄存器型：使用通用寄存器存放数据</li><li>Load/Store型：只有Load和Store指令可以访存</li></ol><blockquote><p>按指令格式复杂程度</p></blockquote><ol><li>CISC：复杂指令集<ul><li>Intel</li></ul></li><li>RISC：简单指令集<ul><li>PowerPC、MIPS、Sun、SPARC、Compaq Alpha</li></ul></li></ol><hr><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><ul><li>ALUSrc：选择操作数(0:BusB；1:立即数)</li><li>ALUCtr：选择ALU操作类型</li><li>ExtOp：选择扩展类型(1符号扩展)</li><li>MemtoReg：选择输出到寄存器(0:ALU result；1:Mem)</li><li>RegDst：0:Rd；1:Rt</li><li>RegWr：是否写寄存器</li><li>MemWr：是否写主存</li><li>Jump</li></ul><hr><h4 id="微指令编码"><a href="#微指令编码" class="headerlink" title="微指令编码"></a>微指令编码</h4><ol><li>直接控制法(不译法)：微操作码长度和微命令个数相当</li><li>字段直接编码法</li><li>字段简介编码法：在字段直接编码的基础上进行压缩，某一字段可以表示多组微命令组，具体为哪一个微命令组需要其它字段给出(<strong>垂直型微指令</strong>)</li></ol><h2 id="七、异常中断处理"><a href="#七、异常中断处理" class="headerlink" title="七、异常中断处理"></a>七、异常中断处理</h2><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><blockquote><p><strong>内部异常</strong></p></blockquote><p>由<strong>处理器</strong>内部异常引起的异常，按照发生原因分类：</p><ol><li><strong>硬故障中断</strong>：由硬连线异常引起(电源掉电、存储器线路错误)</li><li><strong>程序性异常</strong>：CPU执行指令时出现的异常(除零、溢出、断点、访问超时、非法操作码、栈溢出、缺页、地址越界)</li></ol><hr><p>按照发生异常的报告方式和返回方式不同分类：</p><ol><li><strong>故障</strong>(失效)：引起故障的<em>指令启动后，执行结束前</em>被检测到异常；<strong>由特定指令产生</strong></li><li><strong>自陷</strong>(陷阱、陷入)：先将CPU设定为某个特定的状态，在程序执行过程中，当满足一定状态的条件时，执行特定的程序对其进行处理，执行完异常处理后回到下一条指令执行；<strong>由特定指令产生</strong></li><li><strong>终止</strong>：指令执行过程中出现了使机器无法继续执行的硬件故障(掉电、线路故障等)，调出中断服务程序重启系统(<strong>随机发生</strong>)</li></ol><hr><h4 id="中断-1"><a href="#中断-1" class="headerlink" title="中断"></a>中断</h4><blockquote><p><strong>外部中断</strong></p></blockquote><p><strong>外设</strong>完成任务或发生特定事件(打印机缺页、键盘缓冲满等)，会向CPU发中断请求</p><hr><h4 id="异常处理步骤"><a href="#异常处理步骤" class="headerlink" title="异常处理步骤"></a>异常处理步骤</h4><ul><li>关中断</li><li>保护断点和程序状态</li><li>识别异常并处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>毛泽东思想与中国特色社会主义</title>
    <link href="/2018/12/06/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E6%80%9D%E6%83%B3%E4%B8%8E%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89/"/>
    <url>/2018/12/06/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E6%80%9D%E6%83%B3%E4%B8%8E%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><hr><h4 id="各种思想的历史地位"><a href="#各种思想的历史地位" class="headerlink" title="各种思想的历史地位"></a>各种思想的历史地位</h4><div class="table-container"><table><thead><tr><th style="text-align:center">思想</th><th style="text-align:center">历史地位</th></tr></thead><tbody><tr><td style="text-align:center">毛泽东思想</td><td style="text-align:center">马克思主义中国化的第一个重大理论成果</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">中国革命和建设的科学指南</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">中国共产党和中国人民宝贵的精神财富</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">邓小平理论</td><td style="text-align:center">马克思列宁主义、毛泽东思想的继承和发展</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">中国特色社会主义理论体系的开篇之作</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">改革开放和社会主义现代化建设的科学指南</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">“三个代表”重要思想</td><td style="text-align:center">中国特色社会主义理论体系的接续发展</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">加强和改进党的建设，推进中国特色社会主义事业的强大理论武器</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">科学发展观</td><td style="text-align:center">中国特色社会主义理论体系的接续发展</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">发展中国特色社会主义必须长期坚持的指导思想</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">习近平新时代中国特色社会主义思想的历史地位</td><td style="text-align:center">马克思主义中国化最新成果</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">新时代的精神旗帜</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">实现中华民族伟大复兴的行动指南</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><h2 id="一、毛泽东思想及其历史地位"><a href="#一、毛泽东思想及其历史地位" class="headerlink" title="一、毛泽东思想及其历史地位"></a>一、毛泽东思想及其历史地位</h2><h4 id="毛泽东思想形成的历史条件-了解"><a href="#毛泽东思想形成的历史条件-了解" class="headerlink" title="毛泽东思想形成的历史条件(了解)"></a>毛泽东思想形成的历史条件(了解)</h4><blockquote><ul><li>19世纪末20世纪初，世界进入无产阶级革命时代。中国反帝反封建的民主革命从旧的<strong>世界资产阶级民主革命</strong>的一部分，转变为新的<strong>世界无产阶级社会主义革命</strong>的一部分。</li><li>中国共产党成立后，为人民谋幸福，经历了千辛万苦的奋斗历程。毛泽东思想正是在中国革命和建设的<strong>丰富实践</strong>中诞生的。</li></ul></blockquote><h4 id="毛泽东思想的形成过程"><a href="#毛泽东思想的形成过程" class="headerlink" title="-毛泽东思想的形成过程"></a>-毛泽东思想的形成过程</h4><blockquote><ul><li><p>形成：</p><blockquote><ul><li><strong>第一次国内革命战争时期</strong>：《中国社会各阶级的分析》《湖南农民运动考察报告》：分析中国社会各阶级在革命中的地位与作用，提出了新民主主义革命的基本思想。</li><li><strong>土地革命战争时期</strong>：《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》中，提出<strong>农村包围城市，武装夺取政权</strong>的思想，<strong>标志着毛泽东思想的初步形成</strong>。</li></ul></blockquote></li><li><p>成熟</p><blockquote><p>《实践论》《矛盾论》中，毛泽东系统分析了党内“左”和“右”的错误思想根源。</p><p>《&lt;共产党人&gt;发刊词》《中国革命和中国共产党》《新民主主义论》《论联合政府》中，科学阐述了新民主主义革命的对象、动力、领导力量、性质和前途等基本问题，提出了新民主主义总路线，制定了经济、政治文化纲领，指明了新民主主义革命的具体目标。</p></blockquote></li><li><p>继续发展</p><blockquote><p>《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》《论十大关系》《关于正确处理人民内部矛盾的问题》中，毛泽东思想进一步丰富与发展。</p></blockquote></li></ul></blockquote><h4 id="毛泽东思想的主要内容"><a href="#毛泽东思想的主要内容" class="headerlink" title="毛泽东思想的主要内容"></a>毛泽东思想的主要内容</h4><blockquote><ol><li><p>新民主主义革命理论</p><blockquote><ul><li>中国资产阶级有两个部分，依附于帝国主义的大资产阶级和既有革命要求又有动摇性的民族资产阶级。</li><li>由于帝国主义的侵略，加之中国没有资产阶级民主，因此中国革命只能以长期的武装斗争为主要形式。</li><li>统一战线和武装斗争是战胜敌人的两大法宝。</li></ul></blockquote></li><li><p>社会主义革命和社会主义建设理论</p><blockquote><p>社会主义社会任然存在着矛盾，基本矛盾仍然是生产关系和生产力之间的矛盾、上层建筑和经济基础之间的矛盾，必须严格区分和正确处理敌我矛盾和人民内部矛盾的思想。...</p></blockquote></li><li><p>革命军队建设和军事战略理论</p><blockquote><ul><li>人民军队的唯一宗旨：全心全意为人民服务</li><li>原则：党指挥枪</li></ul></blockquote></li><li><p>政策和策略理论</p><blockquote><ul><li>战略上要藐视敌人，战术上要重视敌人</li><li>无产阶级及其政党要实现自己对同盟者的领导，必须具备两个条件：<ul><li>率领被领导者向着共同敌人作坚决斗争并取得胜利</li><li>对被领导者以物质利益，至少不损害其利益，同时给以政治教育。</li></ul></li></ul></blockquote></li><li><p>思想政治工作和文化工作的理论</p></li><li><p>党的建设理论</p></li></ol></blockquote><h4 id="毛泽东思想活的灵魂-掌握"><a href="#毛泽东思想活的灵魂-掌握" class="headerlink" title="毛泽东思想活的灵魂(掌握)"></a>毛泽东思想活的灵魂(掌握)</h4><blockquote><p>定义：贯穿于毛泽东思想各个组成部分的立场、观点和方法，是毛泽东思想的活的灵魂，它们有三个基本方面，即实事求是，群众路线，独立自主。</p><ul><li><p>实事求是</p><blockquote><p>实事求是，就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。实事求是，是<strong>党的基本思想方法、工作方法、领导方法</strong></p><ul><li>坚持实事求是，就是要深入了解事物的本来面貌，把握事物内在必然联系，按照客观规律办事。</li><li>清醒认识和正确把握我国基本国情。</li><li>不断推进实践基础上的理论创新。</li></ul></blockquote></li><li><p>群众路线</p><blockquote><p>群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。群众路线是党的<strong>生命线和根本工作路线，是党永葆青春活力和战斗力的重要传家宝</strong>。</p><ul><li>坚持群众路线，就要坚持人民是推动历史发展的根本力量。</li><li>坚持全心全意为人民服务的根本宗旨。</li><li>保持党同人民群众的血肉联系。</li></ul></blockquote></li><li><p>独立自主</p><blockquote><ul><li>独立自主，就是坚持<strong>独立思考，走自己的路</strong>，坚定不移地<strong>维护民族独立、捍卫国家主权，把立足点放在依靠自己的力量上</strong>，同时<strong>积极争取外援，开展国际经济文化交流，学习外国一切对我们有利的先进事物</strong>。</li><li>坚持独立自主，就是要坚持<strong>中国的事情必须由中国人民自己处理</strong>。</li><li><strong>坚持独立自主的和平外交政策，坚定不移的发展和平道路</strong>。</li></ul></blockquote></li></ul></blockquote><h4 id="毛泽东思想的历史地位"><a href="#毛泽东思想的历史地位" class="headerlink" title="毛泽东思想的历史地位"></a>毛泽东思想的历史地位</h4><blockquote><ul><li>马克思主义中国化的第一个重大理论成果</li><li>中国革命和建设的科学指南</li><li>中国共产党和中国人民宝贵的精神财富</li></ul></blockquote><hr><h2 id="二、新民主主义革命理论"><a href="#二、新民主主义革命理论" class="headerlink" title="二、新民主主义革命理论"></a>二、新民主主义革命理论</h2><h4 id="新民主主义革命"><a href="#新民主主义革命" class="headerlink" title="新民主主义革命"></a>新民主主义革命</h4><blockquote><p>无产阶级领导的，人民大众的，反对帝国主义，封建主义和官僚资本主义的革命</p></blockquote><h4 id="新民主主义实践基础"><a href="#新民主主义实践基础" class="headerlink" title="新民主主义实践基础"></a>新民主主义实践基础</h4><blockquote><ol><li>旧民主主义革命的失败呼唤新的革命理论</li><li>新民主主义革命的艰辛探索奠定了革命理论形成的实践基础</li></ol></blockquote><h4 id="新民主主义总路线-了解"><a href="#新民主主义总路线-了解" class="headerlink" title="新民主主义总路线(了解)"></a>新民主主义总路线(了解)</h4><blockquote><ol><li>革命对象：帝国主义、封建主义、官僚资本主义</li><li>革命动力：无产阶级(最基本动力)、农民阶级(可靠同盟军)、城市小资产阶级(可靠同盟)、民族资产阶级</li><li>领导力量：无产阶级</li><li>性质：<strong>资产阶级民主革命</strong></li><li>前途：社会主义</li></ol></blockquote><h4 id="新旧民主主义革命区别-了解"><a href="#新旧民主主义革命区别-了解" class="headerlink" title="新旧民主主义革命区别(了解)"></a>新旧民主主义革命区别(了解)</h4><blockquote><p>新民主主义革命比旧民主主义有新的内容和特点，表现在：</p><ul><li>中国革命处于世界无产阶级社会革命时代，是世界无产阶级社会主要革命的一部分</li><li>革命领导力量是中国无产阶级及其先锋队中国共产党</li><li>指导思想是马克思主义</li><li>革命前途是社会主义而不是资本主义</li></ul></blockquote><h4 id="新民主主义革命基本纲领-了解"><a href="#新民主主义革命基本纲领-了解" class="headerlink" title="新民主主义革命基本纲领(了解)"></a>新民主主义革命基本纲领(了解)</h4><blockquote><p>政治纲领：</p><blockquote><p>推翻帝国主义和封建主义统治，建立无产阶级领导的、工农联盟为基础的、各革命阶级联合专政的新民主主义共和国</p></blockquote><p>经济纲领：</p><blockquote><ol><li>没收封建地主阶级土地归农民所有</li><li>没收官僚资产阶级的垄断资本归新民主主义国家所有</li><li>保护民族工商业</li></ol></blockquote><p>文化纲领</p><blockquote><p>新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学大众的文化</p></blockquote></blockquote><h4 id="新民主主义革命道路-了解"><a href="#新民主主义革命道路-了解" class="headerlink" title="新民主主义革命道路(了解)"></a>新民主主义革命道路(了解)</h4><blockquote><p><strong>农村包围城市，武装夺取政权</strong></p></blockquote><h4 id="新民主主义革命三大法宝"><a href="#新民主主义革命三大法宝" class="headerlink" title="新民主主义革命三大法宝"></a>新民主主义革命三大法宝</h4><blockquote><ol><li>统一战线</li><li>武装斗争</li><li>党的建设</li></ol></blockquote><h2 id="三、社会主义改造理论"><a href="#三、社会主义改造理论" class="headerlink" title="三、社会主义改造理论"></a>三、社会主义改造理论</h2><h4 id="新民主主义社会是一个过渡性的社会-了解"><a href="#新民主主义社会是一个过渡性的社会-了解" class="headerlink" title="新民主主义社会是一个过渡性的社会(了解)"></a>新民主主义社会是一个过渡性的社会(了解)</h4><blockquote><p>新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态</p><p>在新民主主义社会中，存在五种经济成分：</p><blockquote><ul><li>社会主义性质的国营经济</li><li>半社会主义性质的合作社经济</li><li>农民和手工业的个体经济</li><li>私人资本主义经济</li><li>国家资本主义经济</li></ul></blockquote></blockquote><h4 id="社会主义改造道路的历史经验-了解"><a href="#社会主义改造道路的历史经验-了解" class="headerlink" title="社会主义改造道路的历史经验(了解)"></a>社会主义改造道路的历史经验(了解)</h4><blockquote><ol><li><p><strong>农业、手工业的社会主义改造</strong></p><blockquote><ul><li>积极引导农民组织起来，走<strong>互助合作</strong>道路</li><li>遵循自愿互利、典型示范、国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。</li><li>正确分析农村的阶级和阶层状况，制定正确的阶级政策。</li><li>坚持积极领导、稳步前进的方针。</li></ul></blockquote></li><li><p><strong>资本主义工商业的社会主义改造</strong></p><blockquote><ul><li><strong>和平赎买</strong>的方法改造资本主义工商业</li><li>采取从低级到高级的国家资本主义的过渡形式</li><li>把资本主义工商业者改造成为自食其力的社会主义劳动者</li></ul></blockquote></li></ol></blockquote><h4 id="确立社会主义基本制度的重大意义-理解"><a href="#确立社会主义基本制度的重大意义-理解" class="headerlink" title="确立社会主义基本制度的重大意义(理解)"></a>确立社会主义基本制度的重大意义(理解)</h4><blockquote><ul><li>社会主义基本制度的确立是中国历史上最深刻伟大的社会变革，为当代中国一切发展进步奠定了制度基础，也为中国特色社会主义制度的创新发展提供了重要前提。</li><li>社会主义基本制度的确立，极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展。</li><li>初步显示了社会主义的优越性。</li><li>为当代中国一切发展进步奠定了根本政治前提和制度基础。</li><li>改变了世界政治经济格局，增强了社会主义力量，对维护世界和平产生了积极影响</li></ul></blockquote><hr><h2 id="四、社会主义建设道路初步探索的理论成果"><a href="#四、社会主义建设道路初步探索的理论成果" class="headerlink" title="四、社会主义建设道路初步探索的理论成果"></a>四、社会主义建设道路初步探索的理论成果</h2><h4 id="论十大关系-了解"><a href="#论十大关系-了解" class="headerlink" title="论十大关系(了解)"></a>论十大关系(了解)</h4><blockquote><p>1956年4月和5月，毛泽东先后在中央政治局扩大会议和最高国务会议上，做《论十大关系》报告。</p><ul><li>以苏为鉴，独立自主地探索适合中国情况的社会主义建设道路。</li><li>《论十大关系》标志着党探索中国社会主义建设道路的良好开端。</li></ul><p>意义</p><blockquote><p>确定一个基本方针：努力把党内党外、国内国外的一切积极因素，直接的、间接的积极因素全部调动起来，为社会主义建设服务。</p></blockquote></blockquote><h4 id="走中国工业化道路的思想-了解"><a href="#走中国工业化道路的思想-了解" class="headerlink" title="走中国工业化道路的思想(了解)"></a>走中国工业化道路的思想(了解)</h4><blockquote><p>以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针，以及一整套“两条腿走路“的工业化发展思路，及重工业和轻工业并举，中央工业和地方工业同时并举，沿海工业和内地工业同时并举，大型企业和中小型企业同时并举。</p></blockquote><h4 id="初步探索的意义及历史教训-掌握"><a href="#初步探索的意义及历史教训-掌握" class="headerlink" title="初步探索的意义及历史教训(掌握)"></a>初步探索的意义及历史教训(掌握)</h4><blockquote><p>初步探索的意义</p><blockquote><ol><li>巩固和发展了我国社会主义制度</li><li>为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础</li><li>丰富了科学社会主义的理论和实践</li></ol></blockquote><p>初步探索的经验教训</p><blockquote><ol><li>必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路</li><li>必须正确认识社会主义的主要矛盾和根本任务，集中力量发展生产力</li><li>必须从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成</li><li>必须发展社会主义民主，健全社会主义法制</li><li>必须坚持党的民主集中制和集体领导制度，加强执政党建设</li><li>必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设</li></ol></blockquote></blockquote><hr><h2 id="五、邓小平理论"><a href="#五、邓小平理论" class="headerlink" title="五、邓小平理论"></a>五、邓小平理论</h2><h4 id="邓小平理论的形成条件-了解"><a href="#邓小平理论的形成条件-了解" class="headerlink" title="邓小平理论的形成条件(了解)"></a>邓小平理论的形成条件(了解)</h4><blockquote><ol><li>和平与发展成为时代主题是邓小平理论形成的时代背景</li><li>社会主义建设的经验教训是邓小平理论形成的历史依据</li><li>改革开放和现代化建设的实践是邓小平理论形成的实现依据</li></ol></blockquote><h4 id="邓小平理论的形成过程-了解"><a href="#邓小平理论的形成过程-了解" class="headerlink" title="邓小平理论的形成过程(了解)"></a>邓小平理论的形成过程(了解)</h4><blockquote><ol><li><strong>形成前提</strong>：十一届三中全会，重新确立了解放思想、实事求是的思想路线，实现了党的历史上具有深远意义的伟大转折。</li><li><strong>提出中国特色社会主义</strong>：”邓小平在十二大中指出，把马克思主义的普遍真理同我国的具体实际结合起来，走自己的路，建设有中国特色的社会主义，这就是我们总结长期历史经验得出的基本结论。”</li><li>十二届三中全会作出《关于经济体制改革的决定》，提出了社会主义经济是公有制基础上的有计划的商品经济。</li><li><strong>初步形成</strong>：党的十三大，第一次系统地论述了我国社会主义初级阶段理论，明确概括和全面阐发了党的“一个中心，两个基本点”的基本路线。</li><li><strong>定型</strong>：党的十五大正式提出“邓小平理论”这一概念，将邓小平理论和马克思列宁主义、毛泽东思想一起，确立为党的指导思想指导思想并写入党章。1999年宪法修正案正式将邓小平理论载入宪法。</li></ol></blockquote><h4 id="邓小平理论回答的基本问题-掌握"><a href="#邓小平理论回答的基本问题-掌握" class="headerlink" title="邓小平理论回答的基本问题(掌握)"></a>邓小平理论回答的基本问题(掌握)</h4><blockquote><p><strong>邓小平理论回答的基本问题</strong>：什么是社会主义，怎样建设社会主义。</p><p>邓小平在南方谈话中指出：<strong>社会主义的本质</strong>，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。这一概括的含义有：</p><ul><li>包括了社会主义社会的生产力问题，又包括了以社会主义生产关系为基础的社会关系问题。</li><li>”解放生产力，发展生产力“，纠正了过去忽视生产力发展的错误观念。</li><li>目标为：”消灭剥削，消除两极分化，最终达到共同富裕“。</li></ul></blockquote><h4 id="邓小平理论的主要内容-了解"><a href="#邓小平理论的主要内容-了解" class="headerlink" title="邓小平理论的主要内容(了解)"></a>邓小平理论的主要内容(了解)</h4><blockquote><ol><li><p>解放思想、实事求是的思想路线。</p></li><li><p>社会主义初级阶段理论：</p><blockquote><p><strong>社会主义初级阶段定义</strong>：党的十三大系统地论述了社会主义初级阶段理论。<strong>社会主义初级阶段</strong>，就是指我国在生产力落后，商品经济不发达条件下建设社会主义必然要经历的特定阶段，即我国进入社会主义到基本实现社会主义现代化的整个历史阶段。</p><p><strong>社会主义初级阶段的论断的含义</strong>：</p><ul><li>我国已经进入社会主义社会，必须坚持而不能离开社会主义。</li><li>我国的社会主义社会还处在不发达阶段，必须正视而不能超越初级阶段。</li></ul></blockquote></li><li><p>党的基本路线</p><blockquote><ol><li>建设”富强、民主、文明的社会主义现代化国家“。</li><li>一个中心、两个基本点，以经济建设为中心，坚持四项基本原则，坚持改革开放。<ul><li><strong>以经济建设为中心</strong>，回答了<strong>社会主义的根本任务</strong>，体现了社会主义基本制度要求。</li><li><strong>坚持四项基本原则</strong>，回答解放和发展生产力的政治保证问题，体现了社会主义基本制度要求。</li><li><strong>坚持改革开放</strong>，回答了社会主义发展动力和外部条件问题。</li></ul></li><li>领导和团结全国各族人民。</li><li>自力更生，艰苦创业。</li></ol></blockquote></li><li><p>社会主义根本任务理论</p><blockquote><ol><li>社会主义的<strong>根本任务</strong>是发展生产力。</li><li>发展是硬道理。</li><li>发展要抓住机遇。</li><li>科学技术是第一生产力。</li></ol></blockquote></li><li><p>三步走战略</p></li><li><h5 id="改革开放理论-掌握"><a href="#改革开放理论-掌握" class="headerlink" title="改革开放理论(掌握)"></a>改革开放理论(掌握)</h5><blockquote><p>邓小平明确指出：”改革是中国的第二次革命“</p><ul><li>中国共产党领导的第一次革命，把一个半殖民地半封建的旧中国变成了一个社会主义新中国。</li><li>第二次革命是指改革开放：<ul><li>把一个经济文化比较落后的社会主义中国变成一个现代化的社会主义国家。</li><li>它是社会主义制度的自我完善和发展。</li><li>改革不是一个阶级推翻另一个阶级那种对原来意义上的革命，也不是对原有经济体制的细枝末节的修补，而是对体制的根本性变革。</li><li>改革是社会主义社会发展的直接动力。</li></ul></li></ul></blockquote></li><li><p>社会主义市场经济理论</p><blockquote><p>计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。</p><p>社会主义市场经济理论有：</p><ul><li>一是计划经济和市场经济不是划分社会制度的标志。</li><li>二是计划和市场都是经济手段，对经济活动的调节各有优势和长处，社会主义实行市场经济要把两者都结合起来。</li><li>三是市场经济作为资源配置的一种方式本身具有制度属性，可以和不同的社会制度结合。</li></ul></blockquote></li><li><p>两手抓，两手都要硬</p></li><li><p>一国两制</p><blockquote><ul><li>坚持一个中国</li><li>特别行政区有高度自治权</li><li>尽最大的努力争取和平统一，但不承诺放弃使用武力</li></ul></blockquote></li></ol></blockquote><h4 id="邓小平理论的历史地位-理解"><a href="#邓小平理论的历史地位-理解" class="headerlink" title="邓小平理论的历史地位(理解)"></a>邓小平理论的历史地位(理解)</h4><blockquote><ul><li>马克思列宁主义、毛泽东思想的继承和发展</li><li>中国特色社会主义理论体系的开篇之作</li><li>改革开放和社会主义现代化建设的科学指南</li></ul></blockquote><hr><h2 id="六、三个代表思想"><a href="#六、三个代表思想" class="headerlink" title="六、三个代表思想"></a>六、三个代表思想</h2><h4 id="三个代表重要思想的形成条件-了解"><a href="#三个代表重要思想的形成条件-了解" class="headerlink" title="三个代表重要思想的形成条件(了解)"></a>三个代表重要思想的形成条件(了解)</h4><blockquote><ol><li>三个代表重要思想是在对冷战结束后国际局势科学判断的基础上形成的</li><li>三个代表重要思想是在科学判断党的历史方位和总结历史经验的基础上提出的</li><li>“三个代表”，是在建设中国特色社会主义伟大实践的基础上形成的</li></ol></blockquote><h4 id="三个代表的重要思想形成过程-了解"><a href="#三个代表的重要思想形成过程-了解" class="headerlink" title="*三个代表的重要思想形成过程(了解)"></a>*三个代表的重要思想形成过程(了解)</h4><blockquote><ol><li>建党70周年中共中央发出《关于加强党的建设的通知》</li><li>2000年，江泽民广东考察，首次对“三个代表”做出全面的阐述</li><li>党的十五届五中全会上，将“三个代表”作为加强党建、验证党的工作的标准</li><li>十六大报告，江泽民全面阐述”三个代表”，并写入党章</li></ol></blockquote><h4 id="三个代表重要思想的核心观点-理解"><a href="#三个代表重要思想的核心观点-理解" class="headerlink" title="三个代表重要思想的核心观点(理解)"></a>三个代表重要思想的核心观点(理解)</h4><blockquote><ul><li>始终代表中国先进生产力发展要求</li><li>始终代表中国先进文化的前进方向</li><li>始终代表中国最广大人民的根本利益</li></ul></blockquote><h4 id="三个代表重要思想的主要内容-了解"><a href="#三个代表重要思想的主要内容-了解" class="headerlink" title="三个代表重要思想的主要内容(了解)"></a>三个代表重要思想的主要内容(了解)</h4><blockquote><ol><li>发展是执政党兴国的第一要务</li><li>建立社会主义市场经济体制</li><li>全面建设小康社会</li><li>建设社会主义政治文明</li><li>推进党的建设新的伟大工程</li></ol></blockquote><h4 id="三个代表重要思想历史地位-理解"><a href="#三个代表重要思想历史地位-理解" class="headerlink" title="三个代表重要思想历史地位(理解)"></a>三个代表重要思想历史地位(理解)</h4><blockquote><ul><li>中国特色社会主义理论体系的接续发展</li><li>加强和改进党的建设，推进中国特色社会主义事业的强大理论武器</li></ul></blockquote><hr><h2 id="七、科学发展观"><a href="#七、科学发展观" class="headerlink" title="七、科学发展观"></a>七、科学发展观</h2><h4 id="科学发展观的科学内涵-了解"><a href="#科学发展观的科学内涵-了解" class="headerlink" title="科学发展观的科学内涵(了解)"></a>科学发展观的科学内涵(了解)</h4><blockquote><p><strong>第一要义</strong>是发展，<strong>核心立场</strong>是以人为本，<strong>基本要求</strong>是全面协调可持续，<strong>根本方法</strong>是统筹兼顾。</p></blockquote><h4 id="科学发展观的主要内容-了解"><a href="#科学发展观的主要内容-了解" class="headerlink" title="科学发展观的主要内容(了解)"></a>科学发展观的主要内容(了解)</h4><blockquote><ol><li><p>加快转变经济发展方式</p></li><li><p>发展社会主义民主政治</p></li><li><p>推进社会主义文化强国建设</p></li><li><h5 id="构建社会主义和谐社会"><a href="#构建社会主义和谐社会" class="headerlink" title="构建社会主义和谐社会"></a>构建社会主义和谐社会</h5><blockquote><p><strong>民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处</strong>，是构建社会主义和谐社会的总要求。</p></blockquote></li><li><p>推进生态文明建设</p></li><li><p>全面提高党的建设科学化水平</p></li></ol></blockquote><h4 id="科学发展观的历史地位-理解"><a href="#科学发展观的历史地位-理解" class="headerlink" title="科学发展观的历史地位(理解)"></a>科学发展观的历史地位(理解)</h4><blockquote><ul><li>中国特色社会主义理论体系的接续发展</li><li>发展中国特色社会主义必须长期坚持的指导思想</li></ul></blockquote><hr><h2 id="八、习近平新时代中国特色社会主义思想及历史地位"><a href="#八、习近平新时代中国特色社会主义思想及历史地位" class="headerlink" title="八、习近平新时代中国特色社会主义思想及历史地位"></a>八、习近平新时代中国特色社会主义思想及历史地位</h2><h4 id="历史性成就和历史性变革-了解"><a href="#历史性成就和历史性变革-了解" class="headerlink" title="历史性成就和历史性变革(了解)"></a>历史性成就和历史性变革(了解)</h4><blockquote><ol><li>经济建设取得重大成就，经济总量稳居世界第二，对世界经济增长贡献率超过30%</li><li>全面深化改革取得重大突破，蹄疾步稳推进全面深化改革</li><li>民主法治建设取得重大进展</li><li>思想文化建设取得重大进展</li><li>人民生活不断改善</li><li>生态文明建设成效显著</li><li>强军兴军开创新局面</li><li>港澳台工作取得新进展</li><li>全方位外交布局深入展开</li><li>全面严治党成效卓著</li></ol></blockquote><h4 id="社会主要矛盾的变化-理解"><a href="#社会主要矛盾的变化-理解" class="headerlink" title="社会主要矛盾的变化(理解)"></a>社会主要矛盾的变化(理解)</h4><blockquote><p>党的十九大明确指出，<strong>我国的主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分发展之间的矛盾</strong></p><p>社会主义初级阶段矛盾：<strong>人民日益增长的物质文化需要和落后的社会生产之间的矛盾</strong></p><p>依据有三个方面：</p><ul><li>经过改革开放40年的发展，我国社会生产力水平总体上显著提高，很多方面进入世界前列</li><li>人民生活水平显著提高，对美好生活的向往更加强烈，不仅对物质文化提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长</li><li>影响满足人们美好生活需要的因素很多，但主要是发展的不平衡不充分问题</li></ul></blockquote><h4 id="新时代的内涵-掌握"><a href="#新时代的内涵-掌握" class="headerlink" title="新时代的内涵(掌握)"></a>新时代的内涵(掌握)</h4><blockquote><ol><li>这个新时代是承前启后、继往开来，在新的历史条件下继续夺取中国特色社会主义伟大胜利的新时代。</li><li>这个新时代是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代。</li><li>这个新时代是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代。</li><li>这个新时代是全体中华儿女勠力同心、奋力实现中华民族伟大复兴的新时代。</li><li>这个新时代是我国日益走近世界舞台中央、不断为人类做出更伟大贡献的时代。</li></ol></blockquote><h4 id="新时代的意义-掌握"><a href="#新时代的意义-掌握" class="headerlink" title="新时代的意义(掌握)"></a>新时代的意义(掌握)</h4><blockquote><ol><li>从中华民族复兴的历史进程看，改革开放使中国人民逐步富裕起来，新时代中华民族要实现强起来的宏伟目标</li><li>从科学社会主义发展进程来看，中国特色社会主义进入新时代，意味着科学社会主义在21世纪的中国焕发出强大生机活力</li><li>从人类文明进程看，新时代拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择</li></ol></blockquote><h4 id="习近平新时代中国特色社会主义思想的核心要义和丰富内涵-了解"><a href="#习近平新时代中国特色社会主义思想的核心要义和丰富内涵-了解" class="headerlink" title="习近平新时代中国特色社会主义思想的核心要义和丰富内涵(了解)"></a>习近平新时代中国特色社会主义思想的核心要义和丰富内涵(了解)</h4><blockquote><p>最核心、最重要的内容是党的十九大概括的<strong>八个明确</strong>：</p><ol><li>明确坚持和发展中国特色社会主义，<strong>总任务</strong>是实现社会主义现代化和中华民族伟大复兴。</li><li>明确新时代我国社会<strong>主要矛盾</strong>是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的<strong>发展思想</strong>，不断促进人的全面发展、全体人民共同富裕。</li><li>明确中国特色社会主义事业<strong>总体布局</strong>是“<strong>五位一体</strong>”、<strong>战略布局</strong>是“<strong>四个全面</strong>”，强调坚定道路自信、理论自信、制度自信、文化自信。</li><li>明确<strong>全面深化改革总目标</strong>是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。</li><li>明确全面推进<strong>依法治国总目标</strong>是建设中国特色社会主义依法治国总目标是建设中国特色社会主义法制体系、建设社会主义法治国家。</li><li><strong>强军目标</strong>是，听党指挥、能打胜仗、作风优良的人民军队。</li><li><strong>中国特色大国外交</strong>要推动构建新型国际关系，推动构建人类命运共同体。</li><li>明确<strong>中国特色社会主义最本质的特征</strong>是中国共产党领导。</li></ol></blockquote><h4 id="习近平新时代中国特色社会主义思想的历史地位-理解"><a href="#习近平新时代中国特色社会主义思想的历史地位-理解" class="headerlink" title="习近平新时代中国特色社会主义思想的历史地位(理解)"></a>习近平新时代中国特色社会主义思想的历史地位(理解)</h4><blockquote><ul><li>马克思主义中国化最新成果</li><li>新时代的精神旗帜</li><li>实现中华民族伟大复兴的行动指南</li></ul></blockquote><hr><h2 id="九、坚持和发展中国特色社会主义的总任务"><a href="#九、坚持和发展中国特色社会主义的总任务" class="headerlink" title="九、坚持和发展中国特色社会主义的总任务"></a>九、坚持和发展中国特色社会主义的总任务</h2><h4 id="中国梦的科学内涵-了解"><a href="#中国梦的科学内涵-了解" class="headerlink" title="中国梦的科学内涵(了解)"></a>中国梦的科学内涵(了解)</h4><blockquote><p>中国梦的本质是“国家富强、民族振兴、人民幸福”</p><ul><li>国家富强、民族振兴是人民幸福的基础和保障</li><li>这个梦想，把国家的追求、民族的向往、人民的期盼融为一体</li><li>中国梦是国家情怀、民族情怀、人民情怀相统一的中国梦</li><li>中国梦归根到底是人民的梦</li><li>中国梦是国家的梦、民族的梦，也是每一个中国人的梦想</li><li>中国梦与世界各国人民的美好梦想相通</li></ul></blockquote><h4 id="怎样实现中国梦"><a href="#怎样实现中国梦" class="headerlink" title="怎样实现中国梦"></a>怎样实现中国梦</h4><blockquote><ul><li>实现中国梦必须走中国特色社会主义道路</li><li>实现中国梦必须弘扬中国精神</li><li>实现中国梦必须凝聚中国力量</li><li>实干才能梦想成真</li><li>实现中国梦需要和平</li></ul></blockquote><h4 id="实现社会主义现代化强国“两步走”战略的具体安排"><a href="#实现社会主义现代化强国“两步走”战略的具体安排" class="headerlink" title="实现社会主义现代化强国“两步走”战略的具体安排"></a>实现社会主义现代化强国“两步走”战略的具体安排</h4><blockquote><ol><li><p>从2020年到2035年，基本实现社会主义现代化的目标要求</p><blockquote><ul><li>经济建设方面，我国经济实力、科技实力将大幅跃升，跻身创新型国家前列。</li><li>在政治建设方面，人民平等参与、平等发展权利得到充分保障，法治国家、法治政府、法治社会基本建成，各方面制度更加完善，国家治理体系和治理能力现代化基本实现</li><li>在文化建设方面，社会文明程度达到新的高度，国家文化软实力显著增强，中华文化影响广泛深入。</li><li>在民生和社会建设方面，人民生活更为宽裕，中等收入群体比例明显提高，城乡发展差距和居民生活水平差距显著减小，基本公共服务均等化基本实现，全体人民共同富裕迈出坚实步伐。</li><li>在生态文明建设方面，生态环境根本好转，美丽中国目标基本实现。</li></ul></blockquote></li><li><p>从2035年到本世纪中叶，建成社会主义现代化强国的目标要求：</p><blockquote><ul><li>一是我国将拥有高度的物质文明</li><li>二是我国将拥有高度的政治文明</li><li>三是我国将拥有高度的精神文明</li><li>四是我国将拥有高度的社会文明</li><li>五是我国将拥有高度的生态文明</li></ul></blockquote></li></ol></blockquote><hr><h2 id="十、-五位一体-总布局"><a href="#十、-五位一体-总布局" class="headerlink" title="十、 五位一体 总布局"></a>十、 五位一体 总布局</h2><p>经济建设、政治建设、文化建设、社会建设、生态文明建设</p><h4 id="贯彻新发展理念-掌握"><a href="#贯彻新发展理念-掌握" class="headerlink" title="贯彻新发展理念(掌握)"></a>贯彻新发展理念(掌握)</h4><blockquote><ol><li><p>创新是引领发展的第一动力。抓住了创新，就抓住了牵动经济社会发展全局的关键。</p></li><li><p>协调是持续健康发展的内在要求。</p><blockquote><p>坚持协调发展，要着力推动区域协调发展、城乡协调发展、物质文明和精神文明协调发展，推动经济建设和国防建设融合发展。</p></blockquote></li><li><p>绿色是永续发展的必要条件</p><blockquote><p>绿色发展，就是要解决好人与自然和谐共生问题，坚定走生产发展、生活富裕、生态良好的文明发展道路，加快建设资源节约型、环境友好型社会，形成人与自然和谐发展现代化建设新格局，推进美丽中国建设。</p></blockquote></li><li><p>开放是国家繁荣发展的必由之路</p><blockquote><p>坚持开放发展，就要奉行互利共赢的开放战略，坚持内外需协调、进出口平衡、引进来和走出去并重、引资和引智并举，发展更高层次的开放型经济。</p></blockquote></li><li><p>共享是中国特色社会主义的本质要求</p><blockquote><p>坚持共享发展，就要不断把“蛋糕”做大，又把不断做大的“蛋糕”分好。</p></blockquote></li></ol></blockquote><h4 id="深化供给侧结构性改革"><a href="#深化供给侧结构性改革" class="headerlink" title="*深化供给侧结构性改革"></a>*深化供给侧结构性改革</h4><blockquote><ol><li>推进增长动能转换</li><li>深化要素市场化配置改革</li><li>加大人力资本培育力度</li><li>持续推进“三去一降一补“</li></ol></blockquote><h4 id="建设现代化经济体系的主要任务-掌握"><a href="#建设现代化经济体系的主要任务-掌握" class="headerlink" title="建设现代化经济体系的主要任务(掌握)"></a>建设现代化经济体系的主要任务(掌握)</h4><blockquote><ol><li>要建设创新引领、协同发展的产业体系</li><li>要建设统一开放、竞争有序的市场体系</li><li>加快形成企业自主经营公平竞争、消费者自由选择自主消费、商品和要素自由流动平等交换的现代市场体系。</li><li>建设彰显优势、协调联动的城乡区域发展体系</li><li>要建设资源节约、环境友好的绿色发展体系</li><li>要建设多元平衡、安全高效的全面开放体系</li></ol></blockquote><h4 id="坚持中国特色社会主义政治发展道路-掌握"><a href="#坚持中国特色社会主义政治发展道路-掌握" class="headerlink" title="坚持中国特色社会主义政治发展道路(掌握)"></a>坚持中国特色社会主义政治发展道路(掌握)</h4><blockquote><ol><li>中国特色社会主义政治发展道路是近代以来中国人民长期奋斗历史逻辑、理论逻辑、时间逻辑的必然结果，是坚持党的本质属性、践行党的根本宗旨的必然要求。</li><li>走中国特色社会主义政治发展道路，必须坚持党的领导、人民当家做主，依法治国有机统一。</li><li>走中国特色社会主义政治发展道路，必须坚持正确政治方向。</li></ol></blockquote><h4 id="健全人民当家作主制度体系-了解"><a href="#健全人民当家作主制度体系-了解" class="headerlink" title="健全人民当家作主制度体系(了解)"></a>健全人民当家作主制度体系(了解)</h4><blockquote><p>国体：我国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家，国家的一切权力属于人民。</p><p>政体：人民代表大会制度是我国根本政治制度。</p><p>基本政治制度：</p><ol><li>中国共产党领导的多党合作和政治协商制度</li><li>民族区域自治制度</li><li>基层群众自治制度</li></ol></blockquote><h4 id="巩固和发展爱国统一战线-了解"><a href="#巩固和发展爱国统一战线-了解" class="headerlink" title="*巩固和发展爱国统一战线(了解)"></a>*巩固和发展爱国统一战线(了解)</h4><blockquote><ol><li>坚持长期共存、互相监督、肝胆相照、荣辱与共，支持民主党派按照中国特色社会主义参政党要求履行更好的职能</li><li>深化民族团结进步教育，铸牢中华民族共同体意识</li><li>全面贯彻党的宗教工作基本方针，坚持我国宗教的中国化方向，积极引导宗教与社会主义社会相适应</li></ol></blockquote><h4 id="培育和践行社会主义核心价值观-了解"><a href="#培育和践行社会主义核心价值观-了解" class="headerlink" title="培育和践行社会主义核心价值观(了解)"></a>培育和践行社会主义核心价值观(了解)</h4><blockquote><p>富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善</p></blockquote><h4 id="坚定文化自信，建设社会主义文化强国-了解"><a href="#坚定文化自信，建设社会主义文化强国-了解" class="headerlink" title="坚定文化自信，建设社会主义文化强国(了解)"></a>坚定文化自信，建设社会主义文化强国(了解)</h4><blockquote><p>建设社会主义文化强国，必须培养高度的文化自信。坚定文化自信，事关国运兴衰，事关文化安全，事关民族精神的独立性。</p></blockquote><h4 id="提高保障和改善民生水平-了解"><a href="#提高保障和改善民生水平-了解" class="headerlink" title="*提高保障和改善民生水平(了解)"></a>*提高保障和改善民生水平(了解)</h4><blockquote><ol><li>优先发展教育事业</li><li>提高就业质量和人民收入水平</li><li>加强社会保障体系建设</li><li>坚决打赢脱贫攻坚战</li><li>实施健康中国战略</li></ol></blockquote><h4 id="坚持人与自然和谐共生-理解掌握"><a href="#坚持人与自然和谐共生-理解掌握" class="headerlink" title="坚持人与自然和谐共生(理解掌握)"></a>坚持人与自然和谐共生(理解掌握)</h4><blockquote><ol><li><p>生态文明的核心是坚持人与自然的和谐共生</p></li><li><p>顺应自然，是人与自然相处时应遵循的基本原则</p></li><li><p>保护自然，是人与自然相处时应承担的重要责任</p></li></ol></blockquote><h4 id="形成人与自然和谐发展新格局-掌握"><a href="#形成人与自然和谐发展新格局-掌握" class="headerlink" title="形成人与自然和谐发展新格局(掌握)"></a>形成人与自然和谐发展新格局(掌握)</h4><blockquote><ol><li>把节约资源放在首位</li><li>坚持保护优先</li><li>着力推进绿色发展</li><li>形成节约资源和保护环境的空间格局</li></ol></blockquote><hr><h2 id="十一、四个全面-战略布局"><a href="#十一、四个全面-战略布局" class="headerlink" title="十一、四个全面 战略布局"></a>十一、四个全面 战略布局</h2><h4 id="四个全面"><a href="#四个全面" class="headerlink" title="四个全面"></a>四个全面</h4><blockquote><p>全面建成小康社会</p><p>全面深化改革</p><p>全面依法治国</p><p>全面从严治党</p></blockquote><h4 id="全面建成小康社会的内涵-了解"><a href="#全面建成小康社会的内涵-了解" class="headerlink" title="全面建成小康社会的内涵(了解)"></a>全面建成小康社会的内涵(了解)</h4><blockquote><p>全面建成小康社会，更重要、更难做到的是“全面”</p><p>全面小康，覆盖度领域要全面，是“五位一体”</p></blockquote><h4 id="全面深化改革-掌握"><a href="#全面深化改革-掌握" class="headerlink" title="全面深化改革(掌握)"></a>全面深化改革(掌握)</h4><p>原因：</p><blockquote><ol><li>全面深化改革，是顺应当今世界发展大势的必然选择</li><li>全面深化改革，是解决中国现实问题的根本途径</li><li>全面深化改革，关系党和人民事业前途命运，关系党的执政基础和执政地位</li></ol></blockquote><p>怎样做：</p><blockquote><ol><li>必须坚持党对改革的集中统一领导</li><li>必须坚持改革沿着中国特色社会主义方向前进</li><li>必须坚持改革往有利于维护社会主义公平正义、增进人民福祉方向前进</li><li>必须坚持社会主义市场经济改革方向</li></ol></blockquote><h4 id="全面深化改革的总目标和主要内容-了解"><a href="#全面深化改革的总目标和主要内容-了解" class="headerlink" title="全面深化改革的总目标和主要内容(了解)"></a>全面深化改革的总目标和主要内容(了解)</h4><blockquote><p>完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化</p></blockquote><h4 id="正确处理全面深化改革中的重大关系-了解"><a href="#正确处理全面深化改革中的重大关系-了解" class="headerlink" title="*正确处理全面深化改革中的重大关系(了解)"></a>*正确处理全面深化改革中的重大关系(了解)</h4><blockquote><ol><li>处理好解放思想和实事求是的关系</li><li>处理好顶层设计和摸着石头过河的关系</li><li>处理好整体推进和重点突破的关系</li><li>处理好胆子要大、步子要稳的关系</li><li>处理好改革、发展、稳定的关系</li></ol></blockquote><h4 id="全面依法治国-了解"><a href="#全面依法治国-了解" class="headerlink" title="全面依法治国(了解)"></a>全面依法治国(了解)</h4><blockquote><p>法治：治国方式</p><p>法制：法律制度</p><p>法律是治国之重器，良法是善治之前提。全面依法治国是关系党执政兴国、人民幸福安康、党和国家长治久安的重大战略问题，是“四个全面”战略布局的重要组成部分</p></blockquote><h4 id="中国特色社会主义法治道路-掌握"><a href="#中国特色社会主义法治道路-掌握" class="headerlink" title="中国特色社会主义法治道路(掌握)"></a>中国特色社会主义法治道路(掌握)</h4><blockquote><ol><li>坚持中国共产党的领导</li><li>坚持人民在全面依法治国中的主体地位</li><li>坚持法律面前人人平等</li><li>坚持依法治国和以德治国相结合</li><li>坚持从中国实际出发</li></ol></blockquote><h4 id="深化依法治国实践的重点任务-了解"><a href="#深化依法治国实践的重点任务-了解" class="headerlink" title="深化依法治国实践的重点任务(了解)"></a>深化依法治国实践的重点任务(了解)</h4><blockquote><p>总目标是建设中国特色社会主义法制体系，建设社会主义法治国家</p></blockquote><h4 id="新时代党的建设总要求-了解"><a href="#新时代党的建设总要求-了解" class="headerlink" title="新时代党的建设总要求(了解)"></a>新时代党的建设总要求(了解)</h4><blockquote><ol><li><strong>”坚持党要管党、全面从严治党“</strong>是新时代党的建设的<strong>根本方针</strong></li><li>”把党建设成为始终走在时代前列、人民衷心拥护、用于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党“是新时代党的<strong>建设目标*</strong></li></ol></blockquote><h4 id="把党的建设摆在首位-了解"><a href="#把党的建设摆在首位-了解" class="headerlink" title="把党的建设摆在首位(了解)"></a>把党的建设摆在首位(了解)</h4><blockquote><ol><li><strong>旗帜鲜明讲政治</strong>是我们党作为马克思主义政党的根本要求</li><li><strong>党的政治建设</strong>是<strong>党的根本性建设</strong></li><li>抓住当的政治建设是党的十八大以来全面从严治党的成功经验</li></ol></blockquote><h4 id="全面从严治党永远在路上-了解"><a href="#全面从严治党永远在路上-了解" class="headerlink" title="全面从严治党永远在路上(了解)"></a>全面从严治党永远在路上(了解)</h4><blockquote><ol><li>加强党的思想建设。思想建设是党的基础性建设</li><li>加强党的组织建设。党的组织建设主要包括民主集中制度建设，党的基层组织建设、干部队伍建设和党员队伍建设等内容</li><li>持之以恒正风肃纪</li><li>将制度建设贯穿党的各项建设中</li><li>深化标本兼治</li></ol></blockquote><hr><h2 id="十三、中国特色大国外交-重点"><a href="#十三、中国特色大国外交-重点" class="headerlink" title="十三、中国特色大国外交(重点)"></a>十三、中国特色大国外交(重点)</h2><h4 id="推动建立新型国际关系-掌握"><a href="#推动建立新型国际关系-掌握" class="headerlink" title="推动建立新型国际关系(掌握)"></a>推动建立新型国际关系(掌握)</h4><blockquote><ol><li>推进建立新型国际关系，要坚决维护国家核心利益</li><li>要在和平共处五项原则基础上发展同世界各国友好合作</li><li>要积极参与全球治理体系改革和建设</li><li>要加强涉外法律工作，完善涉外法律法律工作，完善涉外法律法规体系</li><li>要把相互尊重、公平正义、合作共赢理念体现到对外合作的方方面面，推动构建人类命运共同体</li></ol></blockquote><h4 id="构建人类命运共同体思想的内涵-理解"><a href="#构建人类命运共同体思想的内涵-理解" class="headerlink" title="构建人类命运共同体思想的内涵(理解)"></a>构建人类命运共同体思想的内涵(理解)</h4><blockquote><p><strong>核心</strong>：“建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界”</p><ol><li>政治上，要相互尊重、平等协商，坚决摒弃冷战思维和强权政治，走对话而不对抗、结伴而不结盟的国与国交往新路</li><li>安全上，坚持以对话解决争端、以协商化解分歧，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义</li><li>经济上，同舟共济，促进贸易和投资自由化便利化，推动经济全球化朝着更开放、包容、惠普、平衡、共赢的方向发展</li><li>文化上，尊重世界文明多样性，以文明交流超越文明隔阂、文明互鉴超越文明冲突、文明共存超越文明优越</li><li>生态上，坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园</li></ol></blockquote><hr><h2 id="十四、坚持和加强党的领导"><a href="#十四、坚持和加强党的领导" class="headerlink" title="十四、坚持和加强党的领导"></a>十四、坚持和加强党的领导</h2><h4 id="中国特色社会主义最本质的特征-了解"><a href="#中国特色社会主义最本质的特征-了解" class="headerlink" title="中国特色社会主义最本质的特征(了解)"></a>中国特色社会主义最本质的特征(了解)</h4><blockquote><p>一. 党的领导是<strong>中国特色社会主义最本质的特征</strong></p><ol><li>这是由科学社会主义的理论逻辑所决定的</li><li>这是由中国特色社会主义产生于发展的历史逻辑所决定的</li><li>这是由中国特色社会主义迈向新征程的实践逻辑所决定的</li></ol><p>二.党的领导是<strong>中国特色社会主义制度最大优势</strong></p><ol><li>中国特色社会主义制度是党领导人民创建的</li><li>党的领导是充分发挥中国特色社会主义制度优势的根本保障</li><li>党的自身优势是中国特色社会主义制度优势的主要来源</li></ol></blockquote><h4 id="新时代中国共产党的历史使命-理解"><a href="#新时代中国共产党的历史使命-理解" class="headerlink" title="新时代中国共产党的历史使命(理解)"></a>新时代中国共产党的历史使命(理解)</h4><blockquote><p>新时代中国共产党的历史使命，就是统揽伟大斗争、伟大工程、伟大事业、伟大梦想，在全面建成小康社会的基础上全面建成社会主义现代化强国，实现中华民族伟大复兴的中国梦。</p><ol><li>实现伟大梦想，必须进行具有许多新的历史特点的伟大斗争</li><li>实现伟大梦想，必须深入推进党的建设新的伟大工程</li><li>必须推进中国特色社会主义伟大事业</li></ol><p>伟大斗争、伟大工程、伟大事业、伟大梦想是一个紧密联系、相互贯通、相互作用、有机统一的整体。</p><ul><li><strong>伟大梦想</strong>是目标，指引前进方向</li><li><strong>伟大斗争</strong> 是手段，激发前进动力</li><li><strong>伟大工程</strong>是保障，提供前进保障</li><li><strong>伟大事业</strong> 是主题，开辟前进道路</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>马克思主义基本原理</title>
    <link href="/2018/12/06/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2018/12/06/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h3 id="零、绪论"><a href="#零、绪论" class="headerlink" title="零、绪论"></a>零、绪论</h3><h4 id="什么是马克思主义"><a href="#什么是马克思主义" class="headerlink" title="什么是马克思主义"></a>什么是马克思主义</h4><h5 id="创造者"><a href="#创造者" class="headerlink" title="创造者"></a>创造者</h5><blockquote><p>马克思主义是由马克思、恩格斯创立，由其后各个时代、各个民族的马克思主义者不断丰富和发展的观点和学说的理论体系。</p></blockquote><h5 id="科学内容"><a href="#科学内容" class="headerlink" title="科学内容"></a>科学内容</h5><blockquote><ul><li>是关于自然、社会和人类思维发展的普遍规律的学说。</li><li>是关于社会主义必然代替资本主义、最终实现社会主义的学说。</li></ul></blockquote><h5 id="价值立场"><a href="#价值立场" class="headerlink" title="价值立场"></a>价值立场</h5><blockquote><ul><li>是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说。</li><li>是指引人民创造美好生活的行动指南。 </li></ul></blockquote><h4 id="马克思主义基本原理"><a href="#马克思主义基本原理" class="headerlink" title="马克思主义基本原理"></a>马克思主义基本原理</h4><h5 id="基本立场"><a href="#基本立场" class="headerlink" title="基本立场"></a>基本立场</h5><blockquote><p>以无产阶级的解放和全人类的解放为己任，以人的自由全面发展为美好目标，以人民为中心，一切为了人民，一切依靠人民。</p></blockquote><h5 id="基本观点"><a href="#基本观点" class="headerlink" title="基本观点"></a>基本观点</h5><blockquote><p>是关于自然、社会和人类思维发展一般规律科学认识，是对人类思想成果和社会实践的科学总结。</p></blockquote><h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><blockquote><ul><li>建立在辩证唯物主义和历史唯物主义世界观基础上的思想方法和工作方法</li><li>实事求是的方法</li><li>辩证分析法</li><li>社会基本矛盾和主要矛盾分析法</li><li>历史分析法</li><li>阶级分析的方法</li><li>群众路线的方法</li></ul></blockquote><h4 id="马克思主义产生的条件"><a href="#马克思主义产生的条件" class="headerlink" title="马克思主义产生的条件"></a>马克思主义产生的条件</h4><blockquote><p>（历史条件、理论、自然科学前提、理论来源）</p><p>马克思主义是时代的产物</p><ul><li>社会经济基础<ul><li>资产阶级革命和工业革命推动了社会生产力的大发展，资本主义社会阶级矛盾尖锐</li></ul></li><li>阶级基础<ul><li>工人阶级逐渐登上了历史的舞台，阶级斗争 从自发到自觉阶段                                                           </li></ul></li><li>科学基础<ul><li>19世纪自然科学领域取得了三大成果：<ul><li>细胞学说</li><li>能量转换与守恒定律</li><li>生物进化论</li></ul></li></ul></li><li>理论依据<ul><li>哲学，特别是德国古典哲学，是其直接理论来源，为他们 对现实问题的思考提供了最早的方法论。</li><li>政治经济学是英国经验主义文化的渗透，使得马克思主义成为科学和价值理论的统一。 </li></ul></li></ul></blockquote><h4 id="马克思主义的发展"><a href="#马克思主义的发展" class="headerlink" title="马克思主义的发展"></a>马克思主义的发展</h4><ol><li>马克思恩格斯阶段                            <blockquote><ul><li><code>马克思主义的创立时期，形成了唯物史观和剩余价值理论。</code></li><li>共产党宣言》:唯物史观形成，马克思主义诞生的标志。      </li><li>1867年《资本论》第一卷出版，剩余价值学说成熟。 </li><li>1875年《哥达纲领批判》、1880年《社 会主义从空想到科学的发展》，科学社会主义的完整形成。</li></ul></blockquote></li><li><p>列宁和斯大林阶段</p><blockquote><ul><li><code>马克思主义的发展阶段，着重发展了无产阶级革命和解放的学说。</code></li><li>揭示了帝国主义经济政治发展不平衡的规律， 突破了多国同时胜利论，创立了社会主义可以在一国首先取得胜利的理论 </li></ul></blockquote></li><li><p>马克思主义中国化阶段</p><blockquote><ul><li><code>马克思主义的一般理论与中国具体实际相结合的过程。</code></li><li>毛泽东思想<ul><li>把马克思主义普遍原理与中国革命实际相结合，走农村包围城市的革命道路，确立了以新民主主义革命的理论为核心的毛泽东思想，建立了中华人民共和国。</li></ul></li><li>邓小平理论<ul><li>世界格局和时代主题的变化，在“结合”中实现了第二次飞跃，产生了邓小平理论，带领我们走中国特色社会主义道路，取得了重大胜利。</li></ul></li><li>“三个代表”重要思想<ul><li>中国共产党带领中国人民坚持解放思想、实事求是、与时俱进，开创了中国特色社会主义事业的新局面</li></ul></li><li>科学发展观<ul><li>进一步指明了中国现代化建设的发展道路、发展模式和发展战略，是马克思主义的世界观和方法论在发展问题上的集中体现。 </li></ul></li></ul></blockquote></li></ol><h4 id="马克思主义的特征"><a href="#马克思主义的特征" class="headerlink" title="马克思主义的特征"></a>马克思主义的特征</h4><blockquote><ol><li>科学性：马克思主义是对自然、社会和人类思维发展的本质和规律的正确反映。</li><li>革命性：表现在它的彻底的批判精神和鲜明的无产阶级立场。</li><li>实践性：马克思主义是从实践中来，到实践中去，在实践中接受检验，并随实践不断发展的学说。</li><li>人民性：人民至上是马克思主义的政治立场，一切奋斗都致力于实现最广大人民的根本利益。</li><li>发展性：马克思主义是不断发展的学说，具有与时俱进的品质。</li></ol></blockquote><h4 id="为什么要学习马克思主义和如何学习马克思主义"><a href="#为什么要学习马克思主义和如何学习马克思主义" class="headerlink" title="为什么要学习马克思主义和如何学习马克思主义"></a>为什么要学习马克思主义和如何学习马克思主义</h4><blockquote><ul><li>观察当代世界变化的认识工具</li><li>指引当代中国发展的行动指南</li><li>引领人类社会进步的科学真理</li></ul></blockquote><h5 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h5><blockquote><ul><li>努力学习和掌握马克思主义的基本立场、观点、方法。</li><li>坚持理论联系实际的马克思主义学风。</li><li>自觉将马克思主义内化于心、外化于行。</li></ul></blockquote><hr><h3 id="一、世界的物质性及发展规律"><a href="#一、世界的物质性及发展规律" class="headerlink" title="一、世界的物质性及发展规律"></a>一、世界的物质性及发展规律</h3><h4 id="世界观、哲学以及哲学的基本问题"><a href="#世界观、哲学以及哲学的基本问题" class="headerlink" title="世界观、哲学以及哲学的基本问题"></a>世界观、哲学以及哲学的基本问题</h4><h5 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h5><blockquote><ul><li>哲学是关于世界观的学问，是系统化、 理论化的世界观</li><li>哲学是自然知识、社会知识和思维知识 的概括和总结</li><li>哲学是关于整个世界最普遍本质和规律 的学科</li><li>哲学既是世界观又是方法论。</li></ul></blockquote><h5 id="哲学基本问题"><a href="#哲学基本问题" class="headerlink" title="哲学基本问题"></a>哲学基本问题</h5><blockquote><ul><li>思维和存在的关系问题<ul><li>思维和存在谁是世界的本原</li><li>思维能否反映存在，世界是否统一</li></ul></li></ul></blockquote><h4 id="什么是物质、意识"><a href="#什么是物质、意识" class="headerlink" title="什么是物质、意识"></a>什么是物质、意识</h4><blockquote><p>物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映</p></blockquote><h5 id="意识"><a href="#意识" class="headerlink" title="意识"></a>意识</h5><blockquote><p>意识是人脑的机能， 是客观世界的主观映像</p><ul><li><p>意识在内容上是客观的，在形式上是主观的; 意识是物质的产物， 但又不是物质本身</p></li><li><p>意识物质世界长期发展的产物</p></li><li><p>意识是社会的产物</p></li></ul></blockquote><h4 id="世界的物质统一性"><a href="#世界的物质统一性" class="headerlink" title="世界的物质统一性"></a>世界的物质统一性</h4><blockquote><ul><li><p>意识统一于物质</p></li><li><p>人类社会也统一于物质</p><ul><li>人类社会是物质世界的组成部分</li><li>人类获取生活资料活动是物质性的活动</li><li>人类社会存在和发展的基础是物质资料的生产方式</li></ul></li></ul></blockquote><h4 id="物质与运动、相对静止"><a href="#物质与运动、相对静止" class="headerlink" title="物质与运动、相对静止"></a>物质与运动、相对静止</h4><h5 id="运动的定义"><a href="#运动的定义" class="headerlink" title="运动的定义"></a>运动的定义</h5><blockquote><p>运动，就是最一般意义、存在方式，物质的固有属性来说，它包括宇宙中发生的一切变化和过程，从单纯的位置移动起直到思维。</p><ul><li><p>运动绝对，静止相对</p></li><li><p>静止是事物存在和发展的必要条件，是人们认识事物的必要前提，是测量和计算运动的尺度</p></li></ul></blockquote><h4 id="物质运动与时间空间、时间与空间的特性"><a href="#物质运动与时间空间、时间与空间的特性" class="headerlink" title="物质运动与时间空间、时间与空间的特性"></a>物质运动与时间空间、时间与空间的特性</h4><p>时间:     物质运动的持续性、顺序性 </p><blockquote><ul><li>所谓持续性，是指任何一个物体的运动都要经历一 个或长或短的过程。  </li><li>所谓顺序性，是指不同事物之间运动过程的出现有 一个先后顺序关系。 </li><li>时间的特性是一维性，即时间只有一个方向，具有不可逆性。</li></ul></blockquote><p>空间:    运动着的物质的广延性或伸张性，指物体的位置、规模和体积</p><blockquote><ul><li>三维性</li></ul></blockquote><h4 id="社会生活在本质上是实践的"><a href="#社会生活在本质上是实践的" class="headerlink" title="社会生活在本质上是实践的"></a>社会生活在本质上是实践的</h4><h5 id="实践的基本特点："><a href="#实践的基本特点：" class="headerlink" title="实践的基本特点："></a>实践的基本特点：</h5><blockquote><ol><li>客观性</li><li>自觉能动性</li><li>社会历史性</li></ol></blockquote><h5 id="社会生活在本质上是实践的："><a href="#社会生活在本质上是实践的：" class="headerlink" title="社会生活在本质上是实践的："></a>社会生活在本质上是实践的：</h5><blockquote><ul><li>实践是社会关系形成的基础</li><li>实践形成了社会生活的基本领域</li><li>实践是人类社会发展的动力源泉   </li></ul></blockquote><h4 id="客观规律性和主观能动性、意识的能动作用"><a href="#客观规律性和主观能动性、意识的能动作用" class="headerlink" title="客观规律性和主观能动性、意识的能动作用"></a>客观规律性和主观能动性、意识的能动作用</h4><h5 id="主观能动性和客观规律的统一"><a href="#主观能动性和客观规律的统一" class="headerlink" title="主观能动性和客观规律的统一"></a>主观能动性和客观规律的统一</h5><blockquote><ul><li>尊重客观规律是正确发挥主观能动性的前提</li><li>只有充分发挥主观能动性，才能正确认识和利用客观规律</li><li>从实际出发是正确发挥人的主观能动性的前提。</li><li>实践是正确发挥人的主观能动性的基本途径。</li><li>发挥人的主观能动性，还需依赖一定的物质条件和物质手段。</li></ul></blockquote><h5 id="意识对物质具有反作用"><a href="#意识对物质具有反作用" class="headerlink" title="意识对物质具有反作用"></a>意识对物质具有反作用</h5><blockquote><ul><li>意识活动的目的性和计划性</li><li>意识活动的能动创造性</li><li>意识活动指导实践，改造世界</li><li>意识活动具有指导、控制人的行为和生理活动的作用。                                                             </li></ul></blockquote><hr><h3 id="二、辩证法"><a href="#二、辩证法" class="headerlink" title="二、辩证法"></a>二、辩证法</h3><h4 id="形而上"><a href="#形而上" class="headerlink" title="*形而上"></a>*形而上</h4><blockquote><p>在绝对不相容的对立中的思维(是非分明)</p></blockquote><h4 id="联系及其特性"><a href="#联系及其特性" class="headerlink" title="联系及其特性"></a>联系及其特性</h4><blockquote><p>联系是事物或现象之间 及其内部诸要素之间相 互作用、相互影响和相互制约的种种关系</p><ul><li>客观性</li><li>普遍性</li><li>多样性</li><li>条件性</li></ul><p>联系的哲学意义：</p><ul><li>任何事物都不是孤立存在的</li><li>一切以条件、地点和时间为转移</li></ul></blockquote><h4 id="发展的实质"><a href="#发展的实质" class="headerlink" title="发展的实质"></a>发展的实质</h4><blockquote><p>发展:前进的上升的运动，是由一种质态向另一种质态的飞跃。</p><p>实质:新事物的产生和旧事物的灭亡</p><ul><li>新事物：合乎历史前进方向，具有远大前途的东西</li><li>旧事物：丧失历史必然性，日趋灭亡的东西</li></ul></blockquote><h4 id="辩证法三大规律"><a href="#辩证法三大规律" class="headerlink" title="辩证法三大规律"></a>辩证法三大规律</h4><blockquote><ol><li>对立统一规律：唯物辩证法的实质和核心<ul><li>揭示了事物联系的根本内容和发展动力，从根本上回答了事物为什么发展的问题</li><li>贯穿唯物辩证法其他规律和范畴的中心线索，是理解其它规律的要素</li><li>还是人们认识世界改造世界的根本方法：矛盾分析法</li></ul></li><li>质量互变规律</li><li>否定之否定规律</li></ol></blockquote><h4 id="矛盾同一性和斗争性及其关系、方法论意义，矛盾同一性和斗争性在事物发展中的作用"><a href="#矛盾同一性和斗争性及其关系、方法论意义，矛盾同一性和斗争性在事物发展中的作用" class="headerlink" title="矛盾同一性和斗争性及其关系、方法论意义，矛盾同一性和斗争性在事物发展中的作用"></a>矛盾同一性和斗争性及其关系、方法论意义，矛盾同一性和斗争性在事物发展中的作用</h4><h5 id="矛盾及其属性"><a href="#矛盾及其属性" class="headerlink" title="矛盾及其属性"></a>矛盾及其属性</h5><blockquote><p>事物之间或事物内部各要素之间的既对立 又统一的关系 </p><ul><li>同一性(相对/有条件)：矛盾双方相互依存、相互贯通、相互作用的性质和趋势</li><li><p>斗争性(绝对/无条件)：矛盾双方的相互排斥、相互冲突、相互否定、相互分离的性质和趋势 </p></li><li><p>矛盾的同一性和斗争性是相互统一又相互联系的</p></li></ul></blockquote><h5 id="矛盾在事物发展中的作用"><a href="#矛盾在事物发展中的作用" class="headerlink" title="矛盾在事物发展中的作用"></a>矛盾在事物发展中的作用</h5><blockquote><ul><li>矛盾双方的相互依存是事物存在的前提</li><li>矛盾双方相互吸收有利于自身的因素得到发展</li><li>矛盾双方的相互贯通规定事物发展的基本趋势</li><li>矛盾的斗争性促使矛盾双方的力量消长，推动事物不断地量变</li><li>矛盾的斗争性引起矛盾双方的转化，推动事物发生质变</li></ul></blockquote><h4 id="矛盾的普遍性特殊性"><a href="#矛盾的普遍性特殊性" class="headerlink" title="矛盾的普遍性特殊性"></a>矛盾的普遍性特殊性</h4><h5 id="普遍性"><a href="#普遍性" class="headerlink" title="普遍性"></a>普遍性</h5><blockquote><ul><li>其一，矛盾存在于一切事物的发展过程中，即事事有矛盾</li><li>其二，每一事物的发展过程中存在着自始至终的矛盾运动，即时时有矛盾</li></ul></blockquote><h5 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h5><blockquote><ul><li>不同事物的矛盾各有其特点。客观物质世界矛盾运动形式是无限多样的，因而不同事物的矛盾各有其特殊性</li><li>同一事物的矛盾在发展的不同过程个阶段上各有不同的特点</li><li>是构成事物的诸多矛盾以及每一矛盾的不同方面各有不同的性质。即矛盾地位的特殊性</li></ul></blockquote><h4 id="矛盾的普遍性特殊性的辩证关系及方法论意义"><a href="#矛盾的普遍性特殊性的辩证关系及方法论意义" class="headerlink" title="矛盾的普遍性特殊性的辩证关系及方法论意义"></a>矛盾的普遍性特殊性的辩证关系及方法论意义</h4><blockquote><ul><li><p>矛盾的普遍性即矛盾是<code>共性</code>，矛盾的特殊性即矛盾的<code>个性</code>。矛盾共性是无条件的绝对的，矛盾特殊性是有条件的相对的</p></li><li><p>任何事物都是共性和个性的统一体，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性。</p></li></ul></blockquote><h4 id="主要矛盾和非主要矛盾、矛盾主要方面和非主要方面"><a href="#主要矛盾和非主要矛盾、矛盾主要方面和非主要方面" class="headerlink" title="主要矛盾和非主要矛盾、矛盾主要方面和非主要方面"></a>主要矛盾和非主要矛盾、矛盾主要方面和非主要方面</h4><h4 id="对事物发展的不同阶段而言："><a href="#对事物发展的不同阶段而言：" class="headerlink" title="对事物发展的不同阶段而言："></a>对事物发展的不同阶段而言：</h4><h5 id="主要矛盾"><a href="#主要矛盾" class="headerlink" title="主要矛盾"></a>主要矛盾</h5><blockquote><p>处于支配地位的、对事物的发展起决定作用的矛盾，由于它的存在和发展，规定和影响着其它矛盾的存在和发展</p></blockquote><h5 id="非主要矛盾"><a href="#非主要矛盾" class="headerlink" title="非主要矛盾"></a>非主要矛盾</h5><blockquote><p>是处于从属地位、对事物的发展不起决定作用的矛盾。      </p></blockquote><h4 id="对每一矛盾内部的对立双方而言"><a href="#对每一矛盾内部的对立双方而言" class="headerlink" title="对每一矛盾内部的对立双方而言"></a>对每一矛盾内部的对立双方而言</h4><p>矛盾的主要方面：矛盾双方中起着主导作用，规定事物的性质<br>&gt;<br>矛盾的次要方面： 矛盾双方中处于被支配地位的方面</p><h4 id="量变与质变及其关系"><a href="#量变与质变及其关系" class="headerlink" title="量变与质变及其关系"></a>量变与质变及其关系</h4><blockquote><p>质：事物区别于其他事物的内在规定性</p><p>量：事物的规模等关系表现的外在规定性</p><p>度：保持物质稳定的数量界限</p><p>质变：物质根本性质的变化</p><p>量变：事物数量及组成在空间上的变化</p></blockquote><h5 id="量变和质变的辩证关系"><a href="#量变和质变的辩证关系" class="headerlink" title="量变和质变的辩证关系"></a>量变和质变的辩证关系</h5><blockquote><ul><li>量变是质变的必要准备</li><li>质变巩固量变的成果并为新量变开辟新量变开辟新的道路</li><li>量变和质变相互渗透</li></ul></blockquote><h4 id="辩证的否定及其方法论意义"><a href="#辩证的否定及其方法论意义" class="headerlink" title="辩证的否定及其方法论意义"></a>辩证的否定及其方法论意义</h4><blockquote><p>否定之否定揭示了事物发展前进性和曲折性的统一</p><p>肯定是指事物保持自身存在的因素</p><p>否定是指事物自身趋向灭亡、并转化为他事物的因素</p></blockquote><h4 id="辩证的否定"><a href="#辩证的否定" class="headerlink" title="辩证的否定"></a>辩证的否定</h4><blockquote><ul><li>辩证的否定是事物的自我否定</li><li>辩证的否定是事物发展的环节</li><li>辩证的否定是事物联系的环节</li><li>辩证否定的实质是扬弃 </li></ul></blockquote><h4 id="客观辩证法和主观辩证法"><a href="#客观辩证法和主观辩证法" class="headerlink" title="客观辩证法和主观辩证法"></a>客观辩证法和主观辩证法</h4><h5 id="客观辩证法"><a href="#客观辩证法" class="headerlink" title="客观辩证法"></a>客观辩证法</h5><blockquote><p>是指客观事物或客观存在的辩证法，即客观事物及其相互作用、相互联系的形式呈现出的各种物质形态的辩证运动和发展规律</p></blockquote><h5 id="主观辩证法"><a href="#主观辩证法" class="headerlink" title="主观辩证法"></a>主观辩证法</h5><blockquote><p>是指人类认识和思维运动的辩证法。即以概念作为思维细胞的辩证思维运动和发展的规律</p></blockquote><h4 id="唯物辩证法的五对基本范畴"><a href="#唯物辩证法的五对基本范畴" class="headerlink" title="唯物辩证法的五对基本范畴"></a>唯物辩证法的五对基本范畴</h4><blockquote><ul><li>原因与结果：客观性、本质性、先后性</li><li>可能性与现实性<ul><li>凡是现实的都是合必然性之理的， 凡是合必然性之理的都是现实的 </li><li>可能性从内部而言，是由必然性所决定的，从外部而言，又受偶然性制约 </li></ul></li><li>内容与形式</li><li>现象与本质</li><li>必然性与偶然性<ul><li>必然性体现事物发展过程中确定不移的趋势 </li><li>偶然性体现事物发展过程中不确定的趋势</li></ul></li></ul></blockquote><hr><h3 id="三、真理与价值"><a href="#三、真理与价值" class="headerlink" title="三、真理与价值"></a>三、真理与价值</h3><h4 id="实践与认识的关系"><a href="#实践与认识的关系" class="headerlink" title="实践与认识的关系"></a>实践与认识的关系</h4><blockquote><p>实践是认识的基础，认识从实践产生，为实践服务，随实践发展，受实践检验</p><ul><li>实践产生了认识需要</li><li>实践为认识提供了可能</li><li>实践使得认识得以产生和发展</li><li>实践是检验真理的唯一标准，一切真知都来自于实践</li></ul></blockquote><h4 id="认识的本质和发展规律"><a href="#认识的本质和发展规律" class="headerlink" title="认识的本质和发展规律"></a>认识的本质和发展规律</h4><h5 id="认识的本质"><a href="#认识的本质" class="headerlink" title="认识的本质"></a>认识的本质</h5><blockquote><p>主体对客体的能动反映</p><ul><li>主体：有思维能力，从事社会实践和认识活动的人</li><li>客体：实践和认识活动所指向的对象</li><li>中介：各种形式的工具、手段以及运用、操作这些工具的程序和方法</li></ul></blockquote><h5 id="认识运动的基本规律"><a href="#认识运动的基本规律" class="headerlink" title="认识运动的基本规律"></a>认识运动的基本规律</h5><blockquote><p>实践、认识、再实践、再认识，这种形式，循环往复以至无穷，而实践和认识之每循环的内容，都比较地进到了高一级的程度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs flow">st&#x3D;&gt;operation: 实践<br>op1&#x3D;&gt;operation: 认识<br>op2&#x3D;&gt;operation: 实践<br><br>st-&gt;op1-&gt;op2<br>op2-&gt;op1<br><br></code></pre></td></tr></table></figure></blockquote><h4 id="感性认识和理性认识"><a href="#感性认识和理性认识" class="headerlink" title="感性认识和理性认识"></a>感性认识和理性认识</h4><h5 id="感性认识"><a href="#感性认识" class="headerlink" title="感性认识"></a>感性认识</h5><blockquote><p>是客观事物作用于人的感官而 引起的一种最简单的反映形式，是对客观事物表面的个别属性、个别特征的反映</p></blockquote><h5 id="理性认识"><a href="#理性认识" class="headerlink" title="理性认识"></a>理性认识</h5><blockquote><p>是对同类事物共同的一般特性和本质属性的概括的反映 </p></blockquote><h4 id="真理及其客观性"><a href="#真理及其客观性" class="headerlink" title="真理及其客观性"></a>真理及其客观性</h4><h5 id="真理的含义"><a href="#真理的含义" class="headerlink" title="真理的含义"></a>真理的含义</h5><blockquote><p>真理是标志主观与客观相符合的哲学范畴，是人们对客观事物及其规律的正确反映</p></blockquote><h5 id="真理的客观性"><a href="#真理的客观性" class="headerlink" title="真理的客观性"></a>真理的客观性</h5><blockquote><ul><li>真理的内容是客观的</li><li>检验真理的标准是客观的</li></ul></blockquote><h4 id="真理的绝对性和相对性"><a href="#真理的绝对性和相对性" class="headerlink" title="真理的绝对性和相对性"></a>真理的绝对性和相对性</h4><h5 id="真理的绝对性"><a href="#真理的绝对性" class="headerlink" title="真理的绝对性"></a>真理的绝对性</h5><blockquote><p>真理的绝对性是指人们对客观事物及其规律的正确认识具有确定性、无条件性 </p><ul><li>任何真理都包含着同客观对象相符合的客观内容，这是无条件的、绝对的</li><li>人类按其认识本性能够正确认识无限发展的客观世界，这是无条件的、 绝对的</li></ul></blockquote><h5 id="真理的相对性"><a href="#真理的相对性" class="headerlink" title="真理的相对性"></a>真理的相对性</h5><blockquote><ul><li>从认识广度看，任何真理都是对物质世界发展的某一阶段、某一部分的正确认识</li><li>从认识的深度看，任何真理都是对物质世界的某一层次、某一方面的认识</li></ul></blockquote><h5 id="真理的绝对性和相对性的辩证关系"><a href="#真理的绝对性和相对性的辩证关系" class="headerlink" title="真理的绝对性和相对性的辩证关系"></a>真理的绝对性和相对性的辩证关系</h5><blockquote><p>对立:真理的绝对性和相对性是任何一个真理的两个不同的属性，绝对性主要是指真理的客观性，相对性主要是指真理的条件性<br>统一:两者相互渗透、相互包含;相对真理不断向绝对真理转化<br>意义:坚持真理观上的辩证法，反对绝对主义和相对主义; 确立对待马克思主义的科学态度                     </p></blockquote><h4 id="真理的检验标准"><a href="#真理的检验标准" class="headerlink" title="真理的检验标准"></a>真理的检验标准</h4><blockquote><p>实践是检验真理的唯一标准 </p></blockquote><h4 id="真理和价值的关系"><a href="#真理和价值的关系" class="headerlink" title="真理和价值的关系"></a>真理和价值的关系</h4><h5 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h5><blockquote><p>揭示外部世界对于满足人的需要的意义的哲学范畴，指具 有特定属性的客体对于主体需要的意义，即客体的积极作用</p><p>价值和真理在实践中辩证统一</p><ul><li>成功的实践必然以真理和价值的辩证统一为前提</li><li>价值的形成和实现以坚持真理为前提，而真理又必 然具有价值</li><li>真理和价值在实践和认识活动中相互制约、相互引导、相互促进</li></ul></blockquote><hr><h3 id="四、社会历史的本质与规律与社会发展动力系统"><a href="#四、社会历史的本质与规律与社会发展动力系统" class="headerlink" title="四、社会历史的本质与规律与社会发展动力系统"></a>四、社会历史的本质与规律与社会发展动力系统</h3><h4 id="历史"><a href="#历史" class="headerlink" title="*历史"></a>*历史</h4><blockquote><ul><li>人与自然之间物质交换的过程</li><li>人类社会发展的历史就是资料生产的历史</li><li>历史也是一步思想史的展开和延续</li></ul></blockquote><h4 id="物质资料的生产方式是人类社会发展的决定力量"><a href="#物质资料的生产方式是人类社会发展的决定力量" class="headerlink" title="物质资料的生产方式是人类社会发展的决定力量"></a>物质资料的生产方式是人类社会发展的决定力量</h4><blockquote><p>​    </p></blockquote><h4 id="社会存在和社会意识的辩证关系"><a href="#社会存在和社会意识的辩证关系" class="headerlink" title="社会存在和社会意识的辩证关系"></a>社会存在和社会意识的辩证关系</h4><h5 id="社会存在"><a href="#社会存在" class="headerlink" title="社会存在"></a>社会存在</h5><blockquote><p>社会生活的物质方面，主要指物质生活资料的生产方式，也包括地理环境和人口因素</p></blockquote><h5 id="社会意识"><a href="#社会意识" class="headerlink" title="社会意识"></a>社会意识</h5><blockquote><p>社会生活的精神方面</p></blockquote><h5 id="社会存在和社会意识的辩证关系-1"><a href="#社会存在和社会意识的辩证关系-1" class="headerlink" title="社会存在和社会意识的辩证关系"></a>社会存在和社会意识的辩证关系</h5><blockquote><ul><li><p>社会存在决定社会意识</p><ul><li>社会存在决定社会意识的客观内容</li><li>社会存在的发展变化，决定社会意识的发展变化</li></ul></li><li><p>社会意识具有相对独立性</p><ul><li>社会意识与社会存在发展的不平衡性</li><li>社会意识在自身的发展中具有历史继承性</li><li>社会意识各种形式之间相互影响和相互作用</li><li>社会意识对社会存在具有能动的反作用</li></ul></li></ul></blockquote><h5 id="社会存在和社会意识的辩证关系原理的意义"><a href="#社会存在和社会意识的辩证关系原理的意义" class="headerlink" title="社会存在和社会意识的辩证关系原理的意义"></a>社会存在和社会意识的辩证关系原理的意义</h5><blockquote><ul><li>第一次正确解决了社会历史观的基本问题，是社会历史观革命性变革的基础    </li><li>“两个划分”——从社会生活和各种领域划分出经济领域，从一切社会关系中划分出生产关系</li><li>“两个归结”——将一切社会关系归结于生产关 系，将生产关系归结于生产力发展</li></ul></blockquote><h4 id="社会基本矛盾是社会发展的根本动力，生产力是社会发展的最终的决定力量"><a href="#社会基本矛盾是社会发展的根本动力，生产力是社会发展的最终的决定力量" class="headerlink" title="社会基本矛盾是社会发展的根本动力，生产力是社会发展的最终的决定力量"></a>社会基本矛盾是社会发展的根本动力，生产力是社会发展的最终的决定力量</h4><h5 id="社会基本矛盾"><a href="#社会基本矛盾" class="headerlink" title="社会基本矛盾"></a>社会基本矛盾</h5><blockquote><p>生产力和生产关系、经济基础和上层建筑的矛盾</p></blockquote><h5 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h5><blockquote><p>人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量</p><ul><li>性质：客观现实性、社会历史性</li><li>基本要素：劳动力资料、劳动对象、劳动者</li><li>科学技术是第一生产力</li></ul></blockquote><h5 id="生产关系"><a href="#生产关系" class="headerlink" title="生产关系"></a>生产关系</h5><blockquote><p>人们在物质生产过程中形成的不以人的意志为转移的经济关系</p></blockquote><h4 id="生产力是社会发展的决定性力量"><a href="#生产力是社会发展的决定性力量" class="headerlink" title="生产力是社会发展的决定性力量"></a>生产力是社会发展的决定性力量</h4><blockquote><ul><li>生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量</li><li>社会基本矛盾特别是生产力和生产关系的矛盾，是“一切历史冲突的根源”，决定着社会中其他矛盾的存在和发展</li><li>社会基本矛盾具有不同的表现形式和解决方 式，并从根本上影响和促进社会形态的变化和发展</li></ul></blockquote><h4 id="生产力和生产关系矛盾运动的规律"><a href="#生产力和生产关系矛盾运动的规律" class="headerlink" title="生产力和生产关系矛盾运动的规律"></a>生产力和生产关系矛盾运动的规律</h4><blockquote><ol><li>生产力决定生产关系<ul><li>生产力状况决定生产关系的性质</li><li>生产力的发展决定生产关系的变革</li></ul></li><li>生产关系对生产力的反作用<ul><li>当生产关系适应生产力状况时，它对生产力的发展起促进作用</li><li>当生产关系不适合生产力状况时，它对生产力的发展起阻碍作用</li></ul></li><li>生产力和生产关系的相互作用构成生产方式的矛盾运动</li></ol></blockquote><h5 id="生产力和生产关系矛盾运动的规律的意义"><a href="#生产力和生产关系矛盾运动的规律的意义" class="headerlink" title="生产力和生产关系矛盾运动的规律的意义"></a>生产力和生产关系矛盾运动的规律的意义</h5><blockquote><ul><li>首先，这一原理在人类思想史上彻底否定了以 “道德说教”作为评判历史功过是非的思想体系， 第一次科学地确立了生产力发展是“社会进步的最 高标准”。</li><li>其次，这一规律是马克思主义政党制定路线、 方针和政策的重要依据</li></ul></blockquote><h4 id="经济基础和上层建筑的矛盾运动规律"><a href="#经济基础和上层建筑的矛盾运动规律" class="headerlink" title="经济基础和上层建筑的矛盾运动规律"></a>经济基础和上层建筑的矛盾运动规律</h4><h5 id="经济基础"><a href="#经济基础" class="headerlink" title="经济基础"></a>经济基础</h5><blockquote><p>由社会一定发展阶段的生产力决定的生产关系总和</p><ul><li>经济基础的实质是社会一定发展阶段的基本经济制度，是制度化的物质社会关系</li><li>经济基础与经济体制具有内在联系</li></ul></blockquote><h5 id="上层建筑"><a href="#上层建筑" class="headerlink" title="上层建筑"></a>上层建筑</h5><blockquote><p>建立在一定经济基础上的意识形态级相应的制度、组织和设施</p></blockquote><pre><code class=" mermaid">graph LRop1((&quot;上层建筑&quot;))--&gt;op2(&quot;意识形态&quot;)op1--&gt;op3(&quot;政治上层建筑&quot;)op2--&gt;op4(&quot;政治、法律思想、道德、艺术、宗教、哲学&quot;)op3--&gt;op5(&quot;政治法律制度及设施，政治组织&quot;)</code></pre><h5 id="矛盾规律"><a href="#矛盾规律" class="headerlink" title="矛盾规律"></a>矛盾规律</h5><blockquote><ul><li>经济基础决定上层建筑</li><li>上层建筑反作用于经济基础</li></ul></blockquote><h4 id="社会形态更替的一般规律"><a href="#社会形态更替的一般规律" class="headerlink" title="社会形态更替的一般规律"></a>社会形态更替的一般规律</h4><p>社会形态：同生产力发展到一定阶段相适应的经济基础与上层建筑的统一体</p><blockquote><ul><li>经济形态</li><li>政治形态</li><li>意识形态</li></ul></blockquote><h5 id="社会形态更替的统一性和多样性"><a href="#社会形态更替的统一性和多样性" class="headerlink" title="社会形态更替的统一性和多样性"></a>社会形态更替的统一性和多样性</h5><blockquote><ul><li><p>统一性</p><ul><li>原始社会 奴隶制社会 封建制社会 资本 主义社会 共产主义社会</li></ul></li><li><p>多样性</p><ul><li>每个国家或民族有其各自的发展历程</li></ul></li></ul><hr><p>社会形态更替的必然性和人们的历史选择性</p><ul><li>社会形态更替的必然性<ul><li>社会形态依次更替的过程和规律是客观的，其发展的基本趋势是确定不移的</li></ul></li><li>人们的历史选择性<ul><li>社会发展的客观必然性为人们的历史 选择提供了基础、范围和可能性空间</li><li>社会形态更替的过程是一个合目的性与合规律性相统一的过程</li><li>人们的历史选择性，归根结底是人民群众的选择性。                                                             </li></ul></li></ul></blockquote><h4 id="历史进步的尺度"><a href="#历史进步的尺度" class="headerlink" title="*历史进步的尺度"></a>*历史进步的尺度</h4><blockquote><ul><li>历史进步的终极尺度是生产力的发展</li><li>历史进步的终极尺度是人的发展</li><li>是生产力发展与人的发展的统一</li></ul></blockquote><h4 id="资本主义发展的三个悖论"><a href="#资本主义发展的三个悖论" class="headerlink" title="*资本主义发展的三个悖论"></a>*资本主义发展的三个悖论</h4><blockquote><ul><li><p>环境悖论</p><ul><li>掠夺更多的自然资源和消费更多的商品成为资本逻辑的两大支点</li><li>通过消费的扩张来保证经济的持续增长，这种消费也就主要不是满足需要的活动，而是变成了对剩余产品的消耗和毁灭活动</li></ul></li><li><p>两级悖论</p><ul><li>贫富两极分化</li></ul></li><li><p>存在悖论</p><ul><li>资产阶级工人存在悖论：物的世界的增值同人的世界的贬值成正比</li></ul></li></ul></blockquote><h4 id="阶级斗争"><a href="#阶级斗争" class="headerlink" title="*阶级斗争"></a>*阶级斗争</h4><blockquote><p>阶级间物质利益根本对立，根源于社会经济关系的冲突，导致阶级间的对立与冲突</p></blockquote><h4 id="科学技术在社会中的作用"><a href="#科学技术在社会中的作用" class="headerlink" title="科学技术在社会中的作用"></a>科学技术在社会中的作用</h4><blockquote><p>科学：反映事物本质及规律的知识体系</p><p>技术：</p><ul><li>广义：为达目的而利用、改造世界的手段方法</li><li>狭义：生产技术，表现为生产过程中对活动的控制操作手段、程序和方法</li></ul><p>科学技术革命是推动经济和社会发展的强大杠杆</p><p>科学技术对社会作用</p><ul><li>科学技术通过促进经济和社会发展造福于人类。大大增强了人类改造自然的能力,它对社会发展的积极作用是主要的、基本的方面 </li><li>另一方面同时也意味着科学技术增强了人类破坏自然的能力，也产生一定的消极后果</li></ul></blockquote><h4 id="人民群众是历史的创造者"><a href="#人民群众是历史的创造者" class="headerlink" title="人民群众是历史的创造者"></a>人民群众是历史的创造者</h4><h5 id="人民群众"><a href="#人民群众" class="headerlink" title="人民群众"></a>人民群众</h5><blockquote><ul><li><p>人民群众是指一切对社会历史发展起推动作用的人们，是社会成员的大多数</p></li><li><p>在阶级社会中，它包括一切对历史发展起着促进作用的阶级、阶层和社会集团</p></li><li><p>人民群众这个概念在不同的国家和各个国家的不同历史时期，有着不同的内容</p></li></ul></blockquote><h5 id="人民群众创造历史的决定作用表现"><a href="#人民群众创造历史的决定作用表现" class="headerlink" title="人民群众创造历史的决定作用表现"></a>人民群众创造历史的决定作用表现</h5><blockquote><ul><li>人民群众是社会物质财富的创造者</li><li>人民群众是社会精神财富的创造者</li><li>人民群众是社会变革的决定性力量</li></ul></blockquote><h5 id="人民群众创造历史的制约条件"><a href="#人民群众创造历史的制约条件" class="headerlink" title="人民群众创造历史的制约条件"></a>人民群众创造历史的制约条件</h5><blockquote><ul><li>客观经济条件：主要指生产力和生产关系</li><li>政治条件：主要指政治和法律制度</li><li>精神条件：主要指传统，既存的各种思想观念、思维习惯、价值观念等</li></ul></blockquote><h4 id="杰出个人的作用"><a href="#杰出个人的作用" class="headerlink" title="杰出个人的作用"></a>杰出个人的作用</h4><blockquote><p>个人是指在社会群体中单个的成员，是社会 的一个“分子”</p><ul><li>普通个人</li><li>历史人物</li><li>杰出人物：反映时代要求、推动历史进步，并在历史进程中留下深刻印记的 正面人物<ul><li>杰出的政治家、军事家、思想家、科学家、艺术家</li></ul></li></ul></blockquote><h4 id="杰出个人作用"><a href="#杰出个人作用" class="headerlink" title="杰出个人作用"></a>杰出个人作用</h4><blockquote><ul><li>进步历史事件当事人和发起者</li><li>实现历史任务的组织者和领导者</li><li>真理的探索者和发现者</li></ul></blockquote><h5 id="历史性人物制约性"><a href="#历史性人物制约性" class="headerlink" title="历史性人物制约性"></a>历史性人物制约性</h5><blockquote><ul><li>时势召唤英雄 </li><li>时势锻炼英雄</li><li>时势筛选英雄</li></ul></blockquote><h4 id="普通个人的作用-平行四边形原理"><a href="#普通个人的作用-平行四边形原理" class="headerlink" title="普通个人的作用(平行四边形原理)"></a>普通个人的作用(平行四边形原理)</h4><blockquote><p>“无数互相交错的力量， 有无数个力的平行四边形，由此就产生出一个 合力，即历史结果”。“每个意志都对合力有所贡献，因而是包括在这个合力里面的</p><ul><li>创造历史的参与者</li><li>杰出人物是普通人发展而来的</li><li>现代普通人可能对历史发生”超常性影响”</li></ul></blockquote><h4 id="唯心史观的局限"><a href="#唯心史观的局限" class="headerlink" title="唯心史观的局限"></a>唯心史观的局限</h4><blockquote><ul><li>考察人们参加历史活动的思想动机，而没有揭示这些思想动机背后的物质动因</li><li>忽视人民群众的作用</li></ul></blockquote><h4 id="评价历史人物"><a href="#评价历史人物" class="headerlink" title="*评价历史人物"></a>*评价历史人物</h4><blockquote><ul><li>历史分析法</li><li>阶级分析法</li></ul></blockquote><h4 id="杰出个人和人民群众作用的关系"><a href="#杰出个人和人民群众作用的关系" class="headerlink" title="杰出个人和人民群众作用的关系"></a>杰出个人和人民群众作用的关系</h4><blockquote><p>​    </p></blockquote><hr><h3 id="五、商品劳动价值论"><a href="#五、商品劳动价值论" class="headerlink" title="五、商品劳动价值论"></a>五、商品劳动价值论</h3><h4 id="自然经济和商品经济，商品经济产生的条件"><a href="#自然经济和商品经济，商品经济产生的条件" class="headerlink" title="自然经济和商品经济，商品经济产生的条件"></a>自然经济和商品经济，商品经济产生的条件</h4><blockquote><p>商品经济：以交换为目的的经济形态</p></blockquote><h5 id="商品经济存在和发展的条件"><a href="#商品经济存在和发展的条件" class="headerlink" title="商品经济存在和发展的条件"></a>商品经济存在和发展的条件</h5><blockquote><ul><li>前提条件：社会分工</li><li>根本条件：不同经济利益的生产者</li></ul><p>自然经济：自给自足，满足本经济单位的需要的家庭生产为基础的生产方式</p></blockquote><h4 id="商品"><a href="#商品" class="headerlink" title="商品"></a>商品</h4><blockquote><p>使用价值+价值+劳动产品+用于交换</p></blockquote><h4 id="商品的价值和使用价值，以及交换价值，具体劳动和抽象劳动"><a href="#商品的价值和使用价值，以及交换价值，具体劳动和抽象劳动" class="headerlink" title="商品的价值和使用价值，以及交换价值，具体劳动和抽象劳动"></a>商品的价值和使用价值，以及交换价值，具体劳动和抽象劳动</h4><blockquote><p>使用价值：物品能满足人们某种需要的属性，是商品的<code>自然属性</code></p><ul><li>必须是为满足<code>别人</code>需要的使用价值</li><li>必须是<code>为交换而生产</code>的使用价值</li><li>商品的使用价值体现在商品的属性</li><li>商品使用价值在<code>消费过程</code>中体现</li><li>一种商品有多种使用价值</li></ul><p>价值(<span style="color:red">交换价值的基础</span>)：物化在商品中的一般人类劳动，是商品的<code>社会属性</code></p><p>使用价值和价值</p><ul><li>对立性：两者不可兼得</li><li>统一性：商品必须同时具有使用价值和价值</li></ul><p>交换价值(<span style="color:red">价值的表现形式</span>)：一种使用价值与另一种使用价值交换量的关系</p><ul><li>使用价值是交换价值的物质承担者</li></ul><p>具体劳动：劳动的具体形式</p><p>抽象劳动：无差别人类劳动</p><p>具体劳动和抽象劳动是同一劳动的不同方面</p></blockquote><h4 id="商品的价值量，社会必要劳动时间，简单劳动和复杂劳动"><a href="#商品的价值量，社会必要劳动时间，简单劳动和复杂劳动" class="headerlink" title="商品的价值量，社会必要劳动时间，简单劳动和复杂劳动"></a>商品的价值量，社会必要劳动时间，简单劳动和复杂劳动</h4><blockquote><p><strong>价值量</strong>：凝结在商品中的抽象劳动量</p><ul><li>不是个别劳动时间决定，由社会必要劳动时间决定</li></ul><p><strong>个别劳动时间</strong></p><p>​    个别商品生产者或个别企业生产某种商品的劳动时间</p><p><strong>社会必要劳动时间</strong></p><p>​    在现有的社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下制造某种商品所需要的劳动时间</p><p><strong>简单劳动</strong></p><p>​    指在一定社会条件下，不需要经过任何专门的训练，一般劳动者都能胜任的劳动，即简单劳动力的支出和耗费</p><p><strong>复杂劳动</strong></p><p>​    指具有一定技术专长的劳动，而获得这些技术专长和知识，需要经受专门的培养和训练</p><ul><li>少量的复杂劳动等于多量的简单劳动</li></ul></blockquote><h4 id="商品价值形式的四个阶段，货币的本质以及职能，价值规律及其作用"><a href="#商品价值形式的四个阶段，货币的本质以及职能，价值规律及其作用" class="headerlink" title="商品价值形式的四个阶段，货币的本质以及职能，价值规律及其作用"></a>商品价值形式的四个阶段，货币的本质以及职能，价值规律及其作用</h4><blockquote><p><strong>价值规律</strong></p><ul><li>商品价值量由社会必要劳动时间决定，商品交换要以价值量为基础等价交换</li></ul><p><strong>价值规律的作用</strong></p><ul><li>自发地调节资源在社会各部门的配置</li><li>自发的刺激社会生产力发展</li><li>自发地调节社会收入的分配</li></ul><p><strong>价值规律的消极后果</strong></p><ul><li>可能导致垄断的发生</li><li>可能引起商品生产者两极分化</li><li>可能造成社会资源浪费</li></ul><p><code>价值形式</code>：商品的价值表现形式，当货币出现后，表现为价格，<code>平均长期来看，商品与价值一致</code></p><h4 id="价值形式的四个阶段-揭示价值的本质是一种社会关系"><a href="#价值形式的四个阶段-揭示价值的本质是一种社会关系" class="headerlink" title="价值形式的四个阶段(揭示价值的本质是一种社会关系)"></a><strong>价值形式的四个阶段</strong>(揭示价值的本质是一种社会关系)</h4><p><strong>一、简单价值形式</strong></p><p>​    一种商品价值通过任何另一种商品来表现</p><p><strong>二、扩大的价值形式</strong></p><p>​    一种商品价值通过一系列简单价值形式的总和构成</p><p><strong>三、一般价值形式</strong></p><p>​    通过一般等价物比较价值</p><p><strong>四、货币形式</strong></p><p>​    货币固定为一般等价物</p><ul><li><h5 id="货币的本质"><a href="#货币的本质" class="headerlink" title="货币的本质"></a>货币的本质</h5><ul><li>特殊的商品</li><li>价值：商品价值的直接代表</li><li>使用价值：<code>自然属性</code>和<code>社会职能</code>决定的使用价值</li></ul></li><li><h5 id="货币的职能"><a href="#货币的职能" class="headerlink" title="货币的职能"></a>货币的职能</h5><ul><li>价值尺度：能表现一切商品的价值</li><li>流通手段：直接交换一切商品的能力</li><li>贮藏手段</li><li>支付手段：信用交易相关</li></ul></li><li><p>一定时间内流通货币量规律</p></li><li><p>$流通中所需的货币量 = \frac{商品价格总额}{货币流通速度}$</p></li><li><p>商品价格总额=待流通商品数量 * 商品价格水平</p></li><li><p>货币流通速度=同一单位货币的平均流通次数</p></li></ul></blockquote><h4 id="以私有制为基础的商品经济的基本矛盾"><a href="#以私有制为基础的商品经济的基本矛盾" class="headerlink" title="以私有制为基础的商品经济的基本矛盾"></a>以私有制为基础的商品经济的基本矛盾</h4><blockquote><p>私人劳动和社会劳动的矛盾构成基本矛盾</p><ul><li>决定商品经济的本质及发展过程</li><li>商品经济其他一切矛盾的基础</li><li>决定生产者的命运</li></ul></blockquote><h4 id="劳动价值论的意义"><a href="#劳动价值论的意义" class="headerlink" title="劳动价值论的意义"></a>劳动价值论的意义</h4><blockquote><ol><li><p>劳动价值论，为剩余价值论的创立奠定了理论基础;</p></li><li><p>劳动价值论揭示私有制下商品经济的基本矛盾，为从 物与物的关系背后揭示人与人的关系提供了理论依据</p></li><li><p>劳动价值论揭示的商品经济的一般规律，为分析现代社会市场经济发展提供理论指导 </p></li></ol></blockquote><h4 id="深化对马克思劳动价值论的认识"><a href="#深化对马克思劳动价值论的认识" class="headerlink" title="深化对马克思劳动价值论的认识"></a>深化对马克思劳动价值论的认识</h4><blockquote><ul><li><p>深化对创造价值的劳动的认识，对生产性劳动做出新的界定。 </p><ul><li>应当在理论上充分肯定生产性劳动应当包括大部分非物质生产领域的 服务性劳动，服务性劳动也是创造价值的劳动，以利于推动第三产业 更快发展。 </li></ul></li><li><p>深化对科技人员、经营管理人员在社会生产和价值创造中的作用 的认识。 </p></li><li><p>深化对技术、知识、信息等新的生产要素在财富和价值创造中的 作用的认识。 </p></li><li><p>深化对价值创造与价值分配关系的认识。价值分配不仅以价值创 造为前提，而且由生产资料所有制关系决定 </p></li></ul></blockquote><h4 id="资本主义产生的两个途径"><a href="#资本主义产生的两个途径" class="headerlink" title="资本主义产生的两个途径"></a>资本主义产生的两个途径</h4><blockquote><ul><li>小商品经济分化而来</li><li>商人和高利贷者转化而来</li></ul></blockquote><h4 id="资本原始积累的两个途径"><a href="#资本原始积累的两个途径" class="headerlink" title="资本原始积累的两个途径"></a>资本原始积累的两个途径</h4><blockquote><p>暴力掠夺生产者，使生产资料和劳动者分离，资本货币在资本家手中迅速积累</p><ul><li>海外殖民掠夺</li><li>圈地运动(掠夺农民土地)</li><li><ul><li>利用国家政权，发行公债，增加捐税等手段敛财</li></ul></li></ul></blockquote><h4 id="剩余价值理论及其意义"><a href="#剩余价值理论及其意义" class="headerlink" title="剩余价值理论及其意义"></a>剩余价值理论及其意义</h4><blockquote><p><strong>剩余价值论</strong>：资本主义经济的特殊规律</p><p><strong>意义</strong></p><ul><li>深刻的揭露了资本主义生产关系的剥削本质，阐明了资产阶级与无产阶级斗争的经济根源，指出无产阶级革命的必然性</li><li>是马克思主义经济理论的基石，是无产阶级反对资产阶级、揭示资本主义剥削制度的锐利武器</li><li>由于唯物史观和剩余价值理论，社会主义由空想变为科学</li></ul></blockquote><h4 id="必要劳动、剩余劳动"><a href="#必要劳动、剩余劳动" class="headerlink" title="必要劳动、剩余劳动"></a>必要劳动、剩余劳动</h4><blockquote><p>必要劳动：与劳动力价值相匹配的劳动部分</p><p>剩余劳动：无偿为资本家创造的价值的劳动部分</p></blockquote><h4 id="劳动力成为商品的条件，劳动力商品的特点与货币转化为资本"><a href="#劳动力成为商品的条件，劳动力商品的特点与货币转化为资本" class="headerlink" title="劳动力成为商品的条件，劳动力商品的特点与货币转化为资本"></a>劳动力成为商品的条件，劳动力商品的特点与货币转化为资本</h4><blockquote><p><strong>资本流通公式</strong></p><p>G-W-G’</p><p><strong>劳动力</strong>：人的劳动能力，是存在于人体内部的脑力和体力的总和</p><p><strong>劳动力成为商品的条件</strong></p><ul><li>劳动者具有人身自由：<code>能将自身劳动作为商品支配</code></li><li>劳动者一无所有：<code>无实现劳动的物质条件</code></li></ul><p><strong>劳动力商品</strong></p><p>不仅能创造价值，而且能创造比自身价值更大的价值</p><p><strong>货币转换为资本</strong></p><p><span style="color:red">前提：</span>劳动力成为商品</p><p><span style="color:red">标志：</span>剩余价值生产</p></blockquote><h4 id="不变资本、可变资本，剩余价值和剩余价值率，剩余价值的生产方法，超额剩余价值"><a href="#不变资本、可变资本，剩余价值和剩余价值率，剩余价值的生产方法，超额剩余价值" class="headerlink" title="不变资本、可变资本，剩余价值和剩余价值率，剩余价值的生产方法，超额剩余价值"></a>不变资本、可变资本，剩余价值和剩余价值率，剩余价值的生产方法，超额剩余价值</h4><blockquote><p>不变资本：只发生价值转移(<code>生产资料</code>)</p><p>可变资本：能使价值增殖(<code>劳动力</code>)</p><p>剩余价值：$\Delta G= G’ - G$(<code>剩余劳动的凝结</code>)</p><p>剩余价值率：$\frac{剩余劳动时间}{必要劳动时间}=\frac{剩余劳动}{必要劳动}$</p><ul><li>反映资本对雇佣劳动的剥削程度</li></ul><p>剩余价值的生产方法</p><ul><li><code>绝对剩余价值生产</code></li><li><code>相对剩余价值生产(超额剩余价值)</code></li></ul><p>超额剩余价值：</p><ul><li>提高生产率，个别劳动价值 &lt; 社会劳动价值</li></ul></blockquote><h4 id="资本积累，资本的有机构成，资本主义相对人口过剩"><a href="#资本积累，资本的有机构成，资本主义相对人口过剩" class="headerlink" title="资本积累，资本的有机构成，资本主义相对人口过剩"></a>资本积累，资本的有机构成，资本主义相对人口过剩</h4><blockquote><p>资本的积累：剩余价值的资本化(<code>两级分化与失业的源泉</code>)</p><p>资本的有机构成：由资本技术决定并反映<code>技术构成</code>变化的资本<code>价值构成</code></p><p>相对人口过剩：失业</p></blockquote><h4 id="资本的循环周转和再生产、产业资本循环的三个阶段"><a href="#资本的循环周转和再生产、产业资本循环的三个阶段" class="headerlink" title="资本的循环周转和再生产、产业资本循环的三个阶段"></a>资本的循环周转和再生产、产业资本循环的三个阶段</h4><blockquote><p>购买阶段、生产阶段、售卖阶段<br><pre><code class=" mermaid">graph LRsubgraph 购买阶段G --&gt; WW --&gt; PmW --&gt; Ao1&gt;货币资本]end subgraph 生产阶段P[...P...W&#39;]o2&gt;生产资本]endsubgraph 售卖阶段G&#39;o3&gt;商品资本]endA -.- PP --&gt; G&#39;</code></pre></p></blockquote><h4 id="产业资本运动的两个前提条件"><a href="#产业资本运动的两个前提条件" class="headerlink" title="产业资本运动的两个前提条件"></a>产业资本运动的两个前提条件</h4><blockquote><ul><li>空间并存</li><li>时间接续</li></ul></blockquote><h4 id="社会总产品，社会生产的两大部类"><a href="#社会总产品，社会生产的两大部类" class="headerlink" title="社会总产品，社会生产的两大部类"></a>社会总产品，社会生产的两大部类</h4><blockquote><p>c：生产资料的转移价值</p><p>v：必要劳动创造的价值</p><p>m：剩余劳动时间中创造的价值</p><p>社会总产品：社会在一定时期创造生产资料总和</p><ul><li>价值构成</li><li>c+v+m</li><li>实物构成</li><li>生产资料</li><li>消费资料</li></ul><hr><p><strong>社会生产两大部类</strong></p><p><code>生产资料的第一部类I</code>：由生产生产资料的部门构成，产品进入生产领域</p><p><code>生产资料的第二部类II</code>：由生产消费资料的部门构成，产品进入消费领域</p></blockquote><h4 id="资本主义工资的本质，利润和利润率"><a href="#资本主义工资的本质，利润和利润率" class="headerlink" title="资本主义工资的本质，利润和利润率"></a>资本主义工资的本质，利润和利润率</h4><blockquote><p><strong>工资</strong></p><ul><li>劳动力商品的价值表现</li></ul><p><strong>利润</strong>：剩余价值的转化形式，剩余价值是利润的本质</p><p><strong>利润率</strong>：$p’ = \frac{m}{c+v}$</p></blockquote><h4 id="资本主义社会的基本矛盾与经济危机"><a href="#资本主义社会的基本矛盾与经济危机" class="headerlink" title="资本主义社会的基本矛盾与经济危机"></a>资本主义社会的基本矛盾与经济危机</h4><blockquote><p><code>资本主义基本矛盾</code><br>社会化生产力与资本主义私人占有生产关系之间的矛盾 </p><p><code>资本主义经济危机</code></p><p><strong>本质</strong>：生产过剩(<code>相对过剩，对劳动人民支付能力而言过剩，而不是需求过剩</code>)</p><p><strong>根源</strong>：资本主义的基本矛盾</p><ul><li>生产无线扩大的趋势与劳动人民有支付能力的需求相对缩小的矛盾</li><li>单个企业内部生产的有组织性和整个社会的无政府之间的矛盾</li></ul><p><strong>表现</strong>：资本再生产呈现周期性</p><ul><li>危机 =&gt; 萧条 =&gt; 复苏 =&gt; 高涨</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑</title>
    <link href="/2018/07/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    <url>/2018/07/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h3 id="一、数制码制"><a href="#一、数制码制" class="headerlink" title="一、数制码制"></a>一、数制码制</h3><h5 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h5><blockquote><p>在有限个离散稳定值之间做阶跃式变化的信号</p><p>取值有限</p><p>范围是离散值</p><p>晶体管工作在非线性区，处于开关状态 </p></blockquote><h5 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号"></a>模拟信号</h5><blockquote><p>模拟信号是连续信号，任一时间段都包含了信号的连续变化</p><p>模拟电路: 晶体管工作在线性区，处于放大状态</p></blockquote><h5 id="数字逻辑电路"><a href="#数字逻辑电路" class="headerlink" title="数字逻辑电路"></a>数字逻辑电路</h5><blockquote><p>对数字信号信进行传递、变换、运算、存储及显示处理的电路称为数字电路 </p><ul><li>数值运算</li><li>逻辑运算</li><li>逻辑判断</li></ul><p>分类</p><blockquote><ul><li>组合逻辑电路</li><li>时序逻辑电路</li></ul></blockquote><p>研究问题</p><blockquote><p>电路输出信号状态与输入信号状态之间的逻辑关系</p></blockquote></blockquote><h5 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h5><blockquote><p>数字系统是由实现各种功能的逻辑电路相互连接构成的整体，它能交互式地处理用离散形式表示的信息 </p></blockquote><h5 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h5><blockquote><p>真值是指在数值前用“+”表示正数，用“-”表示负数的带符号二进制数。</p></blockquote><h5 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h5><blockquote><p>机器数是指用“0”表示“+”， 用“1”表示“-”，即把符号“数值化”后的带符号二进制数</p><p>正数的原码、反码、补码都是相同的</p><ul><li><p>原码</p><ul><li>整数部分</li></ul></li></ul><p><img src="2.png" width=450></p><ul><li>小数部分</li></ul><p><img src="3.png" width=450></p><ul><li><p>有两种形式的整数0原码</p></li><li><p>有两种形式的纯小数0.0原码</p></li><li><p>符号位不能直接加入运算</p></li></ul><ul><li><p>反码(1的补码)</p><ul><li><p>对于负数，反码的数值是将原码数值部分按位求反</p></li><li><p>对于负数，反码为等长的全1码减数值部分，再加上符号位</p></li><li><p>有两种形式的整数0反码</p></li><li><p>有两种形式的纯小数0.0反码</p></li><li><p>eg：</p><blockquote><p>－0.101的反码为1.010</p><p>－10101的反码为101010</p></blockquote></li></ul></li><li><p>补码(对2的补数)</p><p>反码加1</p><ul><li>整数部分</li></ul></li></ul><p><img src="4.png" width=450></p><ul><li>小数部分</li></ul><p><img src="5.png" width=450></p><ul><li>0和0.0的表示是唯一的</li></ul></blockquote><h5 id="机器数加减运算"><a href="#机器数加减运算" class="headerlink" title="机器数加减运算"></a>机器数加减运算</h5><blockquote><ul><li><p>原码运算</p><p>先看符号，判断绝对值</p><p>符号位不参与运算</p></li><li><p>补码运算</p><ul><li><p>[X1＋X2]~补~＝[X1]~补~＋[X2]~补~</p></li><li><p>[X1- X2]~补~＝[X1]~补~＋[-X2]~补~</p></li><li><p>补码溢出</p><blockquote><p>符号位和数值位一样参加运算，若符号位产生进位，则将进位“丢掉”(高两位进位相同时可直接丢掉)</p><p>最高的两位进位不相同，产生溢出。通过添加Bit数，最高的两位进位为00，从而防止溢出 </p><p> <img src="7.png" width=450></p></blockquote></li><li><p>符号位为1，说明是负数补码，应对运算结果再求补码，得到原码</p></li></ul></li><li><p>反码运算</p><blockquote><ul><li><p>[X1＋X2]~反~＝[X1]~反~＋[X2]~反~</p></li><li><p>[X1- X2]~反~＝[X1]~反~＋[-X2]~反~</p></li><li><p>循环进位</p><blockquote><p>符号位参加运算，如果符号位产生了进位，则该进位应该加到和数的最低位</p></blockquote></li><li><p>若符号位为1，说明是负数的反码，对结果再求反码得原码</p></li></ul></blockquote></li></ul></blockquote><h5 id="数制三要素"><a href="#数制三要素" class="headerlink" title="数制三要素"></a>数制三要素</h5><blockquote><ul><li>基数</li><li>进位规则</li><li>位权</li></ul></blockquote><h5 id="二进制乘除法"><a href="#二进制乘除法" class="headerlink" title="二进制乘除法"></a>二进制乘除法</h5><blockquote><p><img src="14.png" width=200px></p><p><img src="15.png" width=200px></p></blockquote><h5 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h5><blockquote><p>十进制转二进制</p><blockquote><p>整数部分：除以2取<strong>余数</strong>，直到商为0为止(逆序取余数)</p><p>小数部分：乘以2取<strong>整数</strong>，直到小数为0(或到达要求精度)为止(顺序取整数) </p><p>eg: (25.875)~10~＝(11001.111)~2~</p><p><img src="1.png" width=450></p></blockquote><p>十进制转n进制</p><blockquote><p>整数部分：除以n取余数，直到商为0为止(逆序取余数)</p><p>小数部分：乘以n取整数，直到小数为0(或到达要求精度)为止(顺序取整数)</p></blockquote><p>n进制转十进制</p><blockquote><p>位权展开求和</p></blockquote><p>二进制转八进制</p><blockquote><p>小数点起<strong>三位</strong>一组，整数部分不够三位的向前添0，小数部分不够三位的向后添0</p></blockquote><p>二进制转十六进制</p><blockquote><p>即从小数点起<strong>四位</strong>一组，整数部分不够四位的向前添0，小数部分不够四位的向后添0</p></blockquote></blockquote><h5 id="十进制的二进制编码-BCD码"><a href="#十进制的二进制编码-BCD码" class="headerlink" title="十进制的二进制编码(BCD码)"></a>十进制的二进制编码(BCD码)</h5><blockquote><p><img src="9.png" width=450></p><p><img src="10.png" width=450></p><p>8421码</p><blockquote><p>具有奇偶特性，当十进制数为奇数时，对应代码的最低位为1，为偶数时则为0</p></blockquote><p>余3码</p><blockquote><p>8421码加上3(加0011)</p></blockquote></blockquote><h5 id="可靠性编码"><a href="#可靠性编码" class="headerlink" title="可靠性编码"></a>可靠性编码</h5><blockquote><p>格雷码</p><blockquote><p>任意相邻两个代码之间只有一位状态不同，这样在计数过程中就不会出现其它代码，译码时就不会产生抖动和毛刺</p><p><img src="11.png" width=450></p><p><img src="12.png" width=450></p></blockquote><p>奇偶校验码</p><blockquote><p>即在数据中加入校验位，校验位的加入如果使整个代码中的“1” 的个数为奇数，称奇校验</p><p>如果使整个代码中的“1” 的个数为偶数，称偶校验</p><p><img src="13.png" width=450></p></blockquote></blockquote><h3 id="二、数字电路"><a href="#二、数字电路" class="headerlink" title="二、数字电路"></a>二、数字电路</h3><h5 id="正负逻辑"><a href="#正负逻辑" class="headerlink" title="正负逻辑"></a>正负逻辑</h5><blockquote><p>正逻辑</p><blockquote><p>用“0”表示V~L~，用“1”表示V~H~</p></blockquote><p>负逻辑</p><blockquote><p>用“1”表示V~L~，用“0”表示V~H~ </p></blockquote></blockquote><h5 id="逻辑系列"><a href="#逻辑系列" class="headerlink" title="逻辑系列"></a>逻辑系列</h5><blockquote><ul><li>同一系列的芯片具有类似的输入、输出及内部电路特征，但逻辑功能不同</li><li>不同系列的芯片可能不匹配</li><li>CMOS逻辑</li><li>TTL逻辑</li></ul></blockquote><h5 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h5><blockquote><p>互补式金属-氧化层-半导体逻辑电路 </p><ul><li><p>VDD=+3V～+18V</p></li><li><p>VL=0V</p></li><li><p>VH= VDD</p></li><li><p>速度慢，功耗小，抗干扰强，集成度高</p></li></ul><p><img src="16.png"></p><p>n沟道</p><blockquote><p><img src="17.png" width=450></p><p>增加V~gs~，R~ds~减小，高压导通</p></blockquote><p>p沟道</p><blockquote><p><img src="18.png" width=450></p><p>增加V~gs~，R~ds~减小，低压导通</p></blockquote><p>栅－漏、栅－源之间几乎没有电流</p><p>电容耦合</p><blockquote><p>栅极与源和漏极之间有电容耦合</p><p>信号转换时，电容充放电，功耗较大</p></blockquote></blockquote><h5 id="CMOS反相器"><a href="#CMOS反相器" class="headerlink" title="CMOS反相器"></a>CMOS反相器</h5><blockquote><p><img src="19.png" width=300></p></blockquote><h5 id="CMOS与非门"><a href="#CMOS与非门" class="headerlink" title="CMOS与非门"></a>CMOS与非门</h5><blockquote><p><img src="20.png" width=300></p><p>T1、T3串联</p><p>T2、T4并联</p></blockquote><h5 id="CMOS或非门"><a href="#CMOS或非门" class="headerlink" title="CMOS或非门"></a>CMOS或非门</h5><blockquote><p><img src="21.png" width=300></p><p>T1、T3并联</p><p>T2、T4串联</p></blockquote><h5 id="CMOS非反向缓存"><a href="#CMOS非反向缓存" class="headerlink" title="CMOS非反向缓存"></a>CMOS非反向缓存</h5><blockquote><p><img src="22.png" width=450></p></blockquote><h5 id="CMOS电气特性"><a href="#CMOS电气特性" class="headerlink" title="CMOS电气特性"></a>CMOS电气特性</h5><blockquote><ul><li>逻辑电平规格</li></ul><blockquote><p><img src="23.png" width=450></p><p>输出端能吸收的最大电流：I~OLmax~（灌电流）</p><p>输出端能提供的最大电流：I~OHmax~（拉电流）  </p></blockquote><ul><li><p>直流噪声容限</p><blockquote><p>表示多大的噪声会使最坏输出电压被破坏,成为不可被输入端识别的值</p><p>高态：V~OHmin~ - V~LHmin~</p><p>低态：V~ILmax~ - V~OLmax~</p><p><strong>非理想输入</strong>：输入端电路增大，功耗增大</p></blockquote></li><li><p>扇入</p><blockquote><p>门电路所具有的输入端的数目</p></blockquote></li><li><p>扇出</p><blockquote><p>在不超出其最坏情况负载规格的条件下，一个逻辑门能驱动的输入端个数</p><p>高态扇出：$\frac{I<em>{OHmax}}{I</em>{IHmax}}$</p><p>低态扇出：$\frac{I<em>{OLmax}}{I</em>{ILmax}}$</p><p>总扇出：min&lt;高态扇出，低态扇出&gt;</p><p><strong>输出负载大于扇出能力</strong>：电流增大、功耗增大、温度升高、传输时延、转换时间变长</p></blockquote></li><li><p>不用的CMOS端的处理</p><blockquote><p>悬空时，电路噪声会使悬空端呈现高电平，间歇性造成电路故障</p><ul><li>与、与非门，不用的输入端接高电平</li><li>或、或非门，不用的输入端接低电平</li></ul></blockquote></li><li><p>动态特性</p><blockquote><p>速度</p><ul><li><p>状态转换时间</p><blockquote><p>输出从一个状态转换到另外一个状态所需的时间 </p></blockquote></li><li><p>传播时延</p><blockquote><p>从输入信号变化到产生输出信号变化所需的时间</p></blockquote></li></ul></blockquote></li><li><p>动态功耗</p><blockquote><ul><li>CMOS管同时导通瞬间产生的功耗</li><li>电容充放电功耗</li></ul></blockquote></li><li><p>电流尖峰</p><blockquote><p>当CMOS输出，在低态与高态之间交替变化时，从Vcc到地线的电流，通过部分导通的p沟道和n沟道晶体管而流动，持续时间很短</p><p>噪声解决方法：在Vcc与地线之间接去耦电容器</p></blockquote></li></ul></blockquote><h5 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h5><blockquote><p>晶体管晶体管逻辑电路</p><ul><li>VCC=+5V</li><li>VL=0.2V</li><li>VH=3.6V</li><li>速度中等，功耗较大，性价比高</li></ul><p>低态（低电平）：0.0～0.8V</p><p>高态（高电平）：2.0～5.0V</p></blockquote><h5 id="CMOS-TTL接口"><a href="#CMOS-TTL接口" class="headerlink" title="CMOS/TTL接口"></a>CMOS/TTL接口</h5><blockquote><ul><li><p>A驱动B：A为输出端</p></li><li><p>直流噪声容限</p><blockquote><p>高态：V~OHmin~ - V~LHmin~</p><p>低态：V~ILmax~ - V~OLmax~</p></blockquote></li><li><p>扇出</p><blockquote><p>高态扇出：$\frac{I<em>{OHmax}}{I</em>{IHmax}}$</p><p>低态扇出：$\frac{I<em>{OLmax}}{I</em>{ILmax}}$</p><p>总扇出：min&lt;高态扇出，低态扇出&gt;</p></blockquote></li><li><p>剩余驱动能</p><blockquote><p>高态剩余驱动能：高态扇出 - 总扇出</p><p>低态剩余驱动能： 0</p></blockquote></li></ul></blockquote><h3 id="三、逻辑代数"><a href="#三、逻辑代数" class="headerlink" title="三、逻辑代数"></a>三、逻辑代数</h3><h5 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h5><blockquote><p>事物的前因和后果所遵循的规律 </p></blockquote><h5 id="逻辑代数"><a href="#逻辑代数" class="headerlink" title="逻辑代数"></a>逻辑代数</h5><blockquote><p>用于处理有限个逻辑变量的数学运算体系。又称为布尔代数</p><ul><li><p>逻辑与</p><blockquote><p>F＝f(A，B)＝A$\and$B=A·B＝AB</p><p><img src="24.png" width=450></p></blockquote></li><li><p>逻辑或</p><blockquote><p>F＝f(A，B)＝A$\or$B＝A＋B</p><p><img src="25.png" width=450></p></blockquote></li><li><p>逻辑非</p><blockquote><p>F=A^’^</p><p><img src="26.png" width=450></p></blockquote></li><li><p>异或</p><blockquote><p>$F=A\oplus B = A\bar{B} + \bar{A}B$</p><p><img src="30.png" width=450></p><p>可作为模为2的加法</p></blockquote></li><li><p>同或</p><blockquote><p>$F=A\odot B = AB + \overline{A}\cdot\overline{B}$</p><p><img src="31.png" width=450></p></blockquote></li><li><p>偶数个变量的异或和同或互反</p></li><li><p>基数个变量的异或和同或相同</p></li><li><p>偶数个1异或为0(做奇偶校验)</p></li><li><p>偶数个1同或为1(做奇偶校验)</p></li></ul></blockquote><h5 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h5><blockquote><p>逻辑变量和逻辑函数的取值只有0和1</p><p>函数和变量之间的关系由“ 与、或、非 ” 三种基本运算决定</p><ul><li><p>逻辑函数的相等</p><blockquote><p>两个逻辑函数，输入相同时，值也相同</p></blockquote></li><li><p>逻辑函数的表示</p><ul><li>真值表</li><li>表达式</li><li>卡诺图</li><li>时序图、波形图</li></ul></li></ul></blockquote><h5 id="逻辑代数运算规则"><a href="#逻辑代数运算规则" class="headerlink" title="逻辑代数运算规则"></a>逻辑代数运算规则</h5><blockquote><p><img src="27.png" width=450px></p><p><img src="28.png" width=450px></p><p><img src="29.png" width=450></p><p><img src="32.png" width=450></p><p><img src="33.png" width=450></p><ul><li><p>分配率</p><blockquote><p>$A(B\oplus C)=AB\oplus AC$</p><p>$A+(B\odot C)=(A+B)\odot (A+C)$</p></blockquote></li></ul><p><img src="34.png" width=450></p><ul><li><p>代入规则</p><blockquote><p>任何一个含有变量A的逻辑等式,如果将所有出现A的位置都代之以同一个逻辑函数F,则等式仍然成立</p></blockquote></li><li><p>反演规则($\bar{F}$)</p><blockquote><p>0、1互换</p><p>A、$\bar{A} $互换</p><p>与、或互换</p><p>保持符号运算顺序不变</p></blockquote></li><li><p>对偶规则(F`)</p><blockquote><p>0、1互换</p><p>A、$\bar{A} $不变</p><p>与、或互换</p><p>保持符号运算顺序不变</p><p>性质</p><blockquote><p>若一个定理是正确的，则其对偶式也一定正确</p><p>若两个逻辑式相等，则它们的对偶式也相等</p><p>(F`)`=F</p></blockquote></blockquote></li><li><p>展开规则</p><blockquote><p>$F=f(X_1, X_2, \dots X_n)$<br>$=\bar{X_1}f(0, X_2, \dots X_n) + X_1f(1,X_1,\dots X_n)$</p><p>$=[X_1+f(0, X_2, \dots X_n)][\bar{X_1}f(1,X_1,\dots X_n)]$</p></blockquote></li></ul></blockquote><h5 id="正负逻辑-对偶关系"><a href="#正负逻辑-对偶关系" class="headerlink" title="正负逻辑(对偶关系)"></a>正负逻辑(对偶关系)</h5><blockquote><p><img src="35.png" width=300px></p></blockquote><h5 id="逻辑函数的标准形式"><a href="#逻辑函数的标准形式" class="headerlink" title="逻辑函数的标准形式"></a>逻辑函数的标准形式</h5><blockquote><ul><li><p>标准与或式(积之和)、最小项和式</p><blockquote><p>最小项($\sum$m)</p><blockquote><p>积项包含所有变量，每个变量只出现一次</p><ul><li>任意输入，有且只有一个最小项为1</li><li>n个变量一共有2n个最小项</li><li>不相同的最小项的乘积为0</li><li>所有最小项的和为1</li><li>相邻最小项和可消去互反变量</li></ul></blockquote><p>标准与或表达式：由最小项或组成</p><p>将代数式转换为标准与或式(真值表中的1，1为原变量)</p><blockquote><p>将函数式变换成一般“与或”表达式</p><p>使用$A=A(B+\bar{B})$将所有非最小项转换为最小项</p></blockquote></blockquote></li><li><p>标准或与式(和之积)、最大项积式</p><blockquote><p>最大项($\prod$M)</p><blockquote><p>和项包含所有变量，每个变量只出现一次</p><ul><li>任意输入，有且只有一个最大项为0</li><li>n个变量一共有2n个最大项</li><li>不同的最大项和为1</li><li>所有最大项之积为0</li><li>相邻最大项积可消去互反变量 </li></ul></blockquote><p>标准或与表达式：由最大项积组成</p><p>将代数式转换为标准或与式(真值表中的0，0为原变量)</p><blockquote><p>将函数表达式转换成一般“或与”式</p><p>使用$A=(A+B)(A+\bar{B})$将非最大项扩展成最大项</p></blockquote><p>最大项最小项互反</p></blockquote></li><li><p>标准式</p><blockquote><p>n个变量组成的函数式，每个变量在函数式的<strong>每一项</strong>中都必须以原变量或反变量的形式出现一次，且仅出现一次</p></blockquote></li></ul></blockquote><h5 id="卡诺图"><a href="#卡诺图" class="headerlink" title="卡诺图"></a>卡诺图</h5><blockquote><p>圈0，得最简或与式(和之积)(0为原变量)</p><p>圈1，的最简与或式(积之和)(1为原变量)</p><p>禁止逻辑</p><blockquote><p><img src="36.png" width=450></p><p><img src="37.png" width=450></p><p>圈出的与或式乘以禁止项的非等于正确值</p><p>多乘的禁止项可以在后边加上</p></blockquote></blockquote><h3 id="四、组合逻辑设计"><a href="#四、组合逻辑设计" class="headerlink" title="四、组合逻辑设计"></a>四、组合逻辑设计</h3><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><blockquote><ul><li>逻辑抽象,逻辑赋值</li><li>作真值表</li><li>逻辑化简</li><li>逻辑函数表达式</li><li>逻辑电路图</li></ul><p><strong>与非和或非是通用逻辑电路，可以转换成任意门</strong></p></blockquote><h5 id="逻辑转换"><a href="#逻辑转换" class="headerlink" title="逻辑转换"></a>逻辑转换</h5><blockquote><ul><li>$A+B=\overline{\bar{A}\cdot \bar{B}}$</li></ul></blockquote><h5 id="替代尾因子"><a href="#替代尾因子" class="headerlink" title="替代尾因子"></a>替代尾因子</h5><blockquote><p>$F=\sum{E_i}=H_i\overline{T_1}\overline{T_2}\dots$</p><p>其中$H_i$为头部因子，T为尾部因子，可在T中插入头部因子，作为替代尾因子</p><p><img src="38.png" width=300></p></blockquote><h5 id="设计无反变量的逻辑电路"><a href="#设计无反变量的逻辑电路" class="headerlink" title="设计无反变量的逻辑电路"></a>设计无反变量的逻辑电路</h5><blockquote><ul><li>求出函数的最简“与或”式</li><li>把函数整理成$F=\sum{E_i}$的形式</li><li>选择合适的替代尾部因子</li><li>将或转换为与非</li></ul></blockquote><h5 id="基本运算电路"><a href="#基本运算电路" class="headerlink" title="基本运算电路"></a>基本运算电路</h5><blockquote><p>半加器</p><blockquote><p><img src="39.png" width=450></p><p>S：结果</p><p>C：进位</p></blockquote><p>全加器</p><blockquote><p><img src="40.png" width=300></p></blockquote><p>74183集成全加器</p><blockquote><p><img src="41.png" width=300></p><p>全加器74183的级连：A2A1 + B2B1</p></blockquote><p>74283超前进位加法器</p><blockquote><p><img src="42.png" width=450></p></blockquote><p>全减器</p><blockquote><p>D:差</p><p>G:借位</p></blockquote><p>7485集成比较器</p><blockquote><p><img src="43.png" width=450></p><p><img src="44.png" width=450></p></blockquote><p>8 3编码器</p><blockquote><p><img src="45.png" width=300></p><p><img src="46.png" width=450></p><p>约束：$I_i\cdot I_j = 0$</p><p>$Y_2=\overline{\bar{I_4}\bar{I_5}\bar{I_6}\bar{I_7}}$</p><p>$Y_1=\overline{\bar{I_2}\bar{I_3}\bar{I_6}\bar{I_7}}$</p><p>$Y_0=\overline{\bar{I_1}\bar{I_3}\bar{I_5}\bar{I_7}}$</p></blockquote><p>优先编码器</p><blockquote><p><img src="47.png" width=450></p><p> Y~s~=0表示无编码信号输入(选通输出端)</p><p>$\bar{Y}_{EX}=0$表示有编码信号输入(扩展输出端)</p><p><img src="48.png" width=450></p><p>$Y_2=\overline{ST[I_4+I_5+I_6+I_7]}$</p></blockquote><p>译码器</p><blockquote><p><img src="49.png" width=300></p><p>E:使能端，高电平有效</p><p>3-8译码器 74LS138</p><blockquote><p><img src="50.png" width=450></p><p>$\overline{Z_0}到\overline{Z_7}输出M_0到M_7$</p></blockquote><p>数据<strong>分配器</strong>(2-4译码器,E为数据)</p><blockquote><p><img src="51.png" width=300></p><p>选中的输出端输出$\bar{E}$</p></blockquote><p>数据选择器</p><blockquote><p><img src="52.png" width=300></p><p><img src="53.png" width=450></p></blockquote></blockquote></blockquote><h5 id="利用3-8译码器实现逻辑函数"><a href="#利用3-8译码器实现逻辑函数" class="headerlink" title="利用3-8译码器实现逻辑函数"></a>利用3-8译码器实现逻辑函数</h5><blockquote><ul><li>将输出化成标准积之和形式再转成和之积</li><li>3-8译码器每个输出端都输出一个最大项，根据逻辑函数所需的最大项构造电路图</li></ul><p><img src="75.png" width=450></p></blockquote><h5 id="利用数据选择器实现逻辑函数"><a href="#利用数据选择器实现逻辑函数" class="headerlink" title="利用数据选择器实现逻辑函数"></a>利用数据选择器实现逻辑函数</h5><blockquote><ul><li>列出真值表</li><li>将真值表移到数据选择器的输入端</li></ul><p>或利用4选1数据选择器(输出可以被分组总结出来)</p><p><img src="54.png" width=450></p><p>eg(保留地址端)</p><blockquote><p><img src="55.png" width=450></p></blockquote><p>双4路74LS153数据选择器</p><blockquote><p><img src="56.png" width=450></p></blockquote></blockquote><h5 id="组合逻辑电路险象"><a href="#组合逻辑电路险象" class="headerlink" title="组合逻辑电路险象"></a>组合逻辑电路险象</h5><blockquote><ul><li><p>竞争$A\cdot \bar{A}$</p><blockquote><p>某个门电路的两个信号同时向相反方向变化</p><p>原因</p><ul><li>变化时间有微小差异</li><li>信号边沿变化时间存在差异</li></ul><p>结果</p><ul><li>导致险象(毛刺)</li></ul></blockquote></li><li><p>冒险(险象)</p><blockquote><p>输出出现瞬间的逻辑错误。工程上也称为毛刺</p><ul><li>若在输入变化而输出不应发生变化的情况下输出产生险象，称为<strong>静态险象</strong> </li><li>若在输入变化而输出应该发生变化，输出在变化过程中产生的险象称<strong>动态险象</strong> </li><li>若错误输出为负脉冲称<strong>“ 0 ”型险象</strong></li><li>若错误输出为正脉冲称<strong>“ 1 ”型险象</strong></li><li><img src="57.png" width=450></li></ul></blockquote></li><li><p>险象判断</p><blockquote><p><img src="58.png" width=450></p><p><img src="59.png" width=450></p></blockquote></li><li><p>险象消除</p><blockquote><p><img src="60.png" width=450></p></blockquote></li></ul></blockquote><h3 id="五、触发器"><a href="#五、触发器" class="headerlink" title="五、触发器"></a>五、触发器</h3><h5 id="触发器-Flip-Flop"><a href="#触发器-Flip-Flop" class="headerlink" title="触发器(Flip-Flop)"></a>触发器(Flip-Flop)</h5><blockquote><p>能够存储一位二进制信息的基本单元电路称触发器</p><ul><li>具有两个能自行保持的稳定状态</li><li>具有一对互补输出( $Q$、 $\bar{Q}$ )</li><li>有一组控制(激励 、驱动)输入</li><li>或许有定时(时钟)端CP(Clock Pulse) </li><li>在输入信号消失后,电路能将获得的新状态保存 </li></ul></blockquote><h5 id="SR触发器"><a href="#SR触发器" class="headerlink" title="SR触发器"></a>SR触发器</h5><blockquote><p>特征方程</p><blockquote><p>$Q^{n+1}=S+\bar{R}Q^n$</p></blockquote><p>约束条件(S和R不能同时为1)</p><blockquote><p>$\bar{S}+\bar{R}=1$（与非门结构）</p><p>$S\cdot R=0$（或非门结构）</p></blockquote><p><img src="61.png" width=450></p></blockquote><p>真值表</p><blockquote><p>与非门结构</p><p><img src="62.png" width=450></p><p>或非门结构</p><p><img src="63.png" width=450></p></blockquote><h5 id="钟控S-R触发器"><a href="#钟控S-R触发器" class="headerlink" title="钟控S-R触发器"></a>钟控S-R触发器</h5><blockquote><p><img src="64.png" width=300></p><p><img src="65.png" width=300></p></blockquote><h5 id="主从S-R触发器"><a href="#主从S-R触发器" class="headerlink" title="主从S-R触发器"></a>主从S-R触发器</h5><blockquote><p>时钟下降沿输出主触发器状态，解决空翻问题</p><p><img src="66.png" width=450></p><p>cp=1,从触发器保持</p><p>cp=0,主触发器保持,从触发器输出主触发器状态</p></blockquote><h5 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h5><blockquote><ul><li>确定状态个数</li><li>确定得到每个状态的条件</li><li>确定不同状态间的转换条件</li></ul></blockquote><h5 id="D触发器"><a href="#D触发器" class="headerlink" title="D触发器"></a>D触发器</h5><blockquote><p><img src="67.png" width=300></p><ul><li>CP=0：保持</li><li>CP=1： $Q^{n+1}=D$</li></ul></blockquote><h5 id="JK触发器"><a href="#JK触发器" class="headerlink" title="JK触发器"></a>JK触发器</h5><blockquote><p><img src="68.png" width=300></p><p>$Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n$</p><p><img src="69.png" width=300></p><p>JK触发器将<strong>SR触发器</strong>的输出反馈到输入，消去了约束条件</p><p>翻转状态不稳定</p></blockquote><h5 id="主从JK触发器"><a href="#主从JK触发器" class="headerlink" title="主从JK触发器"></a>主从JK触发器</h5><blockquote><p>将主从SR触发器的输出反馈到输入，解决了空翻和消去了约束</p><blockquote><p><img src="70.png" width=450></p></blockquote><p>cp=1,从触发器保持</p><p>cp=0,主触发器保持,从触发器输出主触发器状态</p><p>一次变化</p><blockquote><p>CP为“1”期间，主触发器仅能翻转一次</p><p>Q=0,K被封锁，CP=1期间，J只要有一次为1，$Q^{n+1}=1$</p><p>$\bar{Q}$=0,J被封锁，CP=1期间，K只要有一次为1，$Q^{n+1}=0$</p></blockquote><p>上升沿接收，下降沿改变</p><p>cp=1期间J、K应该保持不变，不然会发生一次变化</p></blockquote><h5 id="T触发器"><a href="#T触发器" class="headerlink" title="T触发器"></a>T触发器</h5><blockquote><p><img src="74.png" width=450></p><p>$Q^{n+1}=T\oplus Q^n$</p><p>T=0保持</p><p>T=1翻转</p><p>下降沿触发</p></blockquote><h5 id="集成触发器"><a href="#集成触发器" class="headerlink" title="集成触发器"></a>集成触发器</h5><blockquote><p>集成D触发器</p><blockquote><p><img src="71.png" width=300></p><p><strong>上升沿</strong></p><blockquote><p>同步工作</p><p>CP=1</p><p>若$\bar{S}\cdot \bar{R}=1$发挥D触发器的作用</p><p>否则发挥SR触发器的作用</p></blockquote><p>CP=0</p><blockquote><p>异步工作</p><p>发挥SR触发器的作用(约束)</p></blockquote></blockquote><p>集成JK触发器</p><blockquote><p><img src="72.png" width=300></p></blockquote><p><strong>下降沿</strong></p><blockquote><p>同步工作</p><p>若$\bar{S}\cdot \bar{R}=1$发挥JK触发器的作用</p><p>否则发挥SR触发器的作用</p></blockquote><p>CP=1</p><blockquote><p>异步工作</p><p>发挥SR触发器的作用(约束)</p></blockquote></blockquote><h5 id="边沿JK触发器"><a href="#边沿JK触发器" class="headerlink" title="边沿JK触发器"></a>边沿JK触发器</h5><blockquote><p><img src="73.png" width=450></p></blockquote><h5 id="触发器之间的转换"><a href="#触发器之间的转换" class="headerlink" title="触发器之间的转换"></a>触发器之间的转换</h5><blockquote><p>p141</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多媒体技术</title>
    <link href="/2018/06/25/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    <url>/2018/06/25/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h3 id="多媒体技术"><a href="#多媒体技术" class="headerlink" title="多媒体技术"></a>多媒体技术</h3><p>多媒体与传统媒体的不同</p><blockquote><p>信号本质不同;模拟与数字 </p><p>被动接受与主动交互 </p></blockquote><p>多媒体</p><blockquote><p><strong>融合两种或两种以上媒体的人-机互动的信息交流和传播媒体</strong></p><p>特点：</p><ul><li>是信息交流和传播媒体  </li><li>是人-机交互式媒体  </li><li>都是以数字形式存储和传输 </li><li>传播信息的媒体的种类很多 </li></ul><p>ISO93a的分类：</p><ul><li>感知媒体 ：帮助人来感知环境 (视听触觉)</li><li>表示媒体：用计算机的内部表示刻画表示媒体(编码)</li><li>表现媒体：信息输入输出的工具和设备(交互)</li><li>存储媒体：支持信息存储的数据载体</li><li>传输媒体：传输数据信息，支持连续媒体的数据传输</li><li>信息交换媒体 ：所有用于传输和存储的信息载体</li></ul></blockquote><p>多媒体数据</p><blockquote><p>特点：</p><ul><li>数据量巨大;</li><li>数据类型多;</li><li>数据输入输出复杂;</li></ul></blockquote><p>超文本</p><blockquote><p><strong>超文本是通过复杂的、非顺序的关联关系连接在一起的一种文本，其真正含义是“链接”的意思</strong> </p></blockquote><p>超媒体</p><blockquote><p>使用文本、图形、图像、声音和电视图像等媒体任意组合的一种交互式信息传播媒体</p><ul><li>多媒体是超媒体的一个子集</li></ul></blockquote><p>多媒体系统</p><p>DCIKW</p><blockquote><p>data(数据) ：以数字、字符或图像等可读语言或其他记录方法表示的事实、概 念或计算机指令 </p><p>Content(内容)：内容是对数据的描述 </p><p>information(信息)：信息是对内容的解释，也就是数据的含义 </p><p> knowledge(知识)：在某个感兴趣领域中的事实、概念和关系 </p><p>wisdom(智慧)：知识累积后产生的洞察力、判断力和发明创造能力 </p></blockquote><p>多媒体内容</p><blockquote><p>多媒体内容是对多媒体数据的描述，多媒体信息是对多媒体 内容的描述，多媒体内容不都是多媒体信息，多媒体信息不一定包含全部多媒体内容</p></blockquote><p>多媒体内容处理分类 ~6~</p><blockquote><p>多媒体内容分析</p><p>多媒体内容分类</p><p>多媒体内容管理多媒体内容搜索</p><p>多媒体内容检索</p><p>多媒体内容浏览 </p></blockquote><p>多媒体国际标准</p><blockquote><p>ITU标准 </p><p>ISO/IEC标准</p><p>因特网技术标准 </p><p>万维网协会(W3C)标准</p></blockquote><p>数据压缩</p><blockquote><p>意义：</p><ul><li>降低多媒体数据对存储器容量的要求 </li><li>降低多媒体数据对传输带宽的要求 </li></ul><p>分类：</p><ul><li>无损压缩: 经过压缩和解压缩后的数据与压缩前的 原始数据完全一样的数据压缩技术 </li><li>有损压缩:经过压缩和解压缩后的数据与压缩前的 原数据不完全一样 </li></ul></blockquote><p>编码方式</p><blockquote><p>熵编码:不考虑数据源的无损数据压缩技术。其核 心思想是按照符号出现的概率大小给符号分配长度合适的代码 </p><p>源编码:考虑数据源特性的数据压缩技术。编码时 考虑信号源的特性和信号的内容 </p><p>混合编码:组合源编码和熵编码的数据有损压缩技术 </p></blockquote><p><img src="1.png" width=600></p><p>计算机网络</p><blockquote><ul><li><p>因特网：通过网络设备把世界各国使用TCP/IP协议的计算机相互连接在一起的计算机网络 </p></li><li><p>互联网：泛指多种网络通过网络互连设备互连而成的网络 </p></li><li><p>万维网：分布在全世界所有HTTP服务器上互相连接的超媒体文档的集合 </p><blockquote><p>万维网的三项核心技术 </p><ul><li>统一资源地址(URL)</li><li>超文本传输协议(HTTP) </li><li>超链接(HyperLink)  </li></ul></blockquote></li></ul></blockquote><p>通用内容标记语言SGML</p><blockquote><p>国际标准化组织(ISO)采用的一个信息管理标准 。该标准定义独立于平台和应用的文本文档的格式、索引和链接信息，为用户提供一种类似于语法的机制，用来定义文档的结 构和指示文档结构的标签</p><p>SGML的精华是把文档的内容与样式分开处理  </p></blockquote><p>HTML</p><blockquote><p>HTML是万维网上的文档所用的标记语言 </p><ul><li>HTML是SGML的一个子集。SGML使用标签来标志文档中的文本或图形之类的元素， 并告诉Web浏览器该如何向用户显示这些元素，以及应该如何响应用户的行为，例如当用户通 过按键或鼠标单击某个链接时该如何响应 </li></ul></blockquote><p>多媒体、万维网和因特网之间有何关系? </p><blockquote><p>多媒体构成了超媒体系统，超媒体系统构成了万维网，万维网是因特网上使用TCP/IP协议和UDP/IP协议的系统</p></blockquote><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><p>数据可被压缩的依据 </p><ul><li>数据本身存在冗余  </li><li>听觉系统的敏感度有限 </li><li>视觉系统的敏感度有限 </li></ul><p>三种多媒体数据类型</p><blockquote><p>文字 (text)数据——无损压缩 </p><blockquote><p>根据数据本身的冗余</p></blockquote><p>声音(audio)数据——有损压缩</p><blockquote><p>根据数据本身的冗余</p><p>根据人的听觉系统特性</p></blockquote><p>图像(image)/视像(video) 数据——有损压缩</p><blockquote><p>根据数据本身的冗余</p><p>根据人的视觉系统特性 </p></blockquote></blockquote><p>冗余</p><blockquote><p>人为冗余  </p><p>视听冗余</p><p>数据冗余</p></blockquote><p>决策量(注意单位)</p><blockquote><p>$H_0=log(n)$</p><p>条件：有限数目的互斥事件集合</p><ul><li>Sh (Shannon): 用于以2为底的对数</li><li>Nat (natural unit): 用于以e为底的对数 </li><li>Hart (hartley):用于以10为底的对数 </li></ul></blockquote><p>信息量(注意单位)</p><blockquote><p>具有确定概率事件的信息的定量度量 </p><p>$I(x)=-log_2P(x)$</p><ul><li>一个等概率事件的集合，每个事件的信息量等于该集合的决策量 </li></ul></blockquote><p>熵(注意单位)</p><blockquote><p>有限的互斥和联合穷举事件的集合中，熵为事件的信息量的平均值，也称事件的平均信息量 </p><script type="math/tex; mode=display">H(x)=-\sum_{i=1}^np(x_i)log_2p(x_i)=\sum_{i=1}^np(x_i)I(x_i)</script></blockquote><p>数据冗余量</p><blockquote><p>决策量H~0~超过熵H的量</p><p>$R=H_0-H$</p></blockquote><h4 id="统计编码"><a href="#统计编码" class="headerlink" title="统计编码"></a>统计编码</h4><blockquote><p>给已知统计信息的符号分配代码的数据无损压缩方法 </p><h5 id="香农-范诺编码"><a href="#香农-范诺编码" class="headerlink" title="香农-范诺编码"></a>香农-范诺编码</h5><blockquote><p>在香农的源编码理论中，熵的大小表示非冗余的不可压缩的信息量</p><p>步骤：</p><ul><li>按照符号出现的概率减少的顺序将待编码的符号排成序列。</li><li>将符号分成两组，使这两组符号概率和相等或几乎相等。</li><li>将第一组赋值为0，第二组赋值为1。(书上大0小1)</li><li>对每一组，重复步骤2的操作。</li></ul></blockquote><h5 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h5><blockquote><p><img src="6.png" width=500></p><p>(书上大1小0)</p></blockquote><h5 id="算数编码"><a href="#算数编码" class="headerlink" title="算数编码"></a>算数编码</h5><blockquote><p>对10 00 11 00 10 11 01进行算数编码</p><ul><li>初始化</li></ul><p><img src="2.png" width=500></p><ul><li>确定符号的编码范围 <ul><li>编码时输入第1个符号是10，找到它的编码范围是 [0.5, 0.7] </li><li>消息中第2个符号00的编码范围是[0, 0.1)，它的间隔 就取[0.5, 0.7)的第一个十分之一作为新间隔[0.5, 0.52) </li><li>编码第3个符号11时，取新间隔为[0.514, 0.52) </li><li>编码第4个符号00时，取新间隔为[0.514, 0.5146) </li><li>依此类推…… </li><li>消息的编码输出可以是最后一个间隔中的任意数 </li></ul></li></ul><p><img src="3.png" width=500></p><p>解码：</p><p><img src="4.png" width=500></p></blockquote></blockquote><h4 id="行程长度编码"><a href="#行程长度编码" class="headerlink" title="行程长度编码"></a>行程长度编码</h4><blockquote><p> <img src="5.png" width=500></p></blockquote><h3 id="声音编码"><a href="#声音编码" class="headerlink" title="声音编码"></a>声音编码</h3><p>声音</p><blockquote><p>声音是听觉器官对声波的感知，而声波是通过介质连续振动 </p><p>声音的强弱体现在声波幅度的大小上，音调的高低体现在声音的频率上</p></blockquote><p>声音频率</p><blockquote><ul><li>高保真声音(high-fidelity audio): 10 ~ 20 000 Hz </li><li>音频(audio): 20~ 20000Hz  </li><li>话音(speech): 300~3000/3400 Hz  </li><li>亚音/次音(subsonic): &lt; 20 Hz  </li><li>超声(ultrasonic): &gt; 20 000 Hz </li></ul></blockquote><p>声音的等级</p><blockquote><p><img src="7.png" width=500></p></blockquote><p>声音质量的衡量方法</p><blockquote><ul><li>声音带宽法</li><li>客观质量度量</li><li>主观质量度量</li></ul><p>主观评分MOS标准</p><p><img src="8.png" width=500></p></blockquote><p>声音大小计算</p><blockquote><p>$(f_s\times 时间长度 \times 采样精度字节数 \times 声道数)/(1024  \times 1024) MB$</p><p>立体声：双声道</p></blockquote><p>采样</p><blockquote><p>对连续时间的离散化,在某些特定的时刻对模拟信号进行测量的过程  </p><ul><li>每隔相等的一段时间采样一次，这种采样称为均匀采样 </li></ul></blockquote><p>量化</p><blockquote><p>对连续幅度的离散化，就是把信号的强度分段</p><ul><li>如果幅度的划分是等间隔的，就称为线性量化，否则就称为非线性量化 </li></ul></blockquote><p>采样频率</p><blockquote><p>奈奎斯特理论指出，采样频率不应低于声音信号最高频率的两倍，这样就能把以数字表达的声音还原成原来的声 音，这叫做无损数字化</p><p>$f<em>s\geq 2f</em>{max}$</p></blockquote><p>采样精度</p><blockquote><ul><li><p>度量声音波形幅度的精确程度，用每个声音样本的位数(即bps)表示 </p></li><li><p>量化阶：精度($\frac{1}{2^n}$)</p></li><li><p>信号噪声比：(n为每个样本位数)</p><script type="math/tex; mode=display">SNR=20log_{10}\frac{V_{signal}}{V_{noise}}=20lg2^n</script><p> 其中，V~signal~表示信号电压，V~noise~表示量化噪声电压(模拟信号的采样值和与它最接近的数 字数值之间的差值)，SNR的单位为分贝(db) </p></li></ul></blockquote><p>脉冲编码调制(PCM) </p><blockquote><p><img src="9.png" width=500></p><p>输入是模拟信号，输出是PCM样本。 </p><p>防失真滤波器:低通滤波器，用来滤除声音频带以 外的信号 </p><p>波形编码器:可理解为采样器 </p><p>量化器:可理解为“量化阶大小(step-size)”生成器或者称为“量化间隔”生成器 </p><p>时分多路复用</p><blockquote><p>24路制</p><ul><li>每秒钟传送8000帧，每帧 125μs </li><li>12帧组成1复帧 </li><li>每帧由24个时间片(信道)和1位同步位组成</li><li>每个信道每次传送8位代码 ，1帧有193位</li><li>数据传输率R=8000x193=1544kb/s</li><li>每一个话路的数据传输率= 8000×8=64 kb/s </li></ul><p>30路制</p><ul><li>每秒钟传送8000帧，每帧125μs </li><li>16帧组成1复帧  </li><li>每帧由32个时间片(信道)组成  </li><li>每个信道每次传送8位代码  </li><li>数据传输率:R=8000×32×8=2048 kb/s  </li><li>每一个话路的数据传输率=8000×8=64 kb/s </li></ul><p>T1等级：1544kb/s数据率(24路制)</p><p>E1等级：2048kb/s数据率(30路制)</p><p>T2等级：5312kb/s</p><p>E2等级：8448kb/s</p></blockquote></blockquote><p>模拟声音数字化的两个步骤 </p><blockquote><p>采样</p><p>量化</p></blockquote><p>量化方法</p><blockquote><p>均匀量化</p><p>非均匀量化：大的输入信号采用大的量化间隔，小的输入信号采用小的量化间隔 </p><blockquote><p>$\mu$率压扩：在脉冲编码调制(PCM)系统中，一种模拟信号和数字信号之间进行转换的CCITT压(缩) 扩(展)标准。在北美PCM电话网中，使用μ率压扩算法 </p><p>A率压扩：在脉冲编码调制(PCM)系统中，一种模拟信号和数字信号之间进行转换的CCITT压(缩) 扩(展)标准。在欧洲电话网，使用A律压扩算法</p></blockquote></blockquote><p>增量调制</p><blockquote><p>固定量化阶可能产生的问题：</p><ul><li><p>斜率过载失真：</p><blockquote><p>由于当输入信号的斜率较大，<a href="https://baike.baidu.com/item/%E8%B0%83%E5%88%B6">调制</a>器跟踪不上输入信号的变化</p></blockquote></li><li><p>粒状噪声失真：</p><blockquote><p>输入信号变化缓慢，增量调制器输出会出现0、1交替的情况</p></blockquote></li></ul><p>自适应增量调制(ADM) </p><blockquote><p>根据输入信号斜率的变化自动调整量化阶Δ的大 小，以使斜率过载和粒状噪声都减到最小。 </p><p>在检测到斜率过载时开始增大量化阶Δ，而在输入 信号的斜率减小时降低量化阶Δ </p><ul><li>例如，宋(Song)在1971描述的ADM技术中提出:每当输出 不变时量化阶增大50%;每当输出值改变时，量化阶减小 50% </li><li>又如，由格林弗基斯(Greefkes)在1970年提出的连续可变斜 率增量调制(CVSD)的基本方法是:如果连续可变斜率增量 调制器的输出连续出现三个相同值时，量化阶加一个大的 增量，反之，就加一个小的增量 </li></ul></blockquote></blockquote><p>自适应脉冲编码调制 APCM</p><blockquote><p>根据输入信号幅度大小来改变量化阶大小的一种波形编码技术</p><p>自适应</p><blockquote><ul><li>瞬时自适应，即量化阶的大小每隔几个样本就改变 </li><li>音节自适应，即量化阶的大小在较长时间里发生变化 </li></ul></blockquote><p>改变量化阶大小的方法</p><blockquote><p><img src="10.png" width=500></p><p><img src="11.png" width=500></p><p>思想</p><blockquote><p>根据输入信号幅度大小来改变量化阶大小的一种波形编码技术。这种自适应可以是瞬时自适应，即量化阶的大小每隔几个样本就改变，也可以是音节自适应，即量化阶的大小在较长时间周期里发生变化 </p></blockquote></blockquote></blockquote><p>差分脉冲编码调制 DPCM</p><blockquote><p>基本思想</p><blockquote><p>利用样本与样本之间存在的信息冗余度来进行编码的一种数据压缩技术。这种技术是根据过去的样本去估算(estimate)下一个样本信号的幅度大小，这个值称为预测值，然后对实际信号值与预测值之差进行量化编码，从而就减少了表示每个样本信号的位数。</p><p>它与脉冲编码调制 (PCM)不同的是，PCM是直接对采样信号进行量化编码，而DPCM是对实际信号值与预测值之差进行量化编码，存储或者传送的是差值而不是幅度绝对值，这就降低了传送或存储的数据量。此外，它还能适应大范围变化的输入信号</p></blockquote></blockquote><p>自适应差分脉冲编码调制 ADPCM</p><blockquote><p>综合了APCM的自适应特性和DPCM系统的差分特 性，是一种性能比较好的波形编码技术 </p><p>基本思想</p><blockquote><ul><li><p>利用自适应的思想改变量化阶的大小，即使用小的量化阶(step-size)去编码小的差值，使用大的量化阶去编码大的差值 </p></li><li><p>使用过去的样本值估算下一个输入样本的预测值，使实际样本值和预测值之间的差值总是最小</p></li></ul></blockquote></blockquote><p>编码性能</p><blockquote><p><img src="12.png" width=500></p></blockquote><p>MIDI</p><blockquote><p>音乐合成器乐器和计算机之间交换音乐信息的一种标准协议。 </p><p>特点:  文件比较小;容易编辑等 </p></blockquote><h3 id="色彩数字图像基础"><a href="#色彩数字图像基础" class="headerlink" title="色彩数字图像基础"></a>色彩数字图像基础</h3><p>颜色</p><blockquote><p>视觉系统对可见光的感知结果，感知的颜色由光的波长决定</p><p>颜色只存在于眼睛和大脑</p><blockquote><ul><li>人的视网膜有对红、绿、蓝颜色敏感程度不同的三种锥体细胞</li><li>杆状体细胞在光功率极低的条件下才起作用</li></ul></blockquote></blockquote><p>有源物体</p><blockquote><p>一个能发出光波的物体称为有源物体，它的颜色由该物体发出的光波决定 </p><p><strong>RGB相加混色模型</strong></p><p> 组合红、绿和蓝光波来产生特定颜色的方法叫做相加混色法 </p><p> <img src="13.png"></p></blockquote><p>无源物体</p><blockquote><p>一个不发光波的物体称为无源物体 ，它的颜色由该物体吸收或者反射哪些光波决定</p><p><strong>CMY相减混色模型</strong></p><p> 用三种基本颜色即青色(cyan)、品红(magenta)和黄色 (yellow)的颜料按一定比例混合得到颜色的方法，通常写 成CMY，称为CMY模型</p><p> <img src="14.png" width="250px"></p></blockquote><p>图像基本属性</p><blockquote><p>屏幕分辨率</p><blockquote><p>水平像素数×垂直像素数，是衡量显示设备再现图像时所能达到的精细程度的度量方法，也称显示分辨率 </p></blockquote><p>图像分辨率</p><blockquote><p>图像分辨率也称空间分辨率和像素分辨率,是图像精细程度的度量方法</p><p>在图像显示应用中的图像分辨率表示法</p><blockquote><ul><li>物理尺寸:每毫米线数(或行数)</li><li>行列像素:像素/行×行/幅，如640像素/行×480行/幅</li><li>像素总数:如数码相机上标的500万像素</li><li>单位长度上的像素:如像素每英寸(pixels per inch，PPI)</li><li>线对数:以黑白相邻的两条线为一对如5对线 </li></ul></blockquote><p>在图像数字化和打印应用中的图像分辨率表示法</p><blockquote><ul><li>通常用多少点每英寸(dots per inch，DPI)表示</li><li>分辨率越高，图像质量就越高，像素就越多，要求存储容量就越大</li></ul></blockquote></blockquote></blockquote><p>像素深度</p><blockquote><p>存储每个像素所用的位数</p></blockquote><p>$\alpha$通道</p><blockquote><p>在每个像素用32位表示的图像表示法中的高8位，用于表示像素在一个对象中的透明度 </p></blockquote><p>真彩色</p><blockquote><p>像素颜色直接用RGB表示</p></blockquote><p>伪彩色</p><blockquote><p>将像素值当作彩色查找表(color look-up table)的表项入口地址，查找显示图像时要使用的R，G，B值，用查找出的R，G，B值产生的彩色 </p><ul><li>使用查找得到的R，G，B数值显示的彩色是真的，但不是图像本身真正的颜色，它没有完全反映原图的颜色 </li></ul></blockquote><p>直接色</p><blockquote><p>每个像素值由R，G，B分量构成，每个分量作为单独的索引值对它做变换，用变换后的R，G，B值产生的颜色 </p></blockquote><p>矢量图</p><blockquote><p>根据数学规则描述而生成的图 </p><p>优点</p><ul><li>易对图像变换</li><li>可快速生成、文件大小小</li></ul><p>缺点</p><ul><li>很难用数学方法来描述真实世界的彩照 </li></ul></blockquote><p>位图</p><blockquote><p>用像素值阵列表示的图</p></blockquote><p>灰度图</p><blockquote><p>只有明暗不同的像素而没有彩色像素组成的图像</p><p>只有黑白两种颜色的图像称为<strong>单色图像</strong> </p></blockquote><p>$\gamma$校正</p><blockquote><p>在屏幕上显示用离散量表示的色彩时采用的一种色彩调整技术。计算机显示器和电视采用的阴极射线管产生的光亮度与输入的电压不成正比。$\gamma$值一般在2.5左右 </p><p>在把输入电压送到显示设备之前对它做一次变换，使输入到显示设备的电压′= (输入电压)^γ^ </p><p>光亮度=(输入电压)$^\gamma$</p></blockquote><p>JPEG</p><blockquote><p>Joint Photographic Experts Group的缩写，联合图像专家组</p><p>在压缩比为25∶1的情况下，压缩后还原得到的图像与原始 图像相比，非图像专家难于找出它们之间的区别 </p><p>JPEG标准  </p><blockquote><p>静态图像数据压缩标准，用于压缩灰度图像和彩色图像 </p></blockquote><p>步骤</p><ul><li>使用正向离散余弦变换(FDCT)把空间域表示的 图变换成频率域表示的图</li><li>使用加权函数对DCT系数进行量化</li><li>使用霍夫曼编码器对量化系数进行编码</li></ul><p>JPEG算法与颜色空间无关 </p><p>DCT(离散余弦变换 )</p><blockquote><ul><li>用余弦函数的离散值构成的变换矩阵对信号进行数学变换 </li><li>可将能量集中到频率较低的系数上 </li><li>将分量图像分成8×8的图块 </li></ul></blockquote><p>量化</p><blockquote><p>对DCT变换后的系数进行量化</p><ul><li>目的：增加0值个数</li><li>分开使用亮度量化表和色度量化表</li></ul></blockquote><p>Z字形编排</p><blockquote><p><img src="15.png"></p><p>目的：增加连续0元个数</p></blockquote><p>熵编码</p><blockquote><p>用DPCM对DC系数进行编码，用RLE对AC系数编码</p><p>使用Huffman编码对整体编码</p></blockquote><p>步骤特性</p><blockquote><ul><li>DCT变换: 无损 </li><li>量化: <strong>有损</strong>  </li><li>Z字形编码: 无损  </li><li>使用DPCM对直流系数(DC)进行编码: 无损 </li><li>使用RLE对交流系数(AC)进行编码: 无损 </li><li>熵编码:无损 </li></ul></blockquote></blockquote><p>BMP文件</p><blockquote><p><img src="16.png" width=600></p><p>无损压缩</p><p>伪彩色</p></blockquote><p>GIF</p><blockquote><p>采用LZW压缩(无损压缩)</p><p>伪彩色</p><p>透明性</p></blockquote><p>PNG</p><blockquote><p>PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的α通道数据</p><p>采用LZ77派生的无损压缩算法</p><p>伪彩色</p><p>透明性</p></blockquote><p>总结</p><blockquote><p><img src="17.png"></p><p>16777216 = 2^24^</p><p>256 = 2^8^</p></blockquote><h3 id="颜色的度量"><a href="#颜色的度量" class="headerlink" title="颜色的度量"></a>颜色的度量</h3><p>颜色的研究史</p><blockquote><ul><li><p>Newton:发明了色环，发现白光包含所有可见光谱波长</p><ul><li><img src="18.png" width=200px></li></ul></li><li><p>Thomas :认为人的眼睛有三种不同类型的颜色感知接收器，大体上相当于红、绿和蓝 三种基色的接收器。 </p></li><li><p>Maxwell:探索了三种基色的关系，并且认识到三种基色相加产生的色调不能覆盖整个感知色调的色域，而使用相减混色产生的色调却可以。他认识到彩色表面的色调和饱和度对眼睛的敏感度比明度低。Maxwell的工作可被认为是现代色度学的基础。 </p></li><li><p>Munsell:开发了第一个广泛被接受的颜色次序制，称为Munsell color system，对颜色作了精确的描述并用在他的教学中。Munsell颜色次序制也是其他颜色体系的基础。</p><blockquote><p> 指出颜色的HSB特性，把明度从色调和饱和度中分离出来</p></blockquote></li><li><p>Ostwald:开发了Ostwald颜色体系，根据对颜色起决定作用的波长、纯度和亮度来映射 色调、饱和度和明度的值。</p><blockquote><p>C(全彩色)W(白色)B(黑色) </p></blockquote></li><li><p>CIE定义了许多度量颜色的标准 </p></li></ul></blockquote><p>颜色特性</p><blockquote><p>视觉感知的光波范围是380~780nm</p><ul><li><p>色调(hue)，纯色由光的波长定义，即光谱色</p><blockquote><p>对光的波长的感知</p></blockquote></li><li><p>饱和度(saturation) </p><blockquote><p>颜色的纯度</p><ul><li>光波掺入其它光的成分越多，饱和度越低</li></ul></blockquote></li><li><p>明度(brightness) </p><blockquote><p>视觉系统对可见物体辐射光或发射光多少的非定量感知 </p><ul><li>明度和反射率成对数关系</li></ul></blockquote></li></ul></blockquote><p>亮度(luminance)</p><blockquote><p>单位面积反射或发射的光强</p><p>与brightness的区别</p><blockquote><p>luminance可计量，brightness考虑主观感受，不可计量</p><p>luminance指定白光作为参考</p></blockquote></blockquote><p>光亮度(lightness )</p><blockquote><p>视觉系统对亮度(luminance)的感知响应值，用L^*^表示</p></blockquote><p>颜色空间(颜色模型)</p><blockquote><p>使用数学方法描述所有颜色的一套规则和定义 </p><p>分类</p><ul><li>设备相关：指定生成的颜色与生成颜色的设备有关，如RGB</li><li>设备无关：指定生成的颜色与生成颜色的设备无关 ，如L^<em>^a^</em>^b^*^ </li></ul></blockquote><p>颜色系统(color system)(颜色度量体系、颜色制)</p><blockquote><p>组织和表示颜色的方法 </p><p>方法</p><ul><li>颜色模型</li><li>编目系统</li></ul></blockquote><p>RGB颜色匹配函数</p><blockquote><p>匹配每种光波波长所需要的三种相加基色的相对量 </p><p><img src="19.png" width=400></p></blockquote><p>标准白光E~w~匹配</p><blockquote><p>用红、绿和蓝三基色光匹配成 白光时，所需红、绿和蓝基色光的光通量之比为 1∶4.5907∶0.0601</p><p>R=1个红基色光单位=1光瓦</p><p>G=1个绿基色光单位=4.5907光瓦</p><p>B=1个蓝基色光单位=0.0601光瓦</p><p>1光瓦=680流明(lm) </p><p>CEw =1xR+1xG+1xB  </p></blockquote><p>CIE XYZ</p><blockquote><p>规定X、Y和Z基色都用正数去匹配所有的颜色， 并用Y值表示人眼对亮度(luminance)的响应 </p><p><img src="21.png" width=400></p><p><img src="20.png" width=400></p><p>X=Y=Z合成白光E~w~</p></blockquote><p>CIE xyY</p><blockquote><p>把XYZ颜色投影到x+y+z=1平面</p><p><img src="22.png" width=400></p><p>x：红色分量；y：绿色分量；z：蓝色分量</p><p>将XYZ投影到XY平面：xyY色度图：</p><p><img src="23.png" width=600></p><p>等色调、等饱和度线</p><p><img src="24.png" width=400></p><p>xyY的缺点</p><ul><li>明度未反映</li><li>感知非均匀</li></ul></blockquote><p>CIE L^<em>^a^</em>^b^*^</p><blockquote><p>基于对色理论</p><p>红、黄、绿和蓝四种基色 ，红-绿和黄-蓝构成两对对立色调，黑-白是另外一对 </p><p>红和黄认为是“暖色，绿和蓝是冷色</p></blockquote><h3 id="颜色空间变换"><a href="#颜色空间变换" class="headerlink" title="颜色空间变换"></a>颜色空间变换</h3><p>颜色空间分类</p><blockquote><p>感知角度</p><ul><li>混合型颜色空间：RGB，CMY(K)和XYZ  </li><li>非线性亮度/色度型颜色空间：L^<em>^a^</em>^b^<em>^, L^</em>^u^*^v，YUV和YIQ </li><li>强度/饱和度/色调型颜色空间：HSI, HSL, HSV和LCh </li></ul><p>技术角度</p><ul><li><p>RGB型</p><blockquote><p>主要用于电视 机和计算机的颜色显示系统 </p></blockquote></li><li><p>XYZ型</p><blockquote><p>与设备无关的颜色表示法，在科学计算中得到广泛应用</p></blockquote></li><li><p>YUV型</p><blockquote><p>由广播电视需求的 推动而开发的颜色空间</p></blockquote><p><img src="25.png" width=600></p></li></ul></blockquote><p>颜色空间的选择</p><blockquote><p><img src="26.png" width="500px"></p><p><img src="27.png" width=500px></p><p>CMYK：用于印刷</p><p>PAL制彩色电视(欧洲的模拟彩色电视)</p><ul><li>YUV</li></ul><p>NTSC制彩色电视(北美模拟彩色电视系统 )</p><ul><li>YIQ</li></ul><p>计算机图像显示设备</p><ul><li>RGB</li></ul></blockquote><p>用YUV或YIQ模型来表示彩色图像的优点</p><blockquote><ul><li>它的亮度信号(Y)和色度信号(U，V)是相互独立的，因此可以 对这些单色图分别进行编码</li><li>可以利用人眼的特性来降低数字彩色图像所需要的存储容量。 </li></ul></blockquote><p>黑白电视机可看彩色电视图像的原因</p><blockquote><p>黑白电视能接收彩色电视信号的道理是利用了YUV/YIQ分量之间的独立性  </p></blockquote><p>RGB$\to$HSL算法(教材222页)</p><blockquote><p><img src="29.jpg" width=500></p></blockquote><p>HSL$\to$RGB算法</p><blockquote><p><img src="30.jpg" width=500></p></blockquote><h3 id="彩色电视基础"><a href="#彩色电视基础" class="headerlink" title="彩色电视基础"></a>彩色电视基础</h3><p>主要的彩色电视制式(互不兼容)</p><ul><li><p>PAL</p><blockquote><ul><li><p>德国制定</p></li><li><p>德国、英国等一些西欧国家，以及中国、朝鲜等国家采用</p></li><li><p>特性</p><blockquote><p>图像的宽高比为4:3，625条扫描线，隔行扫描，25帧图像每秒，视像带宽至少为4 MHz，使用YUV颜色模型，色度 信号用正交幅度调制，声音用调频制(FM)，总的电视通道 带宽为8 MHz </p></blockquote></li></ul></blockquote></li><li><p>NTSC</p><blockquote><ul><li><p>美国国家电视系统委员会制定</p></li><li><p>美国、加拿大等大部分西半球国家以及日本、韩国、菲律 宾和台湾地区采用 </p></li><li><p>特性</p><blockquote><p>图像的宽高比为4:3，525条扫描线，隔行扫描，30帧每 秒，视像带宽为4.2 MHz，使用YIQ信号，色度信号用正交 幅度调制(QAM)，声音用调频制(FM)，总的电视通道带宽 为6 MHz </p></blockquote></li></ul></blockquote></li><li><p>SECAM</p><blockquote><ul><li>法国制定</li><li>法国、俄罗斯、东欧和中东等约有60多个地区和国家使用</li><li>SECAM制与PAL制具有相同的扫描线数(625线每帧)、帧 频(25帧每秒，50场每秒)和图像宽高比(4:3)，视像带宽最 高为6 MHz，总带宽为8 MHz</li></ul></blockquote><p><img src="28.png" width=600></p><p>逐行扫描</p><blockquote><p>电子束从显示屏的左上角一行 接一行地扫到右下角，在显示屏上扫一遍就显示一幅完整的图像 </p></blockquote><p>隔行扫描</p><blockquote><p>电子束扫完第1行后从第3行开始扫，接着扫第5行、7 行、…，一直扫到最后一行的 中间 </p></blockquote><p>扫描术语</p><blockquote><p>行频/水平行速率(horizontal line rate) fH ，每秒钟扫描的行数</p><blockquote><p>NTSC制精确的帧频是29.97 Hz，525行每帧，因此行频为29.97×525=15 734行/秒 </p></blockquote><p>场频/场速率(field rate) f~f~，每秒钟扫描的场数</p><blockquote><p>根据人的视觉特性和电网频率(50Hz或60Hz)确定的，目的 是使在屏幕上显示的图像看起来不会让人感觉到在闪烁， 以及减低电网频率的干扰 </p></blockquote><p>帧频/帧速率(frame rate) f~F~ ，每秒扫描的帧数</p><blockquote><ul><li>用“帧每秒(frames per second，fps)”做单位  </li><li>PAL制和NTSC制电视的帧频分别为25 fps和30 fps</li></ul></blockquote></blockquote><p>S-Video信号</p><blockquote><p>亮度信号(Y)和色度信号(C)分开录制和处理的电视信号</p><p>优点</p><ul><li>减少亮度信号和色差信号之间的交叉干扰  </li><li>不需使用梳状滤波器分离亮度信号和色差信号 </li></ul></blockquote></li></ul><p>电视图像数字化</p><blockquote><ul><li><p>分量数字化</p><blockquote><p>对彩色空间的每个分量进行数字化，如对YCbCr，YUV，YIQ或RGB颜色空间中的分量 </p></blockquote></li><li><p>信号源 </p><blockquote><p>录像带、激光视盘和模拟摄像机等输出的彩色全电视信号</p></blockquote></li></ul><p>方法</p><blockquote><ul><li><p>先分离后数字化</p><blockquote><p>先把模拟的全彩色电视信号分离成YCbCr，YUV，YIQ或 </p><p>RGB彩色空间中的分量信号</p><p>用三个A/D转换器分别对分量信号数字化 </p></blockquote></li><li><p>先数字化后分离 </p><blockquote><p>用一个高速A/D转换器对彩色全电视信号进行数字化</p><p>在数字域中分离出YCbCr，YUV，YIQ或RGB颜色空间中的分量数据 </p></blockquote></li></ul></blockquote></blockquote><p>有效显示分辨率</p><blockquote><p>对所有制式，每一扫描行的有效样本数均为720个</p></blockquote><p>图像子采样</p><blockquote><p>对色差信号使用的采样频率比对亮度信号使用的采样频率低的采样方法</p><p>可采用方式</p><ul><li>对亮度信号和色差信号采用相同的采样频率进行采样  </li><li>对亮度信号和色差信号采用不同的采样频率进行采样</li></ul><p>依据</p><ul><li>人眼对色度信号的敏感程度比对亮度信号的敏感程度低</li><li>人眼对图像细节的分辨能力有一定的限度</li></ul><p>在YCbCr空间执行</p><p>采样方式</p><blockquote><p>4:4:4</p><blockquote><p>这种采样格式不是子采样格式，它是 指在每条扫描线上每4个连续的采样点取4个 亮度Y样本、4个红色差Cr样本和4个蓝色差 Cb样本，每个像素用<strong>3</strong>个样本表示</p></blockquote><p>4:2:2</p><blockquote><p>在每条扫描线上，每4个连续的采样点 取4个亮度Y样本、2个红色差Cr样本和2个蓝 色差Cb样本，平均每个像素用<strong>2</strong>个样本表示 </p></blockquote><p>4:1:1</p><blockquote><p>在每条扫描线上，每4个连续的采样点 取4个亮度Y样本、1个红色差Cr样本和1个蓝 色差Cb样本，平均每个像素用<strong>1.5</strong>个样本表示 </p></blockquote><p>4:2:0</p><blockquote><p>在水平和垂直方向上，每2个连续采样 点上取2个亮度Y样本、1个红色差Cr样本和1 个蓝色差Cb样本，每个像素用<strong>1.5</strong>个样本表示</p></blockquote></blockquote></blockquote><p>数字电视</p><blockquote><p>数字电视是远程通信系统 </p><ul><li>使用数据压缩技术和数字传输技术 </li><li>提供质量高于模拟的电视的图像和声音</li><li>图像使用MPEG-2 Video标准，声音使用MPEG-2 Audio或杜比数字(Dolby Digital)标准</li><li>采用的标准不断修改</li></ul><p>传输方式</p><ul><li>卫星转播:卫星数字电视(digital satellite TV) </li><li>地面广播:地面数字电视(digital terrestrial TV) </li><li>电缆传输:有线数字电视(digital cable TV) </li></ul><p>数字电视标准</p><ul><li>美国的ATSC DTV(ATSC数字电视)标准</li><li>欧洲的DVB (数字电视广播)标准</li><li>日本的ISDB(综合业务数字广播)标准 </li></ul></blockquote><h3 id="MPEG简介"><a href="#MPEG简介" class="headerlink" title="MPEG简介"></a>MPEG简介</h3><p>回顾制定MPEG标准的4个阶段和各阶段的提交的文件类型。</p><blockquote><ul><li>工作文件(Working Draft，WD):工作组(Working Group，WG)准备的工作文件</li><li>委员会草案(Committee Draft，CD):从工作组WG准备好的工作文件WD提升上来的文 件。这是ISO文档的最初形式，它由ISO内部正式调查研究和投票表决。</li><li>国际标准草案(Draft International Standard，DIS):投票成员国对CD的内容和说明满意 之后由委员会草案CD提升上来的文件。</li><li>国际标准(International Standard，IS):由投票成员国、ISO的其他部门和其他委员会投票通过之后出版发布的文件。</li></ul></blockquote><p>MPEG-1, -2, -4和-7的目标是什么?<br>&gt;</p><blockquote><ul><li>MPEG-1处理的是标准图像交换格式的电视，即NTSC制为352像素 × 240行/帧 × 30帧/秒， PAL制为352像素×288行/帧×25帧/秒，压缩的输出速率定义在1.5 Mb/s以下。这个标准主要是针 对当时具有这种数据传输率的CD-ROM和网络而开发的，用于在CD-ROM上存储数字影视和在 网络上传输数字影视。</li><li>MPEG-2标准是一个直接与数字电视广播有关的高质量图像和声音编码标准，是MPEG-1的扩充。MPEG-2提供位速率的可变性能功能，其最基本目标是:位速率为4~9 Mb/s，最高达 15 Mb/s。</li><li>MPEG-4是为视听数据的编码和交互播放开发算法和工具，是一个数据速率很低的多媒体 通信标准。MPEG-4的目标是要在异构网络环境下能够高度可靠地工作，并且具有很强的交互 功能。</li><li>MPEG-7的名称叫做多媒体内容描述接口，目的是制定一套描述符标准，用来描述各种类型的多媒体信息及它们之间的关系，以便更快更有效地检索信息。这些媒体材料可包括静态图 像、图形、3D模型、声音、话音、电视以及在多媒体演示中它们之间的组合关系。在某些情 况下，数据类型还可包括面部特性和个人特性的表达。</li></ul></blockquote><h3 id="MPEG声⾳"><a href="#MPEG声⾳" class="headerlink" title="MPEG声⾳"></a>MPEG声⾳</h3><p>列出你所知道的听觉系统的特性。</p><blockquote><p>响度感知, 音高感知, 掩蔽效应 </p></blockquote><p>什么叫做听阈?什么叫做痛阈?<br>&gt;</p><blockquote><ul><li>当声音弱到人的耳朵刚刚可以听见时，称此时的声音强度为“听阈”</li><li>当声音强到人的耳朵刚刚感到疼痛时，称此时的声音强度为“听阈”。实验表明，如果 频率为1 kHz的纯音的声强级达到120 dB左右时，人的耳朵就感到疼痛，这个阈值称为 “ 痛 阈”。</li></ul></blockquote><p>什么叫做频域掩蔽?什么叫做时域掩蔽?</p><blockquote><ul><li>强纯音掩蔽在其附近同时发声的弱纯音，这种特性称为频域掩蔽。</li><li>在时间方向上相邻声音之间的掩蔽，这种特性称为时域掩蔽。 </li></ul></blockquote><p>MPEG-1的层1、2和3编码分别使用了听觉系统的什么特性?</p><blockquote><p>层1:频域掩蔽特性 </p><p>层2:频域掩蔽特性，时间掩蔽特性 </p><p>层3:频域掩蔽特性，时间掩蔽特性</p></blockquote><p>MPEG-1的层1、2和3编码器的声音输出速率范围分别是多少? </p><blockquote><p>层1:384 kb/s</p><p>层2:256~192 kb/s </p><p>层3:128~112 kb/s</p></blockquote><p>MPEG-1的声音质量是:</p><blockquote><p>AM FM 电话 near-CD CD-DA □ AM □ FM □ 电话√□ near-CD □ CD-DA</p></blockquote><p>什么叫做5.1声道立体环绕声?什么叫做7.1声道立体环绕声?</p><blockquote><p>“5.1环绕声”也称为“3/2-立体声加LFE”，其中的“.1”是指LFE声道。它的含义是播音现场的前面可有3个喇叭声道(左、中、右)，后面可有2个环绕声喇叭声道，LFE是低频音效的加 强声道。<br>7.1声道环绕立体声与5.1类似。</p></blockquote><p>简述MPEG-2 AAC的特性。</p><blockquote><ul><li>MPEG-2 AAC是MPEG-2标准中的一种非常灵活的声音感知编码标准。它使用听觉系统的 掩蔽特性来减少声音的数据量，并且通过把量化噪声分散到各个子带中，用全局信号把噪声掩 蔽掉。</li><li>AAC支持的采用频率可从8 kHz到96 kHz，AAC编码器的音源可以是单声道的、立体声的 和多声道的声音。AAC标准可支持48个主声道、16个低频音效加强通道LFE、16个配音声道或 者叫做多语言声道和16个数据流。 MPEG-2 AAC在压缩比为11:1，即在每个声道的数据率为(44.1×16 )/11=64 kb/s，而5个声道 的总数据率为320 kb/s的情况下，很难区分还原后的声音与原始声音之间的差别。与MPEG- Audio层2相比，MPEG-2 AAC的压缩率可提高1倍，而且质量更高，与MPEG的层3相比，在质 量相同的条件下数据率是它的70%。</li></ul></blockquote><p>什么叫做自然声音?什么叫做合成声音? </p><blockquote><p>自然声音通常是指人、动物等发出的声音、弹奏乐器或其他音源自然发出的声音。<br>合成声音通常指合成器生成的声音，如MIDI。 </p></blockquote><p>什么叫做TTS?至少列举TTS的3个潜在应用例子。</p><blockquote><p>通过话音合成设备自动地把基于文字的数据转换为声音输出的一种技术。文语转换的最终 目标是要使计算机像人一样输出清晰而又自然的声音，也就是说，根据文本的内容可以不同的 情调来朗读任意的文本。TTS是一个十分复杂的系统，涉及到语言学、语音学、信号处理、人 工智能等诸多的学科。尽管现有的TTS系统结构各异，转换方法不同，但是基本上可以分成两 个相对独立的部分:1文本分析，通过对输入文本进行词法分析、语法分析，甚至语义分析， 从文本中抽取音素和韵律等发音信息。2语音合成，使用从文本分析得到的发音信息去控制合 成单元的谱特征(音色)和韵律特征(基频、时长和幅度)，送入声音合成器(软件或硬件)产生相应 的语音输出。通过电话访问信息，朗读文本，盲人计算机等。</p><h3 id="MPEG电视"><a href="#MPEG电视" class="headerlink" title="MPEG电视"></a>MPEG电视</h3><p>电视图像数据压缩的依据是什么?<br> 根据人的视觉特性和电视图像数据自身的冗余特性。<br> 注:人的视觉系统具有的两种特性可以用来压缩电视图像数据。一是人眼对色度信号的敏 感程度比对亮度信号的敏感程度低，利用这个特性可以把图像中表达颜色的信号去掉一些而使 人不察觉;二是人眼对图像细节的分辨能力有一定的限度，利用这个特性可以把图像中的高频 信号去掉而使人不易察觉。</p></blockquote><p>MPEG-1编码器输出的电视图像的数据率大约是多少? </p><blockquote><p>1.15 Mb/s</p></blockquote><p>MPEG专家组在制定MPEG-1/-2 Video标准时定义了哪几种图像?哪种图像的压缩率最高? 哪种图像的压缩率最低?</p><blockquote><p> (1) MPEG专家组定义了三种图像:帧内图像I(intra)，预测图像P(predicted )和双向预测图 像B (bi-directionally interpolated )。<br> (2) 双向预测图的压缩率最高，帧内图像的压缩率最低。 </p></blockquote><p>有人认为“图像压缩比越高越好”。你对这种说法有何看法?</p><blockquote><p> 在图像压缩算法中，为了获得比较高的压缩率，通常要采用有损压缩。这就意味压缩率越高，图像的质量损失越大，重构图像的质量将会越低。</p></blockquote><p>有人说“MPEG-1编码器的压缩比大约是200:1”。这种说法对不对?为什么?</p><blockquote><p> 不对。理由:(1)电视图像的子采样(4:1:1)不是MPEG编码器的功能，<br> (2)电视图像画面尺寸(如PAL制720×576)的降采样(变成360×288)也不属于MPEG编码器的功能。 </p></blockquote><p>说明电视规格MP@ML和HP@HL各自的含义。</p><blockquote><p> MP@ML (Main Profile, Main Level)指的是具有这种特性的电视:分辨率为720×576×30，子 采样格式为4:2:0，位速率可高达15 Mb/s。<br> HP@HL (High Profile, High Level)指的是具有这种特性的电视:分辨率为1920×1152×60， 子采样格式为4:2:0或者4:2:2，位速率可高达80 Mb/s。</p></blockquote><p>电视图像的空间分辨率和时间分辨率是什么意思? </p><blockquote><p> 空间分辨率:图像的尺寸。例如，PAL制图像尺寸:720×576，360×288。<br> 时间分辨率:图像的帧数/每秒钟。例如，PAL制电视图像的时间分辨率为25帧/秒，NTSC 电视图像的时间分辨率为30帧/秒，电影图像的时间分辨率为24帧/秒。</p></blockquote><p><strong>MP4</strong>或称<strong>MPEG-4第14部分</strong>（英语：MPEG-4 Part 14）</p>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2018/06/19/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2018/06/19/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!-- more --><h2 id="数据库系统相关概念"><a href="#数据库系统相关概念" class="headerlink" title="数据库系统相关概念"></a>数据库系统相关概念</h2><p>数据：符号序列，是计算机能够识别、存储、处理的描述。</p><p>信息：数据的含义</p><p>数据处理：数据—&gt;信息的过程</p><p>数据库：长期存储在计算机内，有组织，可共享的大量数据的集合</p><p>数据库管理系统（DBMS)：用户与数据库之间的管理软件。它提供了：</p><blockquote><p>数据定义功能（数据定义语言DDL）</p><p>数据操纵功能（数据操纵语言DML)</p><p>数据控制语言（数据控制语言DCL)</p><p>数据组织、存储、管理功能</p><p>数据库建立维护功能</p></blockquote><p>数据库系统的组成</p><blockquote><p>硬件系统</p><p>数据库集合</p><p>系统软件</p><p>数据库管理员</p><p>用户</p></blockquote><p>数据库系统有如下功能：</p><blockquote><p>定义数据库</p><p>查询数据库</p><p>更新数据库</p><p>多用户访问</p><p>存储大量数据</p></blockquote><p>数据库系统特点</p><blockquote><p>数据结构不是面向单一应用，而是面向全组织</p><p>数据冗余小、易扩充</p><p>数据独立程序</p><p>统一的数据管理功能</p><ul><li><p>数据安全控制</p></li><li><p>数据完整性控制</p></li><li><p>数据的并发控制（解决多用户情况）</p></li></ul></blockquote><p>数据库管理阶段</p><blockquote><p>人工管理阶段</p><p>文件系统阶段</p><p>数据库系统阶段</p></blockquote><p>模型</p><blockquote><p>概念模型: 按照用户需求对数据库和信息进行建模，涉及实体、属性、联系等概念</p><ul><li><p>实体：客观存在且可相互区分的事物</p></li><li><p>属性：实体具有的特性</p></li><li><p>联系：实体之间的关联关系。联系涉及的概念：</p><p> 1.度：参与联系的实体的个数。</p><p> 2.角色名称：实体在联系中扮演的角色</p><p> 3.递归关系：同一实体以不同的角色名称参与到同一联系中</p><p> 4.基数比：一对一、一对多、多对多</p><p> 5.联系约束：约束参与联系的实体的集合，分为:</p><ul><li>基数比</li><li>参与约束</li></ul></li></ul><p>  6.参与约束：每个实体所能参与联系的最小个数</p><ul><li>完全参与约束也称存在依赖，每个实体都要遵循</li><li>部分参与约束</li></ul><p><strong>数据模型</strong></p><p>数据模型的基本要素</p><ul><li>数据结构</li><li>数据操作</li><li>数据完整性约束</li></ul><p>数据的逻辑模型，省略数据存储的细节，主要用于DBMS的实现，分以下类别：</p><ul><li><p>层次模型（实体之间联系用<strong>树</strong>形结构表示）</p></li><li><p>网状模型（实体之间的联系用<strong>有向图</strong>表示）</p></li><li>关系模型（实体之间的联系由<strong>表</strong>来表示）</li><li>面向对象模型（把实体表示为类，对象中包含了对象内元素的联系和对象之间的联系）</li></ul><p>物理模型</p><ul><li>数据在计算机中存储的具体细节，能够由DBMS理解的模式</li></ul></blockquote><p>三层模式结构</p><ul><li><p>外部层含外模式(视图)</p><p>外部层包含很多外模式，描述特定的数据库</p></li><li><p>概念层含概念模式(关系)</p><p>概念层有一个概念模式也称模式，描述数据逻辑，实体、数据类型、用户操作、约束、安全性和完整性信息</p></li><li><p>内部层含内模式(索引)</p><p>内部层有一个内模式，描述数据库物理储存结构</p></li></ul><ul><li><p>数据库语言</p><ul><li><p>数据查询语言（DQL): 数据查询</p></li><li><p>数据定义语言（DDL): 定义数据结构，创建、修改、删除数据库</p></li><li><p>数据操纵语言（DML): 追加、插入、删除、修改、检索数据</p></li><li><p>数据控制语言（DCL): 控制数据库权限、事务发生时间、监视数据库</p></li></ul></li></ul><p>SQL：关系数据库的标准语言，非过程化。</p><p>数据库管理员（DBA)的职责</p><ul><li>定义并存储数据库内容</li><li>监督和控制数据库使用</li><li>负责数据库的日常维护</li><li>必要时重组、改进数据库</li></ul><h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><p>关系数据模型主要由：关系数据结构、关系数据操作、关系完整性约束组成。</p><p>关系需要满足的条件、性质：</p><ul><li>每一列都不可再分（原子性）</li><li>属性名不可重复</li><li>表中元组的顺序可以调换</li><li>同一属性名下的属性应该在同一域中，是同一数据类型</li><li>元组不能重复</li></ul><p>关系的类型：</p><ul><li>基本关系：实际存在的表，是数据的逻辑表示</li><li>查询表：查询结果对应的表</li><li>视图表：是基本表或其他视图表导出的虚表，不存储数据</li></ul><p>元组：关系的一行</p><p>属性：关系的一列</p><p>域：属性的取值范围，是一组具有相同数据类型的值的集合</p><p>基数：域中包含值的个数</p><p>度：表长</p><p>分量：元组中的一个属性值</p><p>键：唯一区分不同元组的属性或属性的集合</p><p>候选键：唯一区分不同元组的属性或属性的集合</p><p>主键：候选键中选取的一个作为关系的主键</p><blockquote><p>主键唯一</p><p>每个关系必须有且只有一个主键</p></blockquote><p>外键：属性（属性组）F不是关系R的键，但F却是关系S的主键，则属性F是关系R的外键。</p><blockquote><p>关系R：参照关系</p><p>关系S：被参照关系</p><p>R和S可以是同一个关系</p><p>S的主键和F必须在同一域上</p></blockquote><p><strong>关系</strong></p><blockquote><p>笛卡尔积有意义的子集，是一张2维表</p></blockquote><p>关系模式：一般表示为：</p><blockquote><p>R(U,D,DOM,F)</p><p>R:关系名</p><p>U:属性名</p><p>D:U中属性的域</p><p>DOM:属性向域的映射集合</p><p>F:数据依赖关系的集合</p><p>关系完整性：</p><ul><li>实体完整性：主键唯一且非空</li><li>参照完整性：外键要么为空，要么是另一个关系的主键</li><li>用户自定义完整性、</li><li>（空值）</li></ul></blockquote><p>数据操作（为集合操作的方式）</p><blockquote><p>关系代数：代数方式</p><p>关系演算：逻辑方式</p></blockquote><h2 id="关系代数-抽象"><a href="#关系代数-抽象" class="headerlink" title="关系代数(抽象 )"></a>关系代数(抽象 )</h2><p>关系运算符：</p><blockquote><p>集合运算符</p><p>比较运算符</p><p>关系运算符</p><p>逻辑运算符</p></blockquote><p>关系代数的操作：</p><blockquote><p>集合运算：并、差、交、笛卡尔积</p><p>关系运算：投影、选择、连接、除、更名</p><p>扩展的关系运算：广义投影、聚集函数、分组、递归闭包</p></blockquote><p><strong><em>专门的关系运算</em></strong></p><blockquote><p>选择运算($\sigma$)：选择符合条件的元组组成新的关系。取R中符合条件的元组：</p><p>$\sigma_{条件}(R)$</p><p>投影运算($\pi$)：选择符合条件的属性组成新的关系。取关系R的第i、j列：</p><p>$\pi_{i,j}(R)$</p><p>连接运算($\infin$)</p><p>自然连接：$R_1\infin R_2$</p><ul><li>计算关系间的笛卡尔积<ul><li>选择在两个关系中属性相等的元组</li></ul></li><li><p>删除重复属性</p><p>外连接</p><p>条件连接：$R|\times|S_{条件}$</p></li><li><p>$\sigma_{条件}(R\times S)$</p></li></ul><p>除运算($\div$)</p><p> $A(x, y)\div B(y,z)$</p><ul><li>找出x的域，对应每一个x取值，求出对应的象集t</li><li>求出投影$\pi_y(R_2)$</li><li>找出t中包含投影的值，即为除运算结果</li></ul><p>更名运算($\rho$)</p><p> $\rho_{新表名(新属性名)(R)}$</p></blockquote><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>sql提供的功能</p><ul><li>数据定义功能（DDL）</li><li>数据操纵功能（DML）</li><li>数据控制功能（DCL)</li><li>数据查询功能（DQL)</li></ul><p>sql的特点</p><ul><li>非过程化语言</li><li>统一的语言</li><li>面向集合的操作方式</li><li>可独立使用又可嵌入主语言使用</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">操作对象</th><th style="text-align:center">创建</th><th style="text-align:center">修改</th><th style="text-align:center">删除</th></tr></thead><tbody><tr><td style="text-align:center">数据库</td><td style="text-align:center">create database</td><td style="text-align:center">alter database</td><td style="text-align:center">drop database</td></tr><tr><td style="text-align:center">表</td><td style="text-align:center">create table</td><td style="text-align:center">alter table</td><td style="text-align:center">drop table</td></tr><tr><td style="text-align:center">视图</td><td style="text-align:center">create view</td><td style="text-align:center"></td><td style="text-align:center">drop view</td></tr><tr><td style="text-align:center">索引</td><td style="text-align:center">create index</td><td style="text-align:center"></td><td style="text-align:center">drop index</td></tr></tbody></table></div><p>在表中插入元组：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO &lt;table&gt;[(属性列表)] VALUES(属性值列表);<br>INSERT INTO &lt;table&gt;[(属性列表)] 子查询;<br></code></pre></td></tr></table></figure><p>更新表数据：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE &lt;table&gt;<br>SET &lt;属性列&gt;&#x3D;&lt;表达式&gt;[,&lt;属性列2&gt;&#x3D;&lt;&gt;, ...]<br>WHERE &lt;条件&gt;<br></code></pre></td></tr></table></figure><p>删除表元组</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM &lt;table&gt; [WHERE &lt;元组选择条件&gt;]<br></code></pre></td></tr></table></figure><p>修改表的命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALETR TABLE table_name<br>[ADD &lt;新列名&gt; &lt;数据类型&gt; &lt;约束&gt;<br>|ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;<br>|DROP COLUMN &lt;列名&gt;<br>|ADD CONSTRAINT &lt;约束名&gt; &lt;约束定义&gt;<br>|MODIFY CONSTRAINT &lt;列名&gt; &lt;约束定义&gt;<br>|DROP CONSTRAINT &lt;约束名&gt;]; <br></code></pre></td></tr></table></figure><p>查询表的命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [DISTINCT|ALL] &lt;*|属性列[AS 新的列名]&gt;<br>&lt;FROM&gt; &lt;表名|视图名|&gt; [别名]<br>[INTO &lt;新表名&gt;]<br>[WHERE &lt;条件&gt;]<br>[GROUP BY &lt;分组依据&gt;]<br>[HAVING &lt;分组选择条件&gt;]<br>[ORDER BY &lt;排序依据&gt;[ASC|DESC]];<br></code></pre></td></tr></table></figure><p>WHERE后接判断：</p><blockquote><p>属性 <strong>[NOT] BETWEEN</strong> constant1 <strong>AND</strong> constant2</p><p>属性 <strong>[NOT] LIKE</strong> 字符串或通配符</p><p>属性 <strong>IS [NOT] NULL</strong></p><p>属性|常量 <strong>[NOT] IN</strong> (SELECT 子句)|元组</p><p><strong>[NOT] EXITS</strong> (SELECT 子句) </p></blockquote><p><strong>LIKE</strong> 匹配的通配符</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">_</td><td style="text-align:center">匹配任意一个字符</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">匹配任意长度字符</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">查询一定范围字符(类似正则表达式)</td></tr><tr><td style="text-align:center"><sup><a href="#fn_" id="reffn_"></a></sup></td><td style="text-align:center">[]的非</td></tr><tr><td style="text-align:center">字符串本身含有’_’、’%’</td><td style="text-align:center">使用<strong>ESCAPE</strong> ‘string’或 <strong>‘\’</strong> 转义</td></tr></tbody></table></div><p>聚集函数（只能出现在select、having中，不能在where中出现）</p><blockquote><p>出现在分组依据中的属性名不能出现在聚集函数中</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">聚集函数使用</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">count(*)</td><td style="text-align:center">统计属性元组个数</td></tr><tr><td style="text-align:center">count([DISTINCT] 属性名)</td><td style="text-align:center">统计属性名下[不重复]的非空分量个数</td></tr><tr><td style="text-align:center">sum([DISTINCT] 属性名)</td><td style="text-align:center">对属性名下所有[不重复]分量求和</td></tr><tr><td style="text-align:center">avg([DISTINCT] 属性名)</td><td style="text-align:center">对属性名下所有[不重复]分量均值</td></tr><tr><td style="text-align:center">max(属性名)</td><td style="text-align:center">求属性列下最大值</td></tr><tr><td style="text-align:center">min(属性名)</td><td style="text-align:center">求属性列下最小值</td></tr></tbody></table></div><p>分组</p><blockquote><p>除聚集函数之外，select中出现的属性必须来自group by中的属性列</p></blockquote><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>连接操作执行的方法：</p><ul><li>循环嵌套法</li><li>排序合并法</li><li>索引连接法</li></ul><p>连接方式</p><ul><li><p>内连接</p><ol><li><strong>FROM</strong> table1 <strong>JOIN</strong> table2 <strong>ON</strong> &lt;连接条件&gt;</li><li><strong>WHERE</strong> &lt;连接条件&gt;</li><li>自然连接</li></ol></li><li><p>自连接</p><blockquote><p>同一张表内子表之间的连接查询</p></blockquote></li><li><p>外连接</p><ol><li><p>SQL SERVER</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT &lt;查询列表&gt;<br>[INTO &lt;新表名&gt;]<br>FROM &lt;table1|view1&gt; [AS new_name1]<br>&lt;LEFT|RIGHT|FULL&gt;[OUTER] JOIN&gt;<br>&lt;table2|view2&gt; [AS new_name2]<br>ON &lt;连接条件&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>WHERE</strong> A <strong>(+)=</strong> B #ORACLE数据库左外连接</p></li><li><p><strong>WHERE</strong> A <strong>=(+)</strong> B #ORACLE数据库右外连接</p></li></ol><ul><li><p>LEFT OUTER JOIN: 左外连接</p><p>输出左表所有记录列值，右表输出与左表向匹配的记录，没有输出NULL</p></li><li><p>RIGHT OUTER JOIN：右外连接</p><p>输出右表所有记录列值，左表输出与右表向匹配的记录，没有输出NULL</p></li><li><p>FULL OUTER JOIN：全连接</p><p>$left_outer_join \cup right_outer_join$</p></li></ul><p><strong>TOP</strong>限制结果集</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT TOP n [WITH TIES] &lt;column_name&gt;<br></code></pre></td></tr></table></figure><blockquote><ul><li>使用 <strong>WITH TIES</strong>会将并列值捆绑，同时输出，并算作同一排名</li></ul></blockquote><p><strong>ANY ALL</strong></p><blockquote><p>ANY: 至少一个值要满足条件</p><p>ALL：所有值都满足条件</p><ul><li>eg.找出年龄大于所有女性的男性客户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name, age<br>from user<br>where sex&#x3D;&#39;male&#39; and age &gt; ALL(select age from user where sex&#x3D;&#39;female&#39;); <br></code></pre></td></tr></table></figure></blockquote></li></ul><hr><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>定义</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW &lt;view_name&gt; [(view list)]<br>AS &lt;子查询&gt;<br>[&lt;WITH CHECK OPTION&gt;];<br></code></pre></td></tr></table></figure><blockquote><p>以下情况需要指定view list：</p><ul><li>子查询中有聚集函数或者列表达式</li><li>多表连接出现相同属性名</li><li>需要给属性更名</li></ul><p><strong>子查询限制</strong>：</p><p>不能含有<strong>ORDER BY</strong></p><p>不能含有<strong>DISTINCT</strong></p></blockquote><p>删除</p><blockquote><p><strong>DROP VIEW</strong> view_name <strong>[CASCADE]</strong>;</p><ul><li>加CASCADE后会联级删除该视图与其导出的所有视图</li></ul></blockquote><p>查询</p><blockquote><p>与关系的查询相同</p></blockquote><p>更新</p><blockquote><p>只有满足以下所有条件的视图才能对基表进行更新操作：</p><ul><li>视图只定义在一个基表上</li><li>子查询不含 <strong>GROUP BY、DISTINCT、</strong>聚集函数</li><li>视图列不含计算表达式</li><li>视图列包含所有基表中<strong>NOT NULL</strong>的列</li></ul></blockquote><p>作用</p><ul><li>视图能简化用户操作</li><li>视图对重构的数据库提供一定程度的逻辑独立性</li><li>视图为用户提供多个视角看同一数据</li><li>提高数据安全性</li><li>保证数据完整性</li></ul><hr><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>特点：空间换时间(hash)</p><p>分类</p><blockquote><ul><li><p>聚簇索引</p><p>索引与数据储存在相邻等待数据空间，并使行的物理顺序和索引的顺序一致</p><p>对经常搜索<strong>范围值</strong>的列非常有效</p></li><li><p>非聚簇索引</p><p>数据和索引分开存储，索引以指针指向数据</p><p><strong>精确匹配</strong>查询最佳方法</p></li><li><p>唯一索引</p><p>保证索引列不含重复值</p><p>创建<strong>PRIMARY KEY</strong>或<strong>UNIQUE</strong>约束会自动在表上场景唯一索引</p></li></ul></blockquote><p>创建</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#NONCLUSTERED：非聚簇索引<br>#CLUSTERED：聚簇索引<br>#UNIQUE：唯一索引<br><br>CREATE [UNIQUE][CLUSTERED][NONCLUSTERED] INDEX &lt;索引名&gt;<br>ON &lt;表名|视图名&gt; (列名[ASC|DESC]);<br><br>#eg.按ID和姓名创建用户的唯一索引<br>CREATE UNIQUE INDEX idIndex<br>ON web_user(user_id ASC, user_name DESC);<br></code></pre></td></tr></table></figure><p>删除</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP INDEX [user_name] &lt;index_name&gt;;<br></code></pre></td></tr></table></figure><p>索引建立原则</p><blockquote><ul><li>选择数据量大的表建立索引</li><li>索引建立数量要适量</li><li>选择合适时机建立索引</li><li>优先选择主键建立索引</li><li>为支撑连接操作，考虑在外码上建立非聚簇索引</li><li>最好选择包含大量非重复值的列建立非聚簇索引</li></ul></blockquote><hr><p>SQL server的三类操作系统文件</p><ul><li>主文件 .mdf： <strong>数据库启动信息</strong>及<strong>数据信息</strong>，每个数据库<strong>只有1个</strong></li><li>次要文件 .ndf：主文件以外的所有信息， 可以有<strong>多</strong>个</li><li>事务日志 .ldf：恢复数据库的日志信息，每个数据库<strong>至少有1个</strong></li></ul><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><p>分类</p><ul><li>类型约束</li><li>属性约束</li><li>关系变量约束</li><li>数据库约束</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">约束</th><th style="text-align:center">含义</th><th style="text-align:center">条件</th></tr></thead><tbody><tr><td style="text-align:center">PRIMARY KEY</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UNIQUE</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">NOT NULL</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CHECK</td><td style="text-align:center">约束属性范围</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">FOREIGN KEY</td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>授予权限</p><blockquote><p><strong>GRANT</strong> 权限 <strong>ON</strong> TABLE_NAME <strong>TO</strong> USERNAME <strong><em>[WITH GRANT OPTION]</em></strong></p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT UPDATE(age) ON table TO kkyou WITH GRANT OPTION; <br></code></pre></td></tr></table></figure><blockquote><p>表示将更新table表的age属性的权限授予kkyou用户， 并且kkyou用户可以将自己的权限授予他人</p></blockquote><p>角色</p><blockquote><p>创建角色</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT ROLE Adam; #创建角色Adam<br>GRANT SELECT ON user TO Adam; #将查询user表的权限分配给Adam<br>GRANT Adam TO kkyou; #将角色Adam授予用户kkyou<br>GRANT Adam TO qiao; #将角色Adam授予用户qiao<br></code></pre></td></tr></table></figure><p>收回权限</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REVOKE [WITH GRANT OPTION FOR] 权限 ON TABLE_NAME FROM USER_NAME;<br></code></pre></td></tr></table></figure><h2 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>定义</p><blockquote><p>事务是用户定义的一个数据库操作序列，每个事务都是不可分割的整体</p></blockquote><p>事务相关的命令</p><blockquote><p><strong>BEGIN TRANSACTION</strong> #开始事务</p><p><strong>ROLLBACK</strong> #执行错误，回滚，撤销所有操作</p><p><strong>COMMIT</strong> #执行成功，提交事务</p><p><strong>END TRANSACTION</strong> #结束事务</p></blockquote><p>事务的ACID特性</p><blockquote><ul><li><p>原子性Atomic: 事务操作要么全部执行，要么都不执行，不可分割</p></li><li><p>一致性Consistent: 事务单独运行时（没有并发运行的其它事务），应保证数据库的一致性</p></li><li><p>隔离性Isolation: 多事务并发执行，每个事务之间不可相互干扰</p></li><li><p>持续性Duration: 事务一旦提交，它对数据库的数据改变应该是永久的</p></li></ul></blockquote><h4 id="数据库恢复-1"><a href="#数据库恢复-1" class="headerlink" title="数据库恢复"></a>数据库恢复</h4><p>需要解决的问题</p><blockquote><ul><li>如何建立冗余数据</li><li>如何利用冗余数据恢复数据库</li></ul></blockquote><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>定义</p><blockquote><p>日志是DBMS用来记录事务对数据库进行更新操作的文件</p></blockquote><p>描述内容</p><blockquote><ul><li>事务标识符：事务的唯一标识符</li><li>数据项标识符：事务操作对象的唯一标识符</li><li>前像(BI)：更新前数据的旧值</li><li>后像(AI)：更新后数据的新值</li></ul></blockquote><p>日志存储</p><blockquote><p>先存入缓冲区，再存入稳定的储存器</p></blockquote><p>记录形式</p><blockquote><ul><li>\<T START> 事务T已经开始</li><li>\<T COMMIT> 事务T成功提交</li><li>\<T ABORT> 事务T不能成功完成，已终止</li><li>\<T,X,V1,V2> 事务T对数据项X进行操作，前像为V1，后像为V2</li></ul></blockquote><p>先写日志规则</p><blockquote><ul><li>在主存中的数据块输出到数据库之前，所有与该数据库有关的日志记录必须已输出到稳定的储存器上(先更新日志，再更新数据库)</li><li>事务要进入提交状态，必须是事务的日志，包括COMMIT记录都写入稳定存储器</li></ul></blockquote><h4 id="保持事务原子性的三种方案"><a href="#保持事务原子性的三种方案" class="headerlink" title="保持事务原子性的三种方案"></a>保持事务原子性的三种方案</h4><blockquote><ul><li><p>后像(BI)在事务提交之后再写入数据库(恢复将数据更新为新值)</p><p>缺点：增加事务平均缓冲的次数</p><p>日志记录： <strong>\<T,X,V\>,</strong> V为后像，不储存前像。</p></li></ul></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">动作</th><th style="text-align:center">日志</th></tr></thead><tbody><tr><td style="text-align:center">READ(data1</td><td style="text-align:center">\<T START\></td></tr><tr><td style="text-align:center">change data1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">WRITE(data1)</td><td style="text-align:center">\<T,data1, new_data1></td></tr><tr><td style="text-align:center">$\dots$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">\<T,COMMIT></td></tr><tr><td style="text-align:center">将数据写入磁盘(数据库)</td></tr></tbody></table></div><blockquote><p>   <strong>恢复步骤</strong>(从前向后，改为最后的新值)</p><ul><li>从后向前扫描日志文件，将COMMIT的事务放入redo-list中<ul><li>从前向后扫描日志文件，对每个\<T,X,V>记录:</li><li>若T不是redo-list中的事务，则什么都不做</li><li>若T是redo-list中的事务，则将新值V写入磁盘</li></ul></li><li>对未完成的事务，在日志文件中写入\<T,ABORT>记录并刷新日志</li></ul><ul><li><p>后像(AI)在事务提交前完全写入数据库(恢复将数据改回旧值)</p><p> 缺点：增加磁盘I/O次数</p><p> 日志记录： <strong>\<T,X,V\></strong> V为前像，不储存后像。</p><p> 要保证系统故障后恢复，需满足：</p><ul><li>记录数据变化的日志记录要在数据项写入磁盘前写入稳定的存储器</li><li>COMMIT日志记录要在数据项写入磁盘后再写入稳定的存储器</li></ul></li></ul></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">动作</th><th style="text-align:center">日志</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">\<T,START></td></tr><tr><td style="text-align:center">READ(data1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">change data1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">WRITE(data1)</td><td style="text-align:center">\<T,data1,V1></td></tr><tr><td style="text-align:center">$\dots$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">更新数据到磁盘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">\<T,COMMIT></td></tr></tbody></table></div><blockquote><pre><code>**恢复步骤** (从后向前，改为最初的旧值)</code></pre><ul><li>对日志文件从后向前扫描，将<T, COMMIT>的事务放入redo-list中</li><li>对每一个<T,X,V>，若T不在redo-list中，则什么都不做</li><li>对每一个<T,X,V>，若T在redo-list中，则将X置为旧值V</li></ul><ul><li><p>后像(AI)在事务提交前后写入数据库</p><p> 日志记录：\<T,X,V1,V2></p><p> <strong>恢复步骤</strong>(已提交记录设为新值，未提交记录回滚为旧值)</p><ul><li>对日志文件从后向前扫描，对有COMMIT记录和没有的事务分别放两个队列：redo-list、undo-list</li><li>从前向后扫描日志文件，重新执行redo-list中的事务</li><li>从后向前扫描日志文件，撤销执行undo-list中的事务</li></ul></li></ul></blockquote><hr><p>创建检查点的方法</p><blockquote><ul><li><p>提交一致性检查点</p><ul><li>新的事务不能开始直到检查点完成</li><li>现有的事务继续执行到提交或中止，并将相关日志都写入稳定存储器</li><li>将当前日志缓冲区中的日志写回稳定存储器中的日志文件</li><li>将日志记录<strong>\<CHECKPOINT></strong>写入存储器</li></ul></li></ul><p>   检查点之前的事务都已经完成，因此无需恢复之前的数据。</p><p>   恢复时，从后向前扫描日志，<strong>\<CHECKPOINT></strong>后的记录都要恢复</p><ul><li><p>高速缓存一致性检查点</p><ul><li>新的事务不能开始直到检查点完成</li><li>已存在的事务不允许进行更新操作</li><li>将当前日志缓冲区中的日志写回稳定存储器中的日志文件</li><li>将数据缓冲区的所有数据写入磁盘</li><li>将日志记录<strong>\<CHECKPOINT，L></strong>写入存储器，L是所有活动事务的列表</li></ul></li></ul><p>   检查点前：事务已提交，不处理</p><p>   检查点中：事务处于活动状态，若事务提交，执行REDO，否则执行UNDO</p><p>   若后像在事务提交后才写入数据库，没有提交记录时，不必UNDO</p><p>   若后像在事务提交前写入数据库，有提交记录，不必执行REDO</p><ul><li>模糊一致性检查点</li></ul></blockquote><p>数据转储</p><blockquote><p>备份级别</p><ul><li>完全转储：备份整个数据库</li><li>增量备份：只备份上次备份后改变的数据</li></ul><p>转储分类</p><ul><li>静态转储：转储期间不允许有事务进行</li><li>动态转储：转储期间允许事务对数据库进行更新(需要用日志记录纠正数据库不一致状态)</li></ul></blockquote><p>故障类型</p><blockquote><ul><li><p>事务故障</p><ul><li>逻辑错误(错误输入、找不到数据、溢出等)</li><li><p>系统错误(系统进入不良状态，如死锁)</p><p>恢复：使用之前的三种方案中的一种即可</p></li></ul></li><li><p>系统故障：硬件、软件故障</p><p> 恢复：使用之前的三种方案中的一种即可</p></li><li><p>介质故障：数据传输过程中发生的内容错误</p><p> 恢复：完成转储备份工作</p></li></ul></blockquote><h4 id="RAID-冗余磁盘阵列"><a href="#RAID-冗余磁盘阵列" class="headerlink" title="RAID(冗余磁盘阵列)"></a>RAID(冗余磁盘阵列)</h4><p>目的：应对介质故障带来的严重影响</p><p>优点</p><ul><li>成本低、功耗小、传输效率高</li><li>可提供容错功能</li><li>具备数据校验功能</li></ul><h2 id="事务的并发控制"><a href="#事务的并发控制" class="headerlink" title="事务的并发控制"></a>事务的并发控制</h2><p>优点</p><ul><li>改善系统资源利用</li><li>简短事务等待时间</li></ul><p>调度：事务按时间排序的序列</p><p>串行调度：事务是一个个执行的(n个事务进行串行调度，有n!种方式)</p><p>交叉调度可能引起的问题</p><blockquote><ul><li><p>读脏数据</p><p>脏数据：未提交事务所写的数据（读了ROLLBACK之前的数据）</p></li><li><p>不可重复读（两次读到不同的数据）</p></li><li><p>丢失修改（两个事务同时修改数据，其中一个事务的修改丢失）</p></li></ul></blockquote><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><blockquote><p>若多个事务交叉调度和某一串行调度的结果相同时，该调度为可串行化的</p></blockquote><h5 id="冲突可串行化"><a href="#冲突可串行化" class="headerlink" title="冲突可串行化"></a>冲突可串行化</h5><blockquote><p>多事务交叉调度发生冲突的条件</p><ul><li><strong>不同事务</strong>对同一数据操作</li><li><strong>不同事务</strong>操作指令中含W操作</li></ul><p>冲突可串行化判断方法：</p><p>交换调度S不冲突的指令，得到新的调度S’。S和S’是<strong>冲突等价</strong>的，若一个调度冲突等价于一个串行调度，则该调度室冲突可串行化的。</p></blockquote><h5 id="视图可串行化"><a href="#视图可串行化" class="headerlink" title="视图可串行化"></a>视图可串行化</h5><blockquote><p>对同一事务集，若事务在任何时候都读到相同的值，写入数据库的最终状态也是相同的，则称事务<strong>视图等价</strong></p></blockquote><p>可串行化判断</p><blockquote><ul><li>调度冲突等价于串行调度</li><li>前驱图（点为事务，产生冲突则连线，入度点为先执行的，若产生环，则不可串行调度）</li></ul></blockquote><p>可恢复条件</p><blockquote><p>不读脏数据(Ti读了Tj修改的数据，则Tj事务先提交，Ti后提交)</p></blockquote><h4 id="基于锁的并发控制协议"><a href="#基于锁的并发控制协议" class="headerlink" title="基于锁的并发控制协议"></a>基于锁的并发控制协议</h4><p>加锁方式(S和X锁之间都是不相容的)</p><ul><li>共享锁(S)：可读数据，不可写（申请队列为空，数据项没有排它锁，则可授予）SLOCK(Q)</li><li>排他锁(X)：可以读写数据（申请队列为空，数据项没有锁，则可授予）XLOCK(Q)</li><li>ULOCK(Q)：释放数据项Q的锁，事务提交或中止即可释放锁</li></ul><p>两段锁协议（2PL）</p><blockquote><p>保证冲突可串行化的充要条件，不能预防死锁</p></blockquote><ul><li>增长阶段：读写数据前，应首先获得数据的锁</li><li>收缩阶段：释放锁后，事务不再申请获得其他任何锁</li></ul><h4 id="活锁、死锁"><a href="#活锁、死锁" class="headerlink" title="活锁、死锁"></a>活锁、死锁</h4><p><strong>活锁</strong></p><blockquote><p>其他事务一直抢先得到锁，使得一个事务一直得不到锁</p></blockquote><p><strong>死锁</strong></p><blockquote><p>事务互相等待，形成死锁</p><p>死锁的预防</p><ul><li><p>顺序封锁法：事务对锁的申请按顺序进行</p></li><li><p>一次封锁法：事务执行前获得所有锁，若不能获得所需的所有锁，则事务中止</p><p> 缺点：事务开始前很难知道所需的所有锁、一次性获得所有锁，但有的锁会在很久之后使用，降低系统并发度</p></li><li><p>用时间戳的死锁预防：早运行的事务优先级高</p><ul><li>Wait-die机制：申请锁时，若事务相较冲突的事务优先级高，则等待，否则中止</li><li>Wound-wait机制：申请锁时，若事务相较冲突的事务优先级高，则中止正在使用锁的事务，否则事务等待</li></ul></li></ul><p>死锁的检测预防</p><ul><li><p>等待图（点为事务，当事务A等待B释放锁时，边由A连向B）</p></li><li><p>死锁解除:撤销事务</p><p> 需要解决的问题：</p><ul><li>撤销事务的选择</li><li>撤销事务的程度（全部回滚|部分回滚）</li></ul></li></ul></blockquote><h2 id="数据库设计理论"><a href="#数据库设计理论" class="headerlink" title="数据库设计理论"></a>数据库设计理论</h2><p>设计的不好的数据库可能出现的问题：</p><ul><li>数据冗余</li><li>操作异常<ul><li>更新异常</li><li>删除异常</li><li>插入异常</li></ul></li></ul><p><strong>模式分解</strong>是解决数据冗余的主要方法</p><p><strong>数据依赖包括</strong></p><ul><li>函数依赖</li><li>多值依赖</li><li>连接依赖</li></ul><p><strong>函数依赖</strong></p><blockquote><p>关系模式R(U)中，$X\subseteq U, Y\subseteq U$，若t[X] = s[X]，则有t[Y] = s[Y]，则称属性或属性组Y函数依赖于X</p><p>FD X$\to$Y  <em>(X:决定因子、Y：依赖因子)</em></p></blockquote><ul><li><p>平凡函数依赖</p><p>若$X\subseteq Y, 则X\to Y$</p></li><li><p>完全函数依赖</p></li><li><p>部分函数依赖</p></li><li><p>传递函数依赖</p><p>$X \to Y, Y \nrightarrow X, Y\rightarrow Z,则 Z对X传递函数依赖$</p><p>$X \to Y, Y \nrightarrow X, Y\rightarrow Z \models X\rightarrow Z$</p></li></ul><p>F的闭包：F和F所蕴含的依赖的全体</p><p>属性集的闭包</p><p>关系无损分解的判断方法</p><ul><li><p>追逐法</p></li><li><p>若关系被分解为两个关系，则无损分解的充要条件是：</p><p>$(U_1\cap U_2)\rightarrow (U_1 - U_2)$或</p><p>$(U_1\cap U_2)\rightarrow (U_2-U_1)$</p></li><li><p>$X\to Y 在R上成立，且X\cap Y=\phi，则{R-Y, XY}是无损分解$</p></li></ul><p><strong>保持函数依赖的分解的判断方法</strong></p><blockquote><p><script type="math/tex">\rho=\{R_1, R_2, \dots , R_k\}</script>执行以下算法：</p><p>Z=X</p><p>while Z 改变 do{</p><p>​    for i=1 to k{</p><p>​        $Z = Z\cup ((Z \cap U_i)^+\cap U_i)$</p><p>​    }</p><p>}</p><p>若最终所有的Z包含正确的$Z^+$，则分解保持函数依赖</p></blockquote><h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><h4 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h4><blockquote><p>每个属性值都是原子值</p></blockquote><h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><blockquote><p>每个非主属性都完全函数依赖于候选码</p></blockquote><h4 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h4><blockquote><p>每个非主属性都不传递依赖于候选码，每个非主属性都完全函数依赖于候选码</p><p>$2NF\subset 3NF$</p></blockquote><h4 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h4><blockquote><p>$R\in$ 1NF，且每个属性都不传递依赖于R的候选码，则R是BCNF模式</p></blockquote><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h4 id="数据库设计方法"><a href="#数据库设计方法" class="headerlink" title="数据库设计方法"></a>数据库设计方法</h4><ul><li>直观设计法</li><li>规范化设计法</li><li>面向对象设计法</li><li>计算机辅助方法</li></ul><h4 id="数据库设计的基本过程"><a href="#数据库设计的基本过程" class="headerlink" title="数据库设计的基本过程"></a>数据库设计的基本过程</h4><ul><li><p>需求分析阶段</p><p>需求调研</p><p>需求分析</p><p>编写需求分析说明书</p><p>需求分析说明书验证</p></li><li><p>概念设计阶段</p></li><li><p>逻辑设计阶段</p></li><li><p>物理设计阶段</p></li><li><p>实现阶段</p></li><li><p>运行和维护阶段</p></li></ul><h4 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h4><p>全局视图集成的重要工作：</p><ul><li>冲突消除</li><li>冗余消除与优化</li></ul><p>局部模式间的冲突：</p><ul><li>属性冲突</li><li>命名冲突</li><li>结构冲突</li></ul><h4 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h4><ul><li>数据项</li><li>数据结构</li><li>数据流</li><li>数据存储</li><li>数据处理</li></ul><p>存取方法设计</p><ul><li>聚簇</li><li>索引</li><li>hash</li></ul>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文艺复兴三杰的艺术风格</title>
    <link href="/2018/06/13/%E6%96%87%E8%89%BA%E5%A4%8D%E5%85%B4%E4%B8%89%E6%9D%B0%E7%9A%84%E8%89%BA%E6%9C%AF%E9%A3%8E%E6%A0%BC/"/>
    <url>/2018/06/13/%E6%96%87%E8%89%BA%E5%A4%8D%E5%85%B4%E4%B8%89%E6%9D%B0%E7%9A%84%E8%89%BA%E6%9C%AF%E9%A3%8E%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="./美术鉴赏.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>组合数学</title>
    <link href="/2018/05/06/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <url>/2018/05/06/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>​    </p><!--more--><h3 id="线排列"><a href="#线排列" class="headerlink" title="线排列"></a>线排列</h3><ul><li>$P(n, r) = \frac{n!}{(n-r)!}$</li><li>$P(n, r) = nP(n-1, r-1)$</li><li>$P(n,r) = rP(n-1, r-1) + P(n-1, r)$</li></ul><hr><h3 id="圆排列"><a href="#圆排列" class="headerlink" title="圆排列"></a>圆排列</h3><ul><li>$\frac{P(n,r)}{r} = \frac{n!}{r(n-r)!}$</li></ul><hr><h3 id="重排列"><a href="#重排列" class="headerlink" title="重排列"></a>重排列</h3><p>B=<script type="math/tex">\{\infty * b_1, \dots , \infty * b_n \}</script> 的r-排列：<script type="math/tex">n^r</script></p><hr><h3 id="无限重集的r-组合"><a href="#无限重集的r-组合" class="headerlink" title="无限重集的r-组合"></a>无限重集的r-组合</h3><ul><li>$F(n,r) = C(n + r - 1, r)$</li><li>$x_1 + x_2 + … + x_n = r  :  F(n, r)$</li></ul><hr><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><ul><li>$(x+y)^n=\sum_{k=0}^nC(n,k)x^ky^{n-k}$</li><li>$(x+y)^n=\sum_{k=0}^nC(n,n-k)x^ky^{n-k}$</li><li>$(1 + x)^n=\sum_{k=0}^nC(n, n - k)x^k$</li><li>$\frac{1}{1 - x} = \sum^{\infty}_{k=0}x^k$</li><li>$\frac{1}{1+x} = \sum^{\infty}_{k=0}(-1)^kx^k$</li><li>$(1+x)^{-n}=\sum_{k=0}^{\infty}(-1)^kC(n+k-1, k)x^k$</li></ul><hr><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>$\arrowvert \overline{A_1} \cap \overline{A_2} \cap \dots \cap \overline{A_n} \arrowvert = $</p><p>$ |S| - \sum|A_i| + \sum|A_i \cap A_j| - \sum|A_i \cap A_j \cap A_k| + … + (-1)^n|A_1 \cap A_2 \cap … A_n| $</p><hr><blockquote><p><em>一个整数能被Lcm(i, j)整除， 当且仅当它既能被i整除也能被j整除。</em></p></blockquote><ul><li>分类！</li></ul><h4 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h4><ul><li><script type="math/tex; mode=display">D_n=n!\sum_{k=0}^n(-1)^k\frac{1}{k!} \approx n!e^{-1}</script></li><li><script type="math/tex; mode=display">D_n = (n-1)(D_{n-1}+D_{n-2})</script></li></ul><h4 id="相对位置有限制排列问题"><a href="#相对位置有限制排列问题" class="headerlink" title="相对位置有限制排列问题"></a>相对位置有限制排列问题</h4><ul><li><script type="math/tex; mode=display">Q_n=\sum_{k=0}^{n-1}(-1)^kC(n-1, k)(n-k)!</script></li><li><script type="math/tex; mode=display">Q_n = D_n + D_{n-1}</script></li></ul><p><em>错排和相对位置有限制排列都可以用容斥原理直接做</em></p><h4 id="一般有限制排列"><a href="#一般有限制排列" class="headerlink" title="一般有限制排列"></a>一般有限制排列</h4><ul><li><p>$R(c) = xR(c_i) + R(c_e)$</p><blockquote><p>$c_i:删去A_i所在行列剩下的棋盘$</p><p>$c_e:删去A_i剩下的棋盘$</p></blockquote></li><li><p>对于相互独立的棋盘$C_1C_2$有：</p><blockquote><p>$R(c) = R(c_1)R(c_2)$</p></blockquote></li><li><p>n元有禁位排列数：</p><blockquote><p>$n! - r_1(n-1)! + r_2(n-2)! + … + r_n(-1)^n$</p></blockquote></li></ul><hr><h3 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h3><h4 id="普通母函数"><a href="#普通母函数" class="headerlink" title="普通母函数"></a>普通母函数</h4><script type="math/tex; mode=display">f(x) = \sum_{i=0}^{\infty}a_ix^i</script><script type="math/tex; mode=display">C(x) = A(x) + B(x)\Leftrightarrow c_i=a_i+b_i</script><script type="math/tex; mode=display">C(x) = A(x)B(x) \Leftrightarrow c_i= \sum_{k=0}^ia_kb_{i-k}</script><h4 id="指数母函数"><a href="#指数母函数" class="headerlink" title="指数母函数"></a>指数母函数</h4><script type="math/tex; mode=display">f_e(x) = \sum_{i=0}^{\infty}a_i\frac{x^n}{i!}</script><script type="math/tex; mode=display">C(x) = A(x) + B(x) \Leftrightarrow c_i = a_i + b_i</script><script type="math/tex; mode=display">C(x) = A(x)B(x) \Leftrightarrow c_i = \sum_{k=0}^i\lgroup_k^i\rgroup a_kb_{i-k}</script><ul><li><p><em>$f(x) = \int_{0}^{\infty}e^{-s}f_e(sx)d_s$</em></p></li><li><p><em>$e^x=\sum_{i=0}^\infty \frac{x^i}{i!}$</em></p></li><li><p><em>$\frac{e^{-x}+e^x}{2} = 1 + \frac{x^2}{2!} + \frac{x^4}{4!} …$</em></p></li><li><p>$e^{ax} = \sum_{n=0}^{\infty}a^n\frac{x^n}{n!}$*</p></li></ul><hr><h3 id="常系数线性齐次递归关系"><a href="#常系数线性齐次递归关系" class="headerlink" title="常系数线性齐次递归关系"></a>常系数线性齐次递归关系</h3><ul><li>q是方程的m重根，则$q^n,  nq^n, …, n^{m-1}q^n$都是a_n的解</li><li>q是方程的1重根，则$q^n$是方程的解</li></ul><h3 id="非齐次递归关系"><a href="#非齐次递归关系" class="headerlink" title="非齐次递归关系"></a>非齐次递归关系</h3><blockquote><p>$a_n = \overline{a_n} + a_n^*$</p></blockquote><p>$\overline{a_n}$：非齐次的特解</p><p>$a_n^*:$齐次的通解</p><hr><h5 id="f-n-是n的k次多项式："><a href="#f-n-是n的k次多项式：" class="headerlink" title="f(n) 是n的k次多项式："></a>f(n) 是n的k次多项式：</h5><ul><li>1不是齐次方程的特征根<ul><li>$\overline{a_n} = A_0n^k + A_1n^{k-1} + … + A_k$</li></ul></li><li>1是齐次方程的m重特征根<ul><li>$\overline{a_n} = (A_0n^k + A_1n^{k-1} + … + A_k)n^m$</li></ul></li></ul><h5 id="f-n-是-beta-n-的形式时："><a href="#f-n-是-beta-n-的形式时：" class="headerlink" title="f(n)是$\beta^n$的形式时："></a>f(n)是$\beta^n$的形式时：</h5><ul><li>$\beta$不是齐次方程的特征根<ul><li>$\overline{a_n} = A \dot \beta^n$</li></ul></li><li>$\beta$是齐次方程的m重特征根<ul><li>$\overline{a_n} = An^m\beta^n$</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Lecture Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
